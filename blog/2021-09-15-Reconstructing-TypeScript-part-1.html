<html><head><title>Reconstructing TypeScript, part 1: bidirectional type checking</title><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/2021-09-15-Reconstructing-TypeScript-part-1.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.bOWasK{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;overflow:auto;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"bOWasK,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.oxVOu{color:#000000;}/*!sc*/
data-styled.g45[id="sc-iTVJFM"]{content:"oxVOu,"}/*!sc*/
.lmGFyU{color:#aa1111;}/*!sc*/
data-styled.g48[id="sc-cTJkRt"]{content:"lmGFyU,"}/*!sc*/
.jIfccS{color:#268bd2;}/*!sc*/
data-styled.g49[id="sc-jNnpgg"]{content:"jIfccS,"}/*!sc*/
.fqbJCS{color:#770088;}/*!sc*/
data-styled.g50[id="sc-dPaNzc"]{content:"fqbJCS,"}/*!sc*/
.cdTyhF{color:#b58900;}/*!sc*/
data-styled.g51[id="sc-bBjRSN"]{content:"cdTyhF,"}/*!sc*/
.haQoIp{color:#009900;}/*!sc*/
data-styled.g52[id="sc-cOifOu"]{content:"haQoIp,"}/*!sc*/
.eJDRKz{color:#116644;}/*!sc*/
data-styled.g53[id="sc-Arkif"]{content:"eJDRKz,"}/*!sc*/
.hQhHpX{color:#221199;}/*!sc*/
data-styled.g54[id="sc-khIgEk"]{content:"hQhHpX,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript, part 1</span></p><h1><span>Reconstructing TypeScript, part 1: bidirectional type checking</span></h1><h3><span><em>2021-09-15</em></span></h3><p><span>This post is part of a series about implementing type checking for a TypeScript-like language. In the </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>last post </span></a><span> I gave some background about type checking, TypeScript&#x27;s type system, and the approach we&#x27;ll use, called </span><span><em>bidirectional type checking</em></span><span>.</span></p><p><span>Now let&#x27;s write a type checker! We&#x27;re going to start with a tiny fragment of the language, and build it up incrementally in subsequent posts. In this fragment we&#x27;ll handle only primitive literals like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-Arkif eJDRKz">7</span>
<span class="sc-cTJkRt lmGFyU">&quot;TypeScript is cool.&quot;</span>
<span class="sc-khIgEk hQhHpX">false</span></code></pre><p><span>object literals like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">{</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">7</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">9</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-iTVJFM oxVOu">{</span> foo<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;bar&quot;</span><span class="sc-iTVJFM oxVOu">,</span> baz<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-khIgEk hQhHpX">false</span> <span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>and member expressions like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">{</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">7</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">9</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">.</span>x</code></pre><p><span>(We don&#x27;t have variables yet, so member expressions look a little weird!)</span></p><p><span>We&#x27;ll also handle </span><span><em>type ascriptions</em></span><span> like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">{</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">7</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;foo&quot;</span> <span class="sc-iTVJFM oxVOu">}</span> <span class="sc-dPaNzc fqbJCS">as</span> <span class="sc-iTVJFM oxVOu">{</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span> <span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>In actual TypeScript, </span><span><code>as</code></span><span> is an unsafe cast, a way to tell the type checker, &quot;trust me, this expression has this type!&quot; Here it is a way to guide the type checker (more on this below), but it&#x27;s not unsafeâ€”the type checker still ensures that the program doesn&#x27;t attempt any unsupported operations.</span></p><h2><span>Parsing code into an abstract syntax tree</span></h2><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> that type checking works on an </span><span><em>abstract syntax tree</em></span><span> representation of code, where each expression in a program is a node in the tree, with its subexpressions as children. So first we need to parse code strings to ASTs. We use </span><a href="https://babeljs.io/docs/en/babel-parser" class="sc-gtsrHT kFWJEY"><span>@babel/parser</span></a><span> with the TypeScript plugin (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/ast/parse.ts" class="sc-gtsrHT kFWJEY"><span>parse.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">parseExpression</span><span class="sc-iTVJFM oxVOu">(</span>input<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">string</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> Expression <span class="sc-iTVJFM oxVOu">{</span>
  <span class="sc-dPaNzc fqbJCS">return</span> Babel<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">parseExpression</span><span class="sc-iTVJFM oxVOu">(</span>input<span class="sc-iTVJFM oxVOu">,</span> <span class="sc-iTVJFM oxVOu">{</span>
    plugins<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">[</span> <span class="sc-cTJkRt lmGFyU">&#x27;typescript&#x27;</span> <span class="sc-iTVJFM oxVOu">]</span>
  <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>which produces a value of type </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2058" class="sc-gtsrHT kFWJEY"><span><code>Expression</code></span></a><span> from </span><a href="https://babeljs.io/docs/en/babel-types" class="sc-gtsrHT kFWJEY"><span>@babel/types</span></a><span>. For example, if we call </span><span><code>parseExpression</code></span><span> on an object expression</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">{</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">7</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">9</span> <span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>we get an </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L611" class="sc-gtsrHT kFWJEY"><span><code>ObjectExpression</code></span></a><span> AST with </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L634" class="sc-gtsrHT kFWJEY"><span><code>ObjectProperty</code></span></a><span> ASTs as children:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">{</span>
  type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;ObjectExpression&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
  properties<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">[</span>
    <span class="sc-iTVJFM oxVOu">{</span>
      type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;ObjectProperty&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
      key<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Identifier&quot;</span><span class="sc-iTVJFM oxVOu">,</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;x&quot;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
      value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;NumericLiteral&quot;</span><span class="sc-iTVJFM oxVOu">,</span> value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">7</span> <span class="sc-iTVJFM oxVOu">}</span>
    <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
    <span class="sc-iTVJFM oxVOu">{</span>
      type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;ObjectProperty&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
      key<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Identifier&quot;</span><span class="sc-iTVJFM oxVOu">,</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;y&quot;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
      value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;NumericLiteral&quot;</span><span class="sc-iTVJFM oxVOu">,</span> value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">9</span> <span class="sc-iTVJFM oxVOu">}</span>
    <span class="sc-iTVJFM oxVOu">}</span>
  <span class="sc-iTVJFM oxVOu">]</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>Each node has a </span><span><code>type</code></span><span> property saying what kind of syntax it represents, and each kind of node has kind-specific properties for subexpressions and other attributes. (I&#x27;ve trimmed out properties that describe the location of each AST node in the original code string.)</span></p><p><span>To keep things simple, our type checker will handle only expressions, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cTJkRt lmGFyU">&quot;TypeScript is cool&quot;</span>
<span class="sc-iTVJFM oxVOu">{</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">7</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">9</span> <span class="sc-iTVJFM oxVOu">}</span>
x <span class="sc-iTVJFM oxVOu">&gt;</span> <span class="sc-Arkif eJDRKz">0</span> <span class="sc-iTVJFM oxVOu">?</span> x <span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">-</span>x</code></pre><p><span>not statements, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">const</span> x <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-Arkif eJDRKz">7</span>
<span class="sc-dPaNzc fqbJCS">for</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-dPaNzc fqbJCS">let</span> i <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-Arkif eJDRKz">0</span><span class="sc-iTVJFM oxVOu">;</span> i <span class="sc-iTVJFM oxVOu">&lt;</span> <span class="sc-Arkif eJDRKz">10</span><span class="sc-iTVJFM oxVOu">;</span> i<span class="sc-iTVJFM oxVOu">++</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">{</span> <span class="sc-iTVJFM oxVOu">...</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-dPaNzc fqbJCS">throw</span> <span class="sc-dPaNzc fqbJCS">new</span> <span class="sc-iTVJFM oxVOu">Error</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-cTJkRt lmGFyU">&quot;bad thing&quot;</span><span class="sc-iTVJFM oxVOu">)</span></code></pre><p><span>so we only need to parse expressions. (We&#x27;ll also parse types, see below.)</span></p><p><span>The full </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2058" class="sc-gtsrHT kFWJEY"><span><code>Expression</code></span></a><span> type is pretty complicated, and it&#x27;s not always obvious what the different properties mean. So it&#x27;s really helpful to be able to browse the AST produced by a piece of code. I use the excellent </span><a href="https://astexplorer.net/" class="sc-gtsrHT kFWJEY"><span>AST Explorer</span></a><span> for this. (Set the language to </span><span><code>JavaScript</code></span><span> and the parser to </span><span><code>@babel/parser.</code></span><span> Then click the gear icon next to </span><span><code>@babel/parser</code></span><span>, enable the </span><span><code>typescript</code></span><span> plugin, and disable the </span><span><code>flow</code></span><span> plugin.)</span></p><p><span>Be aware that AST Explorer parses programs, not expressions; so if you feed it an expression, the AST is wrapped in </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L602" class="sc-gtsrHT kFWJEY"><span><code>Program</code></span></a><span> and </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L455" class="sc-gtsrHT kFWJEY"><span><code>ExpressionStatement</code></span></a><span> nodes. Usually it&#x27;s OK to write an expression where a statement is expected, but for object expressions you need to wrap parentheses around them, or else the parser sees </span><span><code>{</code></span><span> and tries to parse a block of statements.</span></p><h2><span>Representing types</span></h2><p><span>To synthesize and check types, we need a way to represent them. In this fragment we support only a few typesâ€”primitive literals, and objects made up of properties (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/types.ts" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">type</span> <span class="sc-iTVJFM oxVOu">Type</span> <span class="sc-iTVJFM oxVOu">=</span> Null <span class="sc-iTVJFM oxVOu">|</span> Boolean <span class="sc-iTVJFM oxVOu">|</span> Number <span class="sc-iTVJFM oxVOu">|</span> String <span class="sc-iTVJFM oxVOu">|</span> Object<span class="sc-iTVJFM oxVOu">;</span>

<span class="sc-dPaNzc fqbJCS">type</span> <span class="sc-iTVJFM oxVOu">Null</span> <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;Null&#x27;</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-dPaNzc fqbJCS">type</span> <span class="sc-iTVJFM oxVOu">Boolean</span> <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;Boolean&#x27;</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-dPaNzc fqbJCS">type</span> <span class="sc-iTVJFM oxVOu">Number</span> <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;Number&#x27;</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-dPaNzc fqbJCS">type</span> <span class="sc-iTVJFM oxVOu">String</span> <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;String&#x27;</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span>

<span class="sc-dPaNzc fqbJCS">type</span> <span class="sc-iTVJFM oxVOu">Object</span> <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-iTVJFM oxVOu">{</span>
  type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;Object&#x27;</span><span class="sc-iTVJFM oxVOu">;</span>
  properties<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">string</span><span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">:</span> Type <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">[</span><span class="sc-iTVJFM oxVOu">]</span><span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>For example, the type</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">{</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span> <span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>is represented by the value</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">{</span>
  type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;Object&#x27;</span><span class="sc-iTVJFM oxVOu">,</span>
  properties<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">[</span>
    <span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;x&#x27;</span><span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;Number&#x27;</span> <span class="sc-iTVJFM oxVOu">}</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
    <span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;y&#x27;</span><span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;Number&#x27;</span> <span class="sc-iTVJFM oxVOu">}</span> <span class="sc-iTVJFM oxVOu">}</span>
  <span class="sc-iTVJFM oxVOu">]</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><h3><span><em>Constructors</em></span></h3><p><span>We have predefined constants and helper functions to construct types (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/constructors.ts" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">const</span> nullType<span class="sc-iTVJFM oxVOu">:</span> Null <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;Null&#x27;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-dPaNzc fqbJCS">const</span> <span class="sc-jNnpgg jIfccS">boolean</span><span class="sc-iTVJFM oxVOu">:</span> Boolean <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;Boolean&#x27;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-dPaNzc fqbJCS">const</span> <span class="sc-jNnpgg jIfccS">number</span><span class="sc-iTVJFM oxVOu">:</span> Number <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;Number&#x27;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-dPaNzc fqbJCS">const</span> <span class="sc-jNnpgg jIfccS">string</span><span class="sc-iTVJFM oxVOu">:</span> String <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;String&#x27;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">;</span></code></pre><p><span>The properties of an object type are represented as an array, but it&#x27;s often convenient to construct object types by passing an object mapping names to types, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">const</span> type <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-bBjRSN cdTyhF">object</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">{</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span></code></pre><p><span>so the </span><span><code>object</code></span><span> constructor takes either an array of properties or an object mapping names to types:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">object</span><span class="sc-iTVJFM oxVOu">(</span>
  properties<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">string</span><span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">:</span> Type <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">[</span><span class="sc-iTVJFM oxVOu">]</span> <span class="sc-iTVJFM oxVOu">|</span> <span class="sc-iTVJFM oxVOu">{</span> <span class="sc-iTVJFM oxVOu">[</span>name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">string</span><span class="sc-iTVJFM oxVOu">]</span><span class="sc-iTVJFM oxVOu">:</span> Type <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> Object <span class="sc-iTVJFM oxVOu">{</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-jNnpgg jIfccS">Array</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isArray</span><span class="sc-iTVJFM oxVOu">(</span>properties<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">{</span>
    <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&#x27;Object&#x27;</span><span class="sc-iTVJFM oxVOu">,</span> properties <span class="sc-iTVJFM oxVOu">}</span>
  <span class="sc-iTVJFM oxVOu">}</span> <span class="sc-dPaNzc fqbJCS">else</span> <span class="sc-iTVJFM oxVOu">{</span>
    <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-bBjRSN cdTyhF">object</span><span class="sc-iTVJFM oxVOu">(</span>
      Object<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">entries</span><span class="sc-iTVJFM oxVOu">(</span>properties<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">map</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">[</span> name<span class="sc-iTVJFM oxVOu">,</span> type <span class="sc-iTVJFM oxVOu">]</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">=&gt;</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">,</span> <span class="sc-dPaNzc fqbJCS">type</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span>
    <span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>This is a nice example of the flexibility of union types: rather than define a separate function to convert an object argument to an array, we give the argument a union type. If </span><span><code>Array.isArray(properties)</code></span><span> is true, we know from the argument type that </span><span><code>properties</code></span><span> must be an array of </span><span><code>{ name: string, type: Type }</code></span><span> objects, so we can directly construct an </span><span><code>Object</code></span><span> type. Otherwise it must be an object mapping property names to </span><span><code>Type</code></span><span>s, so we walk the object entries to build an array.</span></p><h3><span><em>Validators</em></span></h3><p><span>We have validators for distinguishing different kinds of </span><span><code>Type</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/validators.ts" class="sc-gtsrHT kFWJEY"><span>validators.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">isNull</span><span class="sc-iTVJFM oxVOu">(</span>t<span class="sc-iTVJFM oxVOu">:</span> Type<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> t <span class="sc-dPaNzc fqbJCS">is</span> Null       <span class="sc-iTVJFM oxVOu">{</span> <span class="sc-dPaNzc fqbJCS">return</span> t<span class="sc-iTVJFM oxVOu">.</span>type <span class="sc-iTVJFM oxVOu">===</span> <span class="sc-cTJkRt lmGFyU">&#x27;Null&#x27;</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">isBoolean</span><span class="sc-iTVJFM oxVOu">(</span>t<span class="sc-iTVJFM oxVOu">:</span> Type<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> t <span class="sc-dPaNzc fqbJCS">is</span> Boolean <span class="sc-iTVJFM oxVOu">{</span> <span class="sc-dPaNzc fqbJCS">return</span> t<span class="sc-iTVJFM oxVOu">.</span>type <span class="sc-iTVJFM oxVOu">===</span> <span class="sc-cTJkRt lmGFyU">&#x27;Boolean&#x27;</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">isNumber</span><span class="sc-iTVJFM oxVOu">(</span>t<span class="sc-iTVJFM oxVOu">:</span> Type<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> t <span class="sc-dPaNzc fqbJCS">is</span> Number   <span class="sc-iTVJFM oxVOu">{</span> <span class="sc-dPaNzc fqbJCS">return</span> t<span class="sc-iTVJFM oxVOu">.</span>type <span class="sc-iTVJFM oxVOu">===</span> <span class="sc-cTJkRt lmGFyU">&#x27;Number&#x27;</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">isString</span><span class="sc-iTVJFM oxVOu">(</span>t<span class="sc-iTVJFM oxVOu">:</span> Type<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> t <span class="sc-dPaNzc fqbJCS">is</span> String   <span class="sc-iTVJFM oxVOu">{</span> <span class="sc-dPaNzc fqbJCS">return</span> t<span class="sc-iTVJFM oxVOu">.</span>type <span class="sc-iTVJFM oxVOu">===</span> <span class="sc-cTJkRt lmGFyU">&#x27;String&#x27;</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">isObject</span><span class="sc-iTVJFM oxVOu">(</span>t<span class="sc-iTVJFM oxVOu">:</span> Type<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> t <span class="sc-dPaNzc fqbJCS">is</span> Object   <span class="sc-iTVJFM oxVOu">{</span> <span class="sc-dPaNzc fqbJCS">return</span> t<span class="sc-iTVJFM oxVOu">.</span>type <span class="sc-iTVJFM oxVOu">===</span> <span class="sc-cTJkRt lmGFyU">&#x27;Object&#x27;</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>The return type </span><span><code>t is Null</code></span><span> (for example) is a </span><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" class="sc-gtsrHT kFWJEY"><span>type predicate</span></a><span>; when a call to the validator returns </span><span><code>true</code></span><span>, the type checker narrows </span><span><code>t</code></span><span> to type </span><span><code>Null</code></span><span>, just as it would have if the test </span><span><code>t.type === Null</code></span><span> had appeared directly in the code.</span></p><h3><span><em>Type module</em></span></h3><p><span>We wrap these types, constructors, validators, and other type-related functions into a module (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/index.ts" class="sc-gtsrHT kFWJEY"><span>type/index.ts</span></a><span>) so we can write </span><span><code>Type.Boolean</code></span><span> (the type), </span><span><code>Type.boolean </code></span><span>(the constructor), </span><span><code>Type.object({ ... })</code></span><span>, </span><span><code>Type.isObject</code></span><span>, </span><span><code>Type.toString</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/toString.ts" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span>), and so on.</span></p><h3><span><em>Parsing types</em></span></h3><p><span>For writing tests it&#x27;s useful to parse a type on its own. Babel doesn&#x27;t provide a function for this, but we can parse an </span><span><code>as</code></span><span> expression and pull out the type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">parseType</span><span class="sc-iTVJFM oxVOu">(</span>input<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">string</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> Type <span class="sc-iTVJFM oxVOu">{</span>
  <span class="sc-dPaNzc fqbJCS">const</span> ast <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-bBjRSN cdTyhF">parseExpression</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">_ as </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">input</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span><span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isTSAsExpression</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unexpected </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">ast</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-dPaNzc fqbJCS">type</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">return</span> Type<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">ofTSType</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">.</span><span class="sc-dPaNzc fqbJCS">type</span>Annotation<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>Here </span><span><code>Type.ofTSType</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/ofTSType.ts" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span>) converts a Babel </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2488" class="sc-gtsrHT kFWJEY"><span><code>TSType</code></span></a><span> AST (which represents a parsed type) to our </span><span><code>Type</code></span><span> representation. And </span><span><code>bug</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) throws an exception indicating a bug in the code.</span></p><p><span>The call to </span><span><code>bug</code></span><span> shows a use of narrowing: the return type of </span><span><code>bug</code></span><span> is </span><span><code>never</code></span><span>, meaning that the function never returns a value (it throws an exception), so the TypeScript type checker reasons that in the remainder of the function, </span><span><code>AST.isTSAsExpression(ast)</code></span><span> must be true; so the type of </span><span><code>ast</code></span><span> must be </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L1961" class="sc-gtsrHT kFWJEY"><span><code>TSAsExpression</code></span></a><span> (the </span><span><code>AST</code></span><span> validators are also type predicates), and we can safely access </span><span><code>ast.typeAnnotation</code></span><span>. We use this pattern to handle unexpected cases throughout the code.</span></p><h2><span>Synthesizing types from expressions</span></h2><p><span>Now we have enough machinery in place to do some actual type checking:</span></p><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> that to </span><span><em>synthesize</em></span><span> a type </span><span><em>from</em></span><span> an expression, we synthesize the types of its subexpressions, then combine them according to the top-level operation of the expression; for atomic expressions like literal values, we return the corresponding type.</span></p><p><span>First we case over the expression type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/synth.ts" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">synth</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span>Expression<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> Type <span class="sc-iTVJFM oxVOu">{</span>
  <span class="sc-dPaNzc fqbJCS">switch</span> <span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">.</span>type<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">{</span>
    <span class="sc-dPaNzc fqbJCS">case</span> <span class="sc-cTJkRt lmGFyU">&#x27;NullLiteral&#x27;</span><span class="sc-iTVJFM oxVOu">:</span>      <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-bBjRSN cdTyhF">synthNull</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
    <span class="sc-dPaNzc fqbJCS">case</span> <span class="sc-cTJkRt lmGFyU">&#x27;BooleanLiteral&#x27;</span><span class="sc-iTVJFM oxVOu">:</span>   <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-bBjRSN cdTyhF">synthBoolean</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
    <span class="sc-dPaNzc fqbJCS">case</span> <span class="sc-cTJkRt lmGFyU">&#x27;NumericLiteral&#x27;</span><span class="sc-iTVJFM oxVOu">:</span>   <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-bBjRSN cdTyhF">synthNumber</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
    <span class="sc-dPaNzc fqbJCS">case</span> <span class="sc-cTJkRt lmGFyU">&#x27;StringLiteral&#x27;</span><span class="sc-iTVJFM oxVOu">:</span>    <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-bBjRSN cdTyhF">synthString</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
    <span class="sc-dPaNzc fqbJCS">case</span> <span class="sc-cTJkRt lmGFyU">&#x27;ObjectExpression&#x27;</span><span class="sc-iTVJFM oxVOu">:</span> <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-bBjRSN cdTyhF">synthObject</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
    <span class="sc-dPaNzc fqbJCS">case</span> <span class="sc-cTJkRt lmGFyU">&#x27;MemberExpression&#x27;</span><span class="sc-iTVJFM oxVOu">:</span> <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-bBjRSN cdTyhF">synthMember</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>

    <span class="sc-dPaNzc fqbJCS">default</span><span class="sc-iTVJFM oxVOu">:</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unimplemented </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">ast</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-dPaNzc fqbJCS">type</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>In each </span><span><code>case</code></span><span> of the </span><span><code>switch</code></span><span>, the type of </span><span><code>ast</code></span><span> is narrowed to the corresponding arm of </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2058" class="sc-gtsrHT kFWJEY"><span><code>Expression</code></span></a><span> (which is a big union of all the kinds of expression), so the helper functions receive the specific arm type.</span></p><p><span>For primitive literals we return the corresponding type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">synthNull</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span>NullLiteral<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> Type       <span class="sc-iTVJFM oxVOu">{</span> <span class="sc-dPaNzc fqbJCS">return</span> Type<span class="sc-iTVJFM oxVOu">.</span>nullType<span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">synthBoolean</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span>BooleanLiteral<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> Type <span class="sc-iTVJFM oxVOu">{</span> <span class="sc-dPaNzc fqbJCS">return</span> Type<span class="sc-iTVJFM oxVOu">.</span><span class="sc-jNnpgg jIfccS">boolean</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">synthNumber</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span>NumericLiteral<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> Type  <span class="sc-iTVJFM oxVOu">{</span> <span class="sc-dPaNzc fqbJCS">return</span> Type<span class="sc-iTVJFM oxVOu">.</span><span class="sc-jNnpgg jIfccS">number</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">synthString</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span>StringLiteral<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> Type   <span class="sc-iTVJFM oxVOu">{</span> <span class="sc-dPaNzc fqbJCS">return</span> Type<span class="sc-iTVJFM oxVOu">.</span><span class="sc-jNnpgg jIfccS">string</span><span class="sc-iTVJFM oxVOu">;</span> <span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>For object expressions (of type </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L611" class="sc-gtsrHT kFWJEY"><span><code>ObjectExpression</code></span></a><span>), we synthesize a type for each property value expression, then return an object type that associates property names to types:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">synthObject</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span>ObjectExpression<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> Type <span class="sc-iTVJFM oxVOu">{</span>
  <span class="sc-dPaNzc fqbJCS">const</span> properties <span class="sc-iTVJFM oxVOu">=</span>
    ast<span class="sc-iTVJFM oxVOu">.</span>properties<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">map</span><span class="sc-iTVJFM oxVOu">(</span>prop <span class="sc-iTVJFM oxVOu">=&gt;</span> <span class="sc-iTVJFM oxVOu">{</span>
      <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span><span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isObjectProperty</span><span class="sc-iTVJFM oxVOu">(</span>prop<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unimplemented </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">prop</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-dPaNzc fqbJCS">type</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
      <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span><span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isIdentifier</span><span class="sc-iTVJFM oxVOu">(</span>prop<span class="sc-iTVJFM oxVOu">.</span>key<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unimplemented </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">prop</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-iTVJFM oxVOu">key</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-dPaNzc fqbJCS">type</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
      <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span><span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isExpression</span><span class="sc-iTVJFM oxVOu">(</span>prop<span class="sc-iTVJFM oxVOu">.</span>value<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unimplemented </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">prop</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-iTVJFM oxVOu">value</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-dPaNzc fqbJCS">type</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
      <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span>prop<span class="sc-iTVJFM oxVOu">.</span>computed<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unimplemented computed</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
      <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-iTVJFM oxVOu">{</span>
        name<span class="sc-iTVJFM oxVOu">:</span> prop<span class="sc-iTVJFM oxVOu">.</span>key<span class="sc-iTVJFM oxVOu">.</span>name<span class="sc-iTVJFM oxVOu">,</span>
        type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-bBjRSN cdTyhF">synth</span><span class="sc-iTVJFM oxVOu">(</span>prop<span class="sc-iTVJFM oxVOu">.</span>value<span class="sc-iTVJFM oxVOu">)</span>
      <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">;</span>
    <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">return</span> Type<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">object</span><span class="sc-iTVJFM oxVOu">(</span>properties<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>The Babel parser parses the full JavaScript expression syntax, but we&#x27;re only implementing part of it, so we call </span><span><code>bug(`unimplemented`)</code></span><span> for cases that we don&#x27;t want to handle.</span></p><p><span>For member expressions, we synthesize the type of the left-hand side, check that it&#x27;s an object and contains the named property (using </span><span><code>Type.propType</code></span><span>, see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/propType.ts" class="sc-gtsrHT kFWJEY"><span>propType.ts</span></a><span>), and return the type of the property. We call </span><span><code>err</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) to raise an exception if these checks fail (indicating an error in the input).</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">synthMember</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span>MemberExpression<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> Type <span class="sc-iTVJFM oxVOu">{</span>
  <span class="sc-dPaNzc fqbJCS">const</span> prop <span class="sc-iTVJFM oxVOu">=</span> ast<span class="sc-iTVJFM oxVOu">.</span>property<span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span><span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isIdentifier</span><span class="sc-iTVJFM oxVOu">(</span>prop<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unimplemented </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">prop</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-dPaNzc fqbJCS">type</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">.</span>computed<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unimplemented computed</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">const</span> object <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-bBjRSN cdTyhF">synth</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">.</span>object<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span>Type<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isObject</span><span class="sc-iTVJFM oxVOu">(</span>object<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">err</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-cTJkRt lmGFyU">&#x27;. expects object&#x27;</span><span class="sc-iTVJFM oxVOu">,</span> ast<span class="sc-iTVJFM oxVOu">.</span>object<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">const</span> type <span class="sc-iTVJFM oxVOu">=</span> Type<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">propType</span><span class="sc-iTVJFM oxVOu">(</span>object<span class="sc-iTVJFM oxVOu">,</span> prop<span class="sc-iTVJFM oxVOu">.</span>name<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span>type<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">err</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">no such property </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">prop</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-iTVJFM oxVOu">name</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">,</span> prop<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">return</span> type<span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>Again we skip some cases we don&#x27;t want to handle.</span></p><h2><span>Subtyping</span></h2><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> that in some cases we need to check whether a type </span><span><code>A</code></span><span> is a </span><span><em>subtype</em></span><span> of another type </span><span><code>B</code></span><span>. I find it really helpful to think of subtyping as an adversarial game: I pass a value of type </span><span><code>A</code></span><span> to an opponent, who is allowed to perform any operations on the value that are allowed by type </span><span><code>B</code></span><span>. If my opponent can&#x27;t perform any unsupported operation on the value, I winâ€”</span><span><code>A</code></span><span> is a subtype of </span><span><code>B</code></span><span>. Otherwise my opponent winsâ€”</span><span><code>A</code></span><span> is not a subtype of </span><span><code>B</code></span><span>.</span></p><p><span>My opponent can take the result of an operation and perform further operations on it. So </span><span><code>A</code></span><span> is a subtype of </span><span><code>B</code></span><span> when all the operations supported on </span><span><code>B</code></span><span> are also supported on </span><span><code>A</code></span><span>; and further, that the result of each operation on </span><span><code>A</code></span><span> is a subtype of the result of the same operation on </span><span><code>B</code></span><span>.</span></p><p><span>Since we have only a handful of types in this fragment, the subtyping function is simple (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/isSubtype.ts" class="sc-gtsrHT kFWJEY"><span>isSubtype.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">isSubtype</span><span class="sc-iTVJFM oxVOu">(</span>a<span class="sc-iTVJFM oxVOu">:</span> Type<span class="sc-iTVJFM oxVOu">,</span> b<span class="sc-iTVJFM oxVOu">:</span> Type<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">boolean</span> <span class="sc-iTVJFM oxVOu">{</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-bBjRSN cdTyhF">isNull</span><span class="sc-iTVJFM oxVOu">(</span>a<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">&amp;&amp;</span> <span class="sc-bBjRSN cdTyhF">isNull</span><span class="sc-iTVJFM oxVOu">(</span>b<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-khIgEk hQhHpX">true</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-bBjRSN cdTyhF">isBoolean</span><span class="sc-iTVJFM oxVOu">(</span>a<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">&amp;&amp;</span> <span class="sc-bBjRSN cdTyhF">isBoolean</span><span class="sc-iTVJFM oxVOu">(</span>b<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-khIgEk hQhHpX">true</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-bBjRSN cdTyhF">isNumber</span><span class="sc-iTVJFM oxVOu">(</span>a<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">&amp;&amp;</span> <span class="sc-bBjRSN cdTyhF">isNumber</span><span class="sc-iTVJFM oxVOu">(</span>b<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-khIgEk hQhHpX">true</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-bBjRSN cdTyhF">isString</span><span class="sc-iTVJFM oxVOu">(</span>a<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">&amp;&amp;</span> <span class="sc-bBjRSN cdTyhF">isString</span><span class="sc-iTVJFM oxVOu">(</span>b<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-khIgEk hQhHpX">true</span><span class="sc-iTVJFM oxVOu">;</span>

  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-bBjRSN cdTyhF">isObject</span><span class="sc-iTVJFM oxVOu">(</span>a<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">&amp;&amp;</span> <span class="sc-bBjRSN cdTyhF">isObject</span><span class="sc-iTVJFM oxVOu">(</span>b<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">{</span>
    <span class="sc-dPaNzc fqbJCS">return</span> b<span class="sc-iTVJFM oxVOu">.</span>properties<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">every</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">:</span> bName<span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">:</span> bType <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">=&gt;</span> <span class="sc-iTVJFM oxVOu">{</span>
      <span class="sc-dPaNzc fqbJCS">const</span> aType <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-bBjRSN cdTyhF">propType</span><span class="sc-iTVJFM oxVOu">(</span>a<span class="sc-iTVJFM oxVOu">,</span> bName<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
      <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span>aType<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-khIgEk hQhHpX">false</span><span class="sc-iTVJFM oxVOu">;</span>
      <span class="sc-dPaNzc fqbJCS">else</span> <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-bBjRSN cdTyhF">isSubtype</span><span class="sc-iTVJFM oxVOu">(</span>aType<span class="sc-iTVJFM oxVOu">,</span> bType<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
    <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-iTVJFM oxVOu">}</span>

  <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-khIgEk hQhHpX">false</span><span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>Each primitive type is a subtype of itself but no other type. An object type </span><span><code>A</code></span><span> is a subtype of an object type </span><span><code>B</code></span><span> if all the properties we can access on </span><span><code>B</code></span><span> can also be accessed on </span><span><code>A</code></span><span> (the order of properties doesn&#x27;t matter), and each of those properties on </span><span><code>A</code></span><span> is a subtype of the corresponding property on </span><span><code>B</code></span><span>.</span></p><p><span>For example, this type of rectangles with labelled points:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">{</span>
  upperLeft<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> label<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">string</span><span class="sc-iTVJFM oxVOu">,</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
  lowerRight<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> label<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">string</span><span class="sc-iTVJFM oxVOu">,</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>is a subtype of this type of rectangles with unlabelled points:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">{</span>
  upperLeft<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
  lowerRight<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><h2><span>Checking expressions against types</span></h2><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> that to </span><span><em>check</em></span><span> an expression </span><span><em>against</em></span><span> an expected type, we break down the expression and type and recursively check each expression part against the corresponding type part. When we can&#x27;t break down the expression or type, we synthesize a type for the expression, then check to see that the synthesized type is a subtype of the expected type.</span></p><p><span>First we case over the expression and expected type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/check.ts" class="sc-gtsrHT kFWJEY"><span>check.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">check</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">:</span> Expression<span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">:</span> Type<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">{</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isObjectExpression</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">&amp;&amp;</span> Type<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isObject</span><span class="sc-iTVJFM oxVOu">(</span>type<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span>
    <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-bBjRSN cdTyhF">checkObject</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>

  <span class="sc-dPaNzc fqbJCS">const</span> synthType <span class="sc-iTVJFM oxVOu">=</span> <span class="sc-bBjRSN cdTyhF">synth</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span>Type<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isSubtype</span><span class="sc-iTVJFM oxVOu">(</span>synthType<span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span>
    <span class="sc-bBjRSN cdTyhF">err</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">expected </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">Type</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">toString</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">type</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-cTJkRt lmGFyU">, got </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">Type</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">toString</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">synthType</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">,</span> ast<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>In this fragment, we can only break down object expressions against object types. Otherwise we synthesize a type and compare it to the expected type with </span><span><code>Type.isSubtype</code></span><span>.</span></p><p><span>To check an object expression against an object type, we match expression properties with type properties by name, then check each property value expression against the corresponding property type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">checkObject</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">:</span> ObjectExpression<span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">:</span> Type<span class="sc-iTVJFM oxVOu">.</span>Object<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">{</span>
  <span class="sc-dPaNzc fqbJCS">const</span> astProps<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">string</span><span class="sc-iTVJFM oxVOu">,</span> expr<span class="sc-iTVJFM oxVOu">:</span> Expression<span class="sc-iTVJFM oxVOu">,</span> key<span class="sc-iTVJFM oxVOu">:</span> Identifier <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">[</span><span class="sc-iTVJFM oxVOu">]</span> <span class="sc-iTVJFM oxVOu">=</span>
    ast<span class="sc-iTVJFM oxVOu">.</span>properties<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">map</span><span class="sc-iTVJFM oxVOu">(</span>prop <span class="sc-iTVJFM oxVOu">=&gt;</span> <span class="sc-iTVJFM oxVOu">{</span>
      <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span><span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isObjectProperty</span><span class="sc-iTVJFM oxVOu">(</span>prop<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unimplemented </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">prop</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-dPaNzc fqbJCS">type</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
      <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span>prop<span class="sc-iTVJFM oxVOu">.</span>computed<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unimplemented computed</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
      <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span><span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isIdentifier</span><span class="sc-iTVJFM oxVOu">(</span>prop<span class="sc-iTVJFM oxVOu">.</span>key<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unimplemented </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">prop</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-iTVJFM oxVOu">key</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-dPaNzc fqbJCS">type</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
      <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span><span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">isExpression</span><span class="sc-iTVJFM oxVOu">(</span>prop<span class="sc-iTVJFM oxVOu">.</span>value<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">bug</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">unimplemented </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">prop</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-iTVJFM oxVOu">value</span><span class="sc-iTVJFM oxVOu">.</span><span class="sc-dPaNzc fqbJCS">type</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
      <span class="sc-dPaNzc fqbJCS">return</span> <span class="sc-iTVJFM oxVOu">{</span>
        name<span class="sc-iTVJFM oxVOu">:</span> prop<span class="sc-iTVJFM oxVOu">.</span>key<span class="sc-iTVJFM oxVOu">.</span>name<span class="sc-iTVJFM oxVOu">,</span>
        expr<span class="sc-iTVJFM oxVOu">:</span> prop<span class="sc-iTVJFM oxVOu">.</span>value <span class="sc-dPaNzc fqbJCS">as</span> Expression<span class="sc-iTVJFM oxVOu">,</span>
        key<span class="sc-iTVJFM oxVOu">:</span> prop<span class="sc-iTVJFM oxVOu">.</span>key
      <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">;</span>
    <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>

  type<span class="sc-iTVJFM oxVOu">.</span>properties<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">forEach</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">{</span> name <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">=&gt;</span> <span class="sc-iTVJFM oxVOu">{</span>
    <span class="sc-dPaNzc fqbJCS">const</span> astProp <span class="sc-iTVJFM oxVOu">=</span> astProps<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">find</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">:</span> astName <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">=&gt;</span> astName <span class="sc-iTVJFM oxVOu">===</span> name<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
    <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">!</span>astProp<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">err</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">missing property </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">name</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">,</span> ast<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>

  astProps<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">forEach</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">,</span> expr<span class="sc-iTVJFM oxVOu">,</span> key <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span> <span class="sc-iTVJFM oxVOu">=&gt;</span> <span class="sc-iTVJFM oxVOu">{</span>
    <span class="sc-dPaNzc fqbJCS">const</span> propType <span class="sc-iTVJFM oxVOu">=</span> Type<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">propType</span><span class="sc-iTVJFM oxVOu">(</span>type<span class="sc-iTVJFM oxVOu">,</span> name<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
    <span class="sc-dPaNzc fqbJCS">if</span> <span class="sc-iTVJFM oxVOu">(</span>propType<span class="sc-iTVJFM oxVOu">)</span> <span class="sc-bBjRSN cdTyhF">check</span><span class="sc-iTVJFM oxVOu">(</span>expr<span class="sc-iTVJFM oxVOu">,</span> propType<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
    <span class="sc-dPaNzc fqbJCS">else</span> <span class="sc-bBjRSN cdTyhF">err</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-cTJkRt lmGFyU">extra property </span><span class="sc-iTVJFM oxVOu">${</span><span class="sc-iTVJFM oxVOu">name</span><span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">`</span><span class="sc-iTVJFM oxVOu">,</span> key<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>We flag an error if the object expression is missing a property present in the type. We also flag an error if it has an extra property that&#x27;s not present in the type. You might wonder why, since an extra property can&#x27;t do any harm; in </span><span><code>isSubtype</code></span><span> we allow extra properties. But in a literal object expression, an extra property might be a bug: we meant to set an optional property but mistyped it. So we follow actual TypeScript and flag it.</span></p><p><span>Now that we&#x27;ve defined </span><span><code>check</code></span><span>, we can add a case to </span><span><code>synth</code></span><span> to synthesize </span><span><code>as</code></span><span> expressions by checking the expression against the given type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-dPaNzc fqbJCS">function</span> <span class="sc-bBjRSN cdTyhF">synthTSAs</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-khIgEk hQhHpX">AST</span><span class="sc-iTVJFM oxVOu">.</span>TSAsExpression<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">:</span> Type <span class="sc-iTVJFM oxVOu">{</span>
  <span class="sc-dPaNzc fqbJCS">const</span> type <span class="sc-iTVJFM oxVOu">=</span> Type<span class="sc-iTVJFM oxVOu">.</span><span class="sc-bBjRSN cdTyhF">ofTSType</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">.</span><span class="sc-dPaNzc fqbJCS">type</span>Annotation<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-bBjRSN cdTyhF">check</span><span class="sc-iTVJFM oxVOu">(</span>ast<span class="sc-iTVJFM oxVOu">.</span>expression<span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">)</span><span class="sc-iTVJFM oxVOu">;</span>
  <span class="sc-dPaNzc fqbJCS">return</span> type<span class="sc-iTVJFM oxVOu">;</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>So </span><span><code>as</code></span><span> gives us a way to tell the type checker to switch from synthesis to checking. This can be useful for debugging complicated type errors. It&#x27;s also a way to hide information about the type of an expression (but the language fragment so far is too simple to give a good example of thisâ€”more later).</span></p><h2><span>Example</span></h2><p><span>Let&#x27;s walk through an example in detail:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">{</span>
  x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">7</span><span class="sc-iTVJFM oxVOu">,</span>
  y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> a<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;foo&quot;</span><span class="sc-iTVJFM oxVOu">,</span> b<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;bar&quot;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">.</span>b
<span class="sc-iTVJFM oxVOu">}</span> <span class="sc-dPaNzc fqbJCS">as</span> <span class="sc-iTVJFM oxVOu">{</span> x<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span><span class="sc-iTVJFM oxVOu">,</span> y<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-jNnpgg jIfccS">number</span> <span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>(See </span><a href="https://astexplorer.net/#/gist/4adfad800891ef430cb87db4c60dc5c2/5612db7c5bd283efbbe3a79e986b0176f5717a31" class="sc-gtsrHT kFWJEY"><span>here</span></a><span> for the full AST.) Type checking starts with a call to </span><span><code>synth</code></span><span>:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bBjRSN cdTyhF">synth</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">{</span>
  type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;TSAsExpression&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
  expression<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;ObjectExpression&quot;</span><span class="sc-iTVJFM oxVOu">,</span> properties<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">[</span> <span class="sc-iTVJFM oxVOu">...</span> <span class="sc-iTVJFM oxVOu">]</span> <span class="sc-iTVJFM oxVOu">}</span>
  <span class="sc-dPaNzc fqbJCS">type</span>Annotation<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">...</span>
<span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span></code></pre><p><span>The top-level node is </span><span><code>TSASExpression</code></span><span>, so we call </span><span><code>check</code></span><span> on the </span><span><code>expression</code></span><span> property with the given type (first translating the parsed </span><span><code>typeAnnotation</code></span><span> to our </span><span><code>Type</code></span><span> representation with </span><span><code>Type.ofTSType</code></span><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bBjRSN cdTyhF">check</span><span class="sc-iTVJFM oxVOu">(</span>
  <span class="sc-cOifOu haQoIp">// check this expression</span>
  <span class="sc-iTVJFM oxVOu">{</span>
    type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;ObjectExpression&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
    properties<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">[</span>
      <span class="sc-iTVJFM oxVOu">{</span>
        type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;ObjectProperty&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
        key<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Identifier&quot;</span><span class="sc-iTVJFM oxVOu">,</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;x&quot;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
        value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;NumericLiteral&quot;</span><span class="sc-iTVJFM oxVOu">,</span> value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">7</span> <span class="sc-iTVJFM oxVOu">}</span>
      <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
      <span class="sc-iTVJFM oxVOu">{</span>
        type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;ObjectProperty&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
        key<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Identifier&quot;</span><span class="sc-iTVJFM oxVOu">,</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;y&quot;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
        value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;MemberExpression&quot;</span><span class="sc-iTVJFM oxVOu">,</span> <span class="sc-iTVJFM oxVOu">...</span> <span class="sc-iTVJFM oxVOu">}</span>
      <span class="sc-iTVJFM oxVOu">}</span>
    <span class="sc-iTVJFM oxVOu">]</span>
  <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
  <span class="sc-cOifOu haQoIp">// against this type</span>
  <span class="sc-iTVJFM oxVOu">{</span>
    type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Object&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
    properties<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">[</span>
      <span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;x&quot;</span><span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Number&quot;</span> <span class="sc-iTVJFM oxVOu">}</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
      <span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;y&quot;</span><span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Number&quot;</span> <span class="sc-iTVJFM oxVOu">}</span> <span class="sc-iTVJFM oxVOu">}</span>
    <span class="sc-iTVJFM oxVOu">]</span>
  <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-iTVJFM oxVOu">)</span></code></pre><p><span>To check an </span><span><code>ObjectExpression</code></span><span> against an </span><span><code>Object</code></span><span> type, we check each property value expression against the corresponding property type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cOifOu haQoIp">// property x</span>
<span class="sc-bBjRSN cdTyhF">check</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;NumericLiteral&quot;</span><span class="sc-iTVJFM oxVOu">,</span> value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-Arkif eJDRKz">7</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Number&quot;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span>

<span class="sc-cOifOu haQoIp">// property y</span>
<span class="sc-bBjRSN cdTyhF">check</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;MemberExpression&quot;</span><span class="sc-iTVJFM oxVOu">,</span> <span class="sc-iTVJFM oxVOu">...</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Number&quot;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span></code></pre><p><span>We can&#x27;t break down either of these further, so for each we </span><span><code>synth</code></span><span> a type for the expression, then compare it to the expected type with </span><span><code>isSubtype</code></span><span>. For </span><span><code>x</code></span><span> we </span><span><code>synth</code></span><span> type </span><span><code>Number</code></span><span> and check that it&#x27;s a subtype of </span><span><code>Number</code></span><span>. For </span><span><code>y</code></span><span> we first </span><span><code>synth</code></span><span> a type for </span><span><code>{ a: &quot;foo&quot;, b: &quot;bar&quot; }.b</code></span><span>:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bBjRSN cdTyhF">synth</span><span class="sc-iTVJFM oxVOu">(</span><span class="sc-iTVJFM oxVOu">{</span>
  type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;MemberExpression&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
  object<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span>
    type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;ObjectExpression&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
    properties<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">[</span>
      <span class="sc-iTVJFM oxVOu">{</span>
        type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;ObjectProperty&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
        key<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Identifier&quot;</span><span class="sc-iTVJFM oxVOu">,</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;a&quot;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
        value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;StringLiteral&quot;</span><span class="sc-iTVJFM oxVOu">,</span> value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;foo&quot;</span> <span class="sc-iTVJFM oxVOu">}</span>
      <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
      <span class="sc-iTVJFM oxVOu">{</span>
        type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;ObjectProperty&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
        key<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Identifier&quot;</span><span class="sc-iTVJFM oxVOu">,</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;b&quot;</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
        value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;StringLiteral&quot;</span><span class="sc-iTVJFM oxVOu">,</span> value<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;bar&quot;</span> <span class="sc-iTVJFM oxVOu">}</span>
      <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
    <span class="sc-iTVJFM oxVOu">]</span>
  <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
  property<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Identifier&quot;</span><span class="sc-iTVJFM oxVOu">,</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;b&quot;</span> <span class="sc-iTVJFM oxVOu">}</span>
<span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">)</span></code></pre><p><span>To </span><span><code>synth</code></span><span> a type for a </span><span><code>MemberExpression</code></span><span>, we first </span><span><code>synth</code></span><span> a type for the </span><span><code>object</code></span><span> propertyâ€”to </span><span><code>synth</code></span><span> a type for an </span><span><code>ObjectExpression</code></span><span> we synth types for the property values and return this type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">{</span>
  type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;Object&quot;</span><span class="sc-iTVJFM oxVOu">,</span>
  properties<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">[</span>
    <span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;a&quot;</span><span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;String&quot;</span> <span class="sc-iTVJFM oxVOu">}</span> <span class="sc-iTVJFM oxVOu">}</span><span class="sc-iTVJFM oxVOu">,</span>
    <span class="sc-iTVJFM oxVOu">{</span> name<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;b&quot;</span><span class="sc-iTVJFM oxVOu">,</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-iTVJFM oxVOu">{</span> type<span class="sc-iTVJFM oxVOu">:</span> <span class="sc-cTJkRt lmGFyU">&quot;String&quot;</span> <span class="sc-iTVJFM oxVOu">}</span> <span class="sc-iTVJFM oxVOu">}</span>
  <span class="sc-iTVJFM oxVOu">]</span>
<span class="sc-iTVJFM oxVOu">}</span></code></pre><p><span>then project the </span><span><code>b</code></span><span> property to get type </span><span><code>String</code></span><span> for the whole </span><span><code>MemberExpression</code></span><span>. Finally we check that </span><span><code>String</code></span><span> is a subtype of </span><span><code>Number</code></span><span>, and flag an error because it is not.</span></p><h2><span>Try it!</span></h2><p><span>You can try out the type checker below: type an expression into the top box, see its synthesized type (or an error) in the bottom box. To check an expression against a type, ascribing a type with </span><span><code>as</code></span><span>. (Remember that the only supported expressions in this fragment are primitive literals, object expressions, member expressions, and </span><span><code>as</code></span><span> ascriptions.)</span></p><iframe src="https://jaked.org/reconstructing-typescript/part1/" width="700" height="300" style="border-style:none"></iframe><h2><span>The plan</span></h2><p><span>For the full code of part 1 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part1" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part1</span></a><span>.</span></p><p><span>Next time we&#x27;ll add functions and function calls to the languageâ€”we&#x27;ll add a </span><span><em>type environment</em></span><span> to track the types of variables, and see how subtyping for functions requires </span><span><em>contravariance</em></span><span>.</span></p><ul><li><p><span></span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>Part 0: intro and background</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>Part 1: bidirectional type checking</span></a><span></span></p></li><li><p><span>Part 2: functions and function calls</span></p></li><li><p><span>Part 3: singleton / literal types and arithmetic / logical operators</span></p></li><li><p><span>Part 4: union types</span></p></li><li><p><span>Part 5: intersection types</span></p></li><li><p><span>Part 6: narrowing</span></p></li></ul><p><span>Thanks to Julia Evans, Tony Chow, and Will Lachance for helpful feedback on a draft of this post.</span></p><p><span>Please </span><a href="/blog/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p></div></body></html>