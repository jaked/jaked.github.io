<html><head><title>Reconstructing TypeScript, part 1: bidirectional type checking</title><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/2021-09-15-Reconstructing-TypeScript-part-1.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.bOWasK{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;overflow:auto;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"bOWasK,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.dRsyqq{color:#116644;}/*!sc*/
data-styled.g39[id="sc-hiKfDv"]{content:"dRsyqq,"}/*!sc*/
.jKLUHq{color:#aa1111;}/*!sc*/
data-styled.g40[id="sc-gXfVKN"]{content:"jKLUHq,"}/*!sc*/
.lRfdj{color:#221199;}/*!sc*/
data-styled.g41[id="sc-cBoqAE"]{content:"lRfdj,"}/*!sc*/
.bwSYJA{color:#000000;}/*!sc*/
data-styled.g42[id="sc-ciSkZP"]{content:"bwSYJA,"}/*!sc*/
.kyvWZW{color:#770088;}/*!sc*/
data-styled.g43[id="sc-jcwpoC"]{content:"kyvWZW,"}/*!sc*/
.hBWCUB{color:#268bd2;}/*!sc*/
data-styled.g44[id="sc-carFqZ"]{content:"hBWCUB,"}/*!sc*/
.oxVOu{color:#b58900;}/*!sc*/
data-styled.g45[id="sc-iTVJFM"]{content:"oxVOu,"}/*!sc*/
.glZmJR{color:#009900;}/*!sc*/
data-styled.g46[id="sc-iBzEeX"]{content:"glZmJR,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript, part 1</span></p><h1><span>Reconstructing TypeScript, part 1: bidirectional type checking</span></h1><h3><span><em>2021-09-15</em></span></h3><p><span>This post is part of a series about implementing type checking for a TypeScript-like language. In the </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>last post </span></a><span> I gave some background about type checking, TypeScript&#x27;s type system, and the approach we&#x27;ll use, called </span><span><em>bidirectional type checking</em></span><span>.</span></p><p><span>Now let&#x27;s write a type checker! We&#x27;re going to start with a tiny fragment of the language, and build it up incrementally in subsequent posts. In this fragment we&#x27;ll handle only primitive literals like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-hiKfDv dRsyqq">7</span>
<span class="sc-gXfVKN jKLUHq">&quot;TypeScript is cool.&quot;</span>
<span class="sc-cBoqAE lRfdj">false</span></code></pre><p><span>object literals like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">{</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">7</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">9</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-ciSkZP bwSYJA">{</span> foo<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;bar&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> baz<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-cBoqAE lRfdj">false</span> <span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>and member expressions like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">{</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">7</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">9</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">.</span>x</code></pre><p><span>(We don&#x27;t have variables yet, so member expressions look a little weird!)</span></p><p><span>We&#x27;ll also handle </span><span><em>type ascriptions</em></span><span> like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">{</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">7</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;foo&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span> <span class="sc-jcwpoC kyvWZW">as</span> <span class="sc-ciSkZP bwSYJA">{</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span> <span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>In actual TypeScript, </span><span><code>as</code></span><span> is an unsafe cast, a way to tell the type checker, &quot;trust me, this expression has this type!&quot; Here it is a way to guide the type checker (more on this below), but it&#x27;s not unsafe—the type checker still ensures that the program doesn&#x27;t attempt any unsupported operations.</span></p><h2><span>Parsing code into an abstract syntax tree</span></h2><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> that type checking works on an </span><span><em>abstract syntax tree</em></span><span> representation of code, where each expression in a program is a node in the tree, with its subexpressions as children. So first we need to parse code strings to ASTs. We use </span><a href="https://babeljs.io/docs/en/babel-parser" class="sc-gtsrHT kFWJEY"><span>@babel/parser</span></a><span> with the TypeScript plugin (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/ast/parse.ts" class="sc-gtsrHT kFWJEY"><span>parse.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">parseExpression</span><span class="sc-ciSkZP bwSYJA">(</span>input<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">string</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> Expression <span class="sc-ciSkZP bwSYJA">{</span>
  <span class="sc-jcwpoC kyvWZW">return</span> Babel<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">parseExpression</span><span class="sc-ciSkZP bwSYJA">(</span>input<span class="sc-ciSkZP bwSYJA">,</span> <span class="sc-ciSkZP bwSYJA">{</span>
    plugins<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">[</span> <span class="sc-gXfVKN jKLUHq">&#x27;typescript&#x27;</span> <span class="sc-ciSkZP bwSYJA">]</span>
  <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>which produces a value of type </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2058" class="sc-gtsrHT kFWJEY"><span><code>Expression</code></span></a><span> from </span><a href="https://babeljs.io/docs/en/babel-types" class="sc-gtsrHT kFWJEY"><span>@babel/types</span></a><span>. For example, if we call </span><span><code>parseExpression</code></span><span> on an object expression</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">{</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">7</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">9</span> <span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>we get an </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L611" class="sc-gtsrHT kFWJEY"><span><code>ObjectExpression</code></span></a><span> AST with </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L634" class="sc-gtsrHT kFWJEY"><span><code>ObjectProperty</code></span></a><span> ASTs as children:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">{</span>
  type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;ObjectExpression&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
  properties<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">[</span>
    <span class="sc-ciSkZP bwSYJA">{</span>
      type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;ObjectProperty&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
      key<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Identifier&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;x&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
      value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;NumericLiteral&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">7</span> <span class="sc-ciSkZP bwSYJA">}</span>
    <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
    <span class="sc-ciSkZP bwSYJA">{</span>
      type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;ObjectProperty&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
      key<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Identifier&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;y&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
      value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;NumericLiteral&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">9</span> <span class="sc-ciSkZP bwSYJA">}</span>
    <span class="sc-ciSkZP bwSYJA">}</span>
  <span class="sc-ciSkZP bwSYJA">]</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>Each node has a </span><span><code>type</code></span><span> property saying what kind of syntax it represents, and each kind of node has kind-specific properties for subexpressions and other attributes. (I&#x27;ve trimmed out properties that describe the location of each AST node in the original code string.)</span></p><p><span>To keep things simple, our type checker will handle only expressions, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">&quot;TypeScript is cool&quot;</span>
<span class="sc-ciSkZP bwSYJA">{</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">7</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">9</span> <span class="sc-ciSkZP bwSYJA">}</span>
x <span class="sc-ciSkZP bwSYJA">&gt;</span> <span class="sc-hiKfDv dRsyqq">0</span> <span class="sc-ciSkZP bwSYJA">?</span> x <span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">-</span>x</code></pre><p><span>not statements, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">const</span> x <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-hiKfDv dRsyqq">7</span>
<span class="sc-jcwpoC kyvWZW">for</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-jcwpoC kyvWZW">let</span> i <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-hiKfDv dRsyqq">0</span><span class="sc-ciSkZP bwSYJA">;</span> i <span class="sc-ciSkZP bwSYJA">&lt;</span> <span class="sc-hiKfDv dRsyqq">10</span><span class="sc-ciSkZP bwSYJA">;</span> i<span class="sc-ciSkZP bwSYJA">++</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">{</span> <span class="sc-ciSkZP bwSYJA">...</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-jcwpoC kyvWZW">throw</span> <span class="sc-jcwpoC kyvWZW">new</span> <span class="sc-ciSkZP bwSYJA">Error</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-gXfVKN jKLUHq">&quot;bad thing&quot;</span><span class="sc-ciSkZP bwSYJA">)</span></code></pre><p><span>so we only need to parse expressions. (We&#x27;ll also parse types, see below.)</span></p><p><span>The full </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2058" class="sc-gtsrHT kFWJEY"><span><code>Expression</code></span></a><span> type is pretty complicated, and it&#x27;s not always obvious what the different properties mean. So it&#x27;s really helpful to be able to browse the AST produced by a piece of code. I use the excellent </span><a href="https://astexplorer.net/" class="sc-gtsrHT kFWJEY"><span>AST Explorer</span></a><span> for this. (Set the language to </span><span><code>JavaScript</code></span><span> and the parser to </span><span><code>@babel/parser.</code></span><span> Then click the gear icon next to </span><span><code>@babel/parser</code></span><span>, enable the </span><span><code>typescript</code></span><span> plugin, and disable the </span><span><code>flow</code></span><span> plugin.)</span></p><p><span>Be aware that AST Explorer parses programs, not expressions; so if you feed it an expression, the AST is wrapped in </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L602" class="sc-gtsrHT kFWJEY"><span><code>Program</code></span></a><span> and </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L455" class="sc-gtsrHT kFWJEY"><span><code>ExpressionStatement</code></span></a><span> nodes. Usually it&#x27;s OK to write an expression where a statement is expected, but for object expressions you need to wrap parentheses around them, or else the parser sees </span><span><code>{</code></span><span> and tries to parse a block of statements.</span></p><h2><span>Representing types</span></h2><p><span>To synthesize and check types, we need a way to represent them. In this fragment we support only a few types—primitive literals, and objects made up of properties (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/types.ts" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">type</span> <span class="sc-ciSkZP bwSYJA">Type</span> <span class="sc-ciSkZP bwSYJA">=</span> Null <span class="sc-ciSkZP bwSYJA">|</span> Boolean <span class="sc-ciSkZP bwSYJA">|</span> Number <span class="sc-ciSkZP bwSYJA">|</span> String <span class="sc-ciSkZP bwSYJA">|</span> Object<span class="sc-ciSkZP bwSYJA">;</span>

<span class="sc-jcwpoC kyvWZW">type</span> <span class="sc-ciSkZP bwSYJA">Null</span> <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Null&#x27;</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-jcwpoC kyvWZW">type</span> <span class="sc-ciSkZP bwSYJA">Boolean</span> <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Boolean&#x27;</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-jcwpoC kyvWZW">type</span> <span class="sc-ciSkZP bwSYJA">Number</span> <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Number&#x27;</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-jcwpoC kyvWZW">type</span> <span class="sc-ciSkZP bwSYJA">String</span> <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;String&#x27;</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span>

<span class="sc-jcwpoC kyvWZW">type</span> <span class="sc-ciSkZP bwSYJA">Object</span> <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-ciSkZP bwSYJA">{</span>
  type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Object&#x27;</span><span class="sc-ciSkZP bwSYJA">;</span>
  properties<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">string</span><span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">:</span> Type <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">[</span><span class="sc-ciSkZP bwSYJA">]</span><span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>For example, the type</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">{</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span> <span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>is represented by the value</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">{</span>
  type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Object&#x27;</span><span class="sc-ciSkZP bwSYJA">,</span>
  properties<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">[</span>
    <span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;x&#x27;</span><span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Number&#x27;</span> <span class="sc-ciSkZP bwSYJA">}</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
    <span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;y&#x27;</span><span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Number&#x27;</span> <span class="sc-ciSkZP bwSYJA">}</span> <span class="sc-ciSkZP bwSYJA">}</span>
  <span class="sc-ciSkZP bwSYJA">]</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><h3><span><em>Constructors</em></span></h3><p><span>We have predefined constants and helper functions to construct types (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/constructors.ts" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">const</span> nullType<span class="sc-ciSkZP bwSYJA">:</span> Null <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Null&#x27;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-jcwpoC kyvWZW">const</span> <span class="sc-carFqZ hBWCUB">boolean</span><span class="sc-ciSkZP bwSYJA">:</span> Boolean <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Boolean&#x27;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-jcwpoC kyvWZW">const</span> <span class="sc-carFqZ hBWCUB">number</span><span class="sc-ciSkZP bwSYJA">:</span> Number <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Number&#x27;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-jcwpoC kyvWZW">const</span> <span class="sc-carFqZ hBWCUB">string</span><span class="sc-ciSkZP bwSYJA">:</span> String <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;String&#x27;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">;</span></code></pre><p><span>The properties of an object type are represented as an array, but it&#x27;s often convenient to construct object types by passing an object mapping names to types, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">const</span> type <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-iTVJFM oxVOu">object</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">{</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span></code></pre><p><span>so the </span><span><code>object</code></span><span> constructor takes either an array of properties or an object mapping names to types:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">object</span><span class="sc-ciSkZP bwSYJA">(</span>
  properties<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">string</span><span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">:</span> Type <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">[</span><span class="sc-ciSkZP bwSYJA">]</span> <span class="sc-ciSkZP bwSYJA">|</span> <span class="sc-ciSkZP bwSYJA">{</span> <span class="sc-ciSkZP bwSYJA">[</span>name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">string</span><span class="sc-ciSkZP bwSYJA">]</span><span class="sc-ciSkZP bwSYJA">:</span> Type <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> Object <span class="sc-ciSkZP bwSYJA">{</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-carFqZ hBWCUB">Array</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isArray</span><span class="sc-ciSkZP bwSYJA">(</span>properties<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">{</span>
    <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Object&#x27;</span><span class="sc-ciSkZP bwSYJA">,</span> properties <span class="sc-ciSkZP bwSYJA">}</span>
  <span class="sc-ciSkZP bwSYJA">}</span> <span class="sc-jcwpoC kyvWZW">else</span> <span class="sc-ciSkZP bwSYJA">{</span>
    <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-iTVJFM oxVOu">object</span><span class="sc-ciSkZP bwSYJA">(</span>
      Object<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">entries</span><span class="sc-ciSkZP bwSYJA">(</span>properties<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">map</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">[</span> name<span class="sc-ciSkZP bwSYJA">,</span> type <span class="sc-ciSkZP bwSYJA">]</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">=&gt;</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">,</span> <span class="sc-jcwpoC kyvWZW">type</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span>
    <span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>This is a nice example of the flexibility of union types: rather than define a separate function to convert an object argument to an array, we give the argument a union type. If </span><span><code>Array.isArray(properties)</code></span><span> is true, we know from the argument type that </span><span><code>properties</code></span><span> must be an array of </span><span><code>{ name: string, type: Type }</code></span><span> objects, so we can directly construct an </span><span><code>Object</code></span><span> type. Otherwise it must be an object mapping property names to </span><span><code>Type</code></span><span>s, so we walk the object entries to build an array.</span></p><h3><span><em>Validators</em></span></h3><p><span>We have validators for distinguishing different kinds of </span><span><code>Type</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/validators.ts" class="sc-gtsrHT kFWJEY"><span>validators.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">isNull</span><span class="sc-ciSkZP bwSYJA">(</span>t<span class="sc-ciSkZP bwSYJA">:</span> Type<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> t <span class="sc-jcwpoC kyvWZW">is</span> Null       <span class="sc-ciSkZP bwSYJA">{</span> <span class="sc-jcwpoC kyvWZW">return</span> t<span class="sc-ciSkZP bwSYJA">.</span>type <span class="sc-ciSkZP bwSYJA">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Null&#x27;</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">isBoolean</span><span class="sc-ciSkZP bwSYJA">(</span>t<span class="sc-ciSkZP bwSYJA">:</span> Type<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> t <span class="sc-jcwpoC kyvWZW">is</span> Boolean <span class="sc-ciSkZP bwSYJA">{</span> <span class="sc-jcwpoC kyvWZW">return</span> t<span class="sc-ciSkZP bwSYJA">.</span>type <span class="sc-ciSkZP bwSYJA">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Boolean&#x27;</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">isNumber</span><span class="sc-ciSkZP bwSYJA">(</span>t<span class="sc-ciSkZP bwSYJA">:</span> Type<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> t <span class="sc-jcwpoC kyvWZW">is</span> Number   <span class="sc-ciSkZP bwSYJA">{</span> <span class="sc-jcwpoC kyvWZW">return</span> t<span class="sc-ciSkZP bwSYJA">.</span>type <span class="sc-ciSkZP bwSYJA">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Number&#x27;</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">isString</span><span class="sc-ciSkZP bwSYJA">(</span>t<span class="sc-ciSkZP bwSYJA">:</span> Type<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> t <span class="sc-jcwpoC kyvWZW">is</span> String   <span class="sc-ciSkZP bwSYJA">{</span> <span class="sc-jcwpoC kyvWZW">return</span> t<span class="sc-ciSkZP bwSYJA">.</span>type <span class="sc-ciSkZP bwSYJA">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;String&#x27;</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">isObject</span><span class="sc-ciSkZP bwSYJA">(</span>t<span class="sc-ciSkZP bwSYJA">:</span> Type<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> t <span class="sc-jcwpoC kyvWZW">is</span> Object   <span class="sc-ciSkZP bwSYJA">{</span> <span class="sc-jcwpoC kyvWZW">return</span> t<span class="sc-ciSkZP bwSYJA">.</span>type <span class="sc-ciSkZP bwSYJA">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Object&#x27;</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>The return type </span><span><code>t is Null</code></span><span> (for example) is a </span><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" class="sc-gtsrHT kFWJEY"><span>type predicate</span></a><span>; when a call to the validator returns </span><span><code>true</code></span><span>, the type checker narrows </span><span><code>t</code></span><span> to type </span><span><code>Null</code></span><span>, just as it would have if the test </span><span><code>t.type === Null</code></span><span> had appeared directly in the code.</span></p><h3><span><em>Type module</em></span></h3><p><span>We wrap these types, constructors, validators, and other type-related functions into a module (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/index.ts" class="sc-gtsrHT kFWJEY"><span>type/index.ts</span></a><span>) so we can write </span><span><code>Type.Boolean</code></span><span> (the type), </span><span><code>Type.boolean </code></span><span>(the constructor), </span><span><code>Type.object({ ... })</code></span><span>, </span><span><code>Type.isObject</code></span><span>, </span><span><code>Type.toString</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/toString.ts" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span>), and so on.</span></p><h3><span><em>Parsing types</em></span></h3><p><span>For writing tests it&#x27;s useful to parse a type on its own. Babel doesn&#x27;t provide a function for this, but we can parse an </span><span><code>as</code></span><span> expression and pull out the type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">parseType</span><span class="sc-ciSkZP bwSYJA">(</span>input<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">string</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> Type <span class="sc-ciSkZP bwSYJA">{</span>
  <span class="sc-jcwpoC kyvWZW">const</span> ast <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-iTVJFM oxVOu">parseExpression</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">_ as </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">input</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isTSAsExpression</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unexpected </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">ast</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-jcwpoC kyvWZW">type</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">return</span> Type<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">ofTSType</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-jcwpoC kyvWZW">type</span>Annotation<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>Here </span><span><code>Type.ofTSType</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/ofTSType.ts" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span>) converts a Babel </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2488" class="sc-gtsrHT kFWJEY"><span><code>TSType</code></span></a><span> AST (which represents a parsed type) to our </span><span><code>Type</code></span><span> representation. And </span><span><code>bug</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) throws an exception indicating a bug in the code.</span></p><p><span>The call to </span><span><code>bug</code></span><span> shows a use of narrowing: the return type of </span><span><code>bug</code></span><span> is </span><span><code>never</code></span><span>, meaning that the function never returns a value (it throws an exception), so the TypeScript type checker reasons that in the remainder of the function, </span><span><code>AST.isTSAsExpression(ast)</code></span><span> must be true; so the type of </span><span><code>ast</code></span><span> must be </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L1961" class="sc-gtsrHT kFWJEY"><span><code>TSAsExpression</code></span></a><span> (the </span><span><code>AST</code></span><span> validators are also type predicates), and we can safely access </span><span><code>ast.typeAnnotation</code></span><span>. We use this pattern to handle unexpected cases throughout the code.</span></p><h2><span>Synthesizing types from expressions</span></h2><p><span>Now we have enough machinery in place to do some actual type checking:</span></p><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> that to </span><span><em>synthesize</em></span><span> a type </span><span><em>from</em></span><span> an expression, we synthesize the types of its subexpressions, then combine them according to the top-level operation of the expression; for atomic expressions like literal values, we return the corresponding type.</span></p><p><span>First we case over the expression type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/synth.ts" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">synth</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span>Expression<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> Type <span class="sc-ciSkZP bwSYJA">{</span>
  <span class="sc-jcwpoC kyvWZW">switch</span> <span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">.</span>type<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">{</span>
    <span class="sc-jcwpoC kyvWZW">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;NullLiteral&#x27;</span><span class="sc-ciSkZP bwSYJA">:</span>      <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-iTVJFM oxVOu">synthNull</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
    <span class="sc-jcwpoC kyvWZW">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;BooleanLiteral&#x27;</span><span class="sc-ciSkZP bwSYJA">:</span>   <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-iTVJFM oxVOu">synthBoolean</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
    <span class="sc-jcwpoC kyvWZW">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;NumericLiteral&#x27;</span><span class="sc-ciSkZP bwSYJA">:</span>   <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-iTVJFM oxVOu">synthNumber</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
    <span class="sc-jcwpoC kyvWZW">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;StringLiteral&#x27;</span><span class="sc-ciSkZP bwSYJA">:</span>    <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-iTVJFM oxVOu">synthString</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
    <span class="sc-jcwpoC kyvWZW">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;ObjectExpression&#x27;</span><span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-iTVJFM oxVOu">synthObject</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
    <span class="sc-jcwpoC kyvWZW">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;MemberExpression&#x27;</span><span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-iTVJFM oxVOu">synthMember</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>

    <span class="sc-jcwpoC kyvWZW">default</span><span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">ast</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-jcwpoC kyvWZW">type</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>In each </span><span><code>case</code></span><span> of the </span><span><code>switch</code></span><span>, the type of </span><span><code>ast</code></span><span> is narrowed to the corresponding arm of </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2058" class="sc-gtsrHT kFWJEY"><span><code>Expression</code></span></a><span> (which is a big union of all the kinds of expression), so the helper functions receive the specific arm type.</span></p><p><span>For primitive literals we return the corresponding type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">synthNull</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span>NullLiteral<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> Type       <span class="sc-ciSkZP bwSYJA">{</span> <span class="sc-jcwpoC kyvWZW">return</span> Type<span class="sc-ciSkZP bwSYJA">.</span>nullType<span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">synthBoolean</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span>BooleanLiteral<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> Type <span class="sc-ciSkZP bwSYJA">{</span> <span class="sc-jcwpoC kyvWZW">return</span> Type<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-carFqZ hBWCUB">boolean</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">synthNumber</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span>NumericLiteral<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> Type  <span class="sc-ciSkZP bwSYJA">{</span> <span class="sc-jcwpoC kyvWZW">return</span> Type<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-carFqZ hBWCUB">number</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">synthString</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span>StringLiteral<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> Type   <span class="sc-ciSkZP bwSYJA">{</span> <span class="sc-jcwpoC kyvWZW">return</span> Type<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-carFqZ hBWCUB">string</span><span class="sc-ciSkZP bwSYJA">;</span> <span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>For object expressions (of type </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L611" class="sc-gtsrHT kFWJEY"><span><code>ObjectExpression</code></span></a><span>), we synthesize a type for each property value expression, then return an object type that associates property names to types:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">synthObject</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span>ObjectExpression<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> Type <span class="sc-ciSkZP bwSYJA">{</span>
  <span class="sc-jcwpoC kyvWZW">const</span> properties <span class="sc-ciSkZP bwSYJA">=</span>
    ast<span class="sc-ciSkZP bwSYJA">.</span>properties<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">map</span><span class="sc-ciSkZP bwSYJA">(</span>prop <span class="sc-ciSkZP bwSYJA">=&gt;</span> <span class="sc-ciSkZP bwSYJA">{</span>
      <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isObjectProperty</span><span class="sc-ciSkZP bwSYJA">(</span>prop<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">prop</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-jcwpoC kyvWZW">type</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
      <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isIdentifier</span><span class="sc-ciSkZP bwSYJA">(</span>prop<span class="sc-ciSkZP bwSYJA">.</span>key<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">prop</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-ciSkZP bwSYJA">key</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-jcwpoC kyvWZW">type</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
      <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isExpression</span><span class="sc-ciSkZP bwSYJA">(</span>prop<span class="sc-ciSkZP bwSYJA">.</span>value<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">prop</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-ciSkZP bwSYJA">value</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-jcwpoC kyvWZW">type</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
      <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span>prop<span class="sc-ciSkZP bwSYJA">.</span>computed<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unimplemented computed</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
      <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-ciSkZP bwSYJA">{</span>
        name<span class="sc-ciSkZP bwSYJA">:</span> prop<span class="sc-ciSkZP bwSYJA">.</span>key<span class="sc-ciSkZP bwSYJA">.</span>name<span class="sc-ciSkZP bwSYJA">,</span>
        type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-iTVJFM oxVOu">synth</span><span class="sc-ciSkZP bwSYJA">(</span>prop<span class="sc-ciSkZP bwSYJA">.</span>value<span class="sc-ciSkZP bwSYJA">)</span>
      <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">;</span>
    <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">return</span> Type<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">object</span><span class="sc-ciSkZP bwSYJA">(</span>properties<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>The Babel parser parses the full JavaScript expression syntax, but we&#x27;re only implementing part of it, so we call </span><span><code>bug(`unimplemented`)</code></span><span> for cases that we don&#x27;t want to handle.</span></p><p><span>For member expressions, we synthesize the type of the left-hand side, check that it&#x27;s an object and contains the named property (using </span><span><code>Type.propType</code></span><span>, see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/propType.ts" class="sc-gtsrHT kFWJEY"><span>propType.ts</span></a><span>), and return the type of the property. We call </span><span><code>err</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) to raise an exception if these checks fail (indicating an error in the input).</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">synthMember</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span>MemberExpression<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> Type <span class="sc-ciSkZP bwSYJA">{</span>
  <span class="sc-jcwpoC kyvWZW">const</span> prop <span class="sc-ciSkZP bwSYJA">=</span> ast<span class="sc-ciSkZP bwSYJA">.</span>property<span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isIdentifier</span><span class="sc-ciSkZP bwSYJA">(</span>prop<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">prop</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-jcwpoC kyvWZW">type</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">.</span>computed<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unimplemented computed</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">const</span> object <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-iTVJFM oxVOu">synth</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">.</span>object<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span>Type<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isObject</span><span class="sc-ciSkZP bwSYJA">(</span>object<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">err</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-gXfVKN jKLUHq">&#x27;. expects object&#x27;</span><span class="sc-ciSkZP bwSYJA">,</span> ast<span class="sc-ciSkZP bwSYJA">.</span>object<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">const</span> type <span class="sc-ciSkZP bwSYJA">=</span> Type<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">propType</span><span class="sc-ciSkZP bwSYJA">(</span>object<span class="sc-ciSkZP bwSYJA">,</span> prop<span class="sc-ciSkZP bwSYJA">.</span>name<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span>type<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">err</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">no such property </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">prop</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-ciSkZP bwSYJA">name</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">,</span> prop<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">return</span> type<span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>Again we skip some cases we don&#x27;t want to handle.</span></p><h2><span>Subtyping</span></h2><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> that in some cases we need to check whether a type </span><span><code>A</code></span><span> is a </span><span><em>subtype</em></span><span> of another type </span><span><code>B</code></span><span>. I find it really helpful to think of subtyping as an adversarial game: I pass a value of type </span><span><code>A</code></span><span> to an opponent, who is allowed to perform any operations on the value that are allowed by type </span><span><code>B</code></span><span>. If my opponent can&#x27;t perform any unsupported operation on the value, I win—</span><span><code>A</code></span><span> is a subtype of </span><span><code>B</code></span><span>. Otherwise my opponent wins—</span><span><code>A</code></span><span> is not a subtype of </span><span><code>B</code></span><span>.</span></p><p><span>My opponent can take the result of an operation and perform further operations on it. So </span><span><code>A</code></span><span> is a subtype of </span><span><code>B</code></span><span> when all the operations supported on </span><span><code>B</code></span><span> are also supported on </span><span><code>A</code></span><span>; and further, that the result of each operation on </span><span><code>A</code></span><span> is a subtype of the result of the same operation on </span><span><code>B</code></span><span>.</span></p><p><span>Since we have only a handful of types in this fragment, the subtyping function is simple (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/isSubtype.ts" class="sc-gtsrHT kFWJEY"><span>isSubtype.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">isSubtype</span><span class="sc-ciSkZP bwSYJA">(</span>a<span class="sc-ciSkZP bwSYJA">:</span> Type<span class="sc-ciSkZP bwSYJA">,</span> b<span class="sc-ciSkZP bwSYJA">:</span> Type<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">boolean</span> <span class="sc-ciSkZP bwSYJA">{</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-iTVJFM oxVOu">isNull</span><span class="sc-ciSkZP bwSYJA">(</span>a<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">&amp;&amp;</span> <span class="sc-iTVJFM oxVOu">isNull</span><span class="sc-ciSkZP bwSYJA">(</span>b<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-cBoqAE lRfdj">true</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-iTVJFM oxVOu">isBoolean</span><span class="sc-ciSkZP bwSYJA">(</span>a<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">&amp;&amp;</span> <span class="sc-iTVJFM oxVOu">isBoolean</span><span class="sc-ciSkZP bwSYJA">(</span>b<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-cBoqAE lRfdj">true</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-iTVJFM oxVOu">isNumber</span><span class="sc-ciSkZP bwSYJA">(</span>a<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">&amp;&amp;</span> <span class="sc-iTVJFM oxVOu">isNumber</span><span class="sc-ciSkZP bwSYJA">(</span>b<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-cBoqAE lRfdj">true</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-iTVJFM oxVOu">isString</span><span class="sc-ciSkZP bwSYJA">(</span>a<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">&amp;&amp;</span> <span class="sc-iTVJFM oxVOu">isString</span><span class="sc-ciSkZP bwSYJA">(</span>b<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-cBoqAE lRfdj">true</span><span class="sc-ciSkZP bwSYJA">;</span>

  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-iTVJFM oxVOu">isObject</span><span class="sc-ciSkZP bwSYJA">(</span>a<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">&amp;&amp;</span> <span class="sc-iTVJFM oxVOu">isObject</span><span class="sc-ciSkZP bwSYJA">(</span>b<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">{</span>
    <span class="sc-jcwpoC kyvWZW">return</span> b<span class="sc-ciSkZP bwSYJA">.</span>properties<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">every</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">:</span> bName<span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">:</span> bType <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">=&gt;</span> <span class="sc-ciSkZP bwSYJA">{</span>
      <span class="sc-jcwpoC kyvWZW">const</span> aType <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-iTVJFM oxVOu">propType</span><span class="sc-ciSkZP bwSYJA">(</span>a<span class="sc-ciSkZP bwSYJA">,</span> bName<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
      <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span>aType<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-cBoqAE lRfdj">false</span><span class="sc-ciSkZP bwSYJA">;</span>
      <span class="sc-jcwpoC kyvWZW">else</span> <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-iTVJFM oxVOu">isSubtype</span><span class="sc-ciSkZP bwSYJA">(</span>aType<span class="sc-ciSkZP bwSYJA">,</span> bType<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
    <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-ciSkZP bwSYJA">}</span>

  <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-cBoqAE lRfdj">false</span><span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>Each primitive type is a subtype of itself but no other type. An object type </span><span><code>A</code></span><span> is a subtype of an object type </span><span><code>B</code></span><span> if all the properties we can access on </span><span><code>B</code></span><span> can also be accessed on </span><span><code>A</code></span><span> (the order of properties doesn&#x27;t matter), and each of those properties on </span><span><code>A</code></span><span> is a subtype of the corresponding property on </span><span><code>B</code></span><span>.</span></p><p><span>For example, this type of rectangles with labelled points:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">{</span>
  upperLeft<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> label<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">string</span><span class="sc-ciSkZP bwSYJA">,</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
  lowerRight<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> label<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">string</span><span class="sc-ciSkZP bwSYJA">,</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>is a subtype of this type of rectangles with unlabelled points:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">{</span>
  upperLeft<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
  lowerRight<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><h2><span>Checking expressions against types</span></h2><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> that to </span><span><em>check</em></span><span> an expression </span><span><em>against</em></span><span> an expected type, we break down the expression and type and recursively check each expression part against the corresponding type part. When we can&#x27;t break down the expression or type, we synthesize a type for the expression, then check to see that the synthesized type is a subtype of the expected type.</span></p><p><span>First we case over the expression and expected type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/check.ts" class="sc-gtsrHT kFWJEY"><span>check.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">check</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">:</span> Expression<span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">:</span> Type<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">{</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isObjectExpression</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">&amp;&amp;</span> Type<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isObject</span><span class="sc-ciSkZP bwSYJA">(</span>type<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span>
    <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-iTVJFM oxVOu">checkObject</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>

  <span class="sc-jcwpoC kyvWZW">const</span> synthType <span class="sc-ciSkZP bwSYJA">=</span> <span class="sc-iTVJFM oxVOu">synth</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span>Type<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isSubtype</span><span class="sc-ciSkZP bwSYJA">(</span>synthType<span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span>
    <span class="sc-iTVJFM oxVOu">err</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">expected </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">Type</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">toString</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">type</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-gXfVKN jKLUHq">, got </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">Type</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">toString</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">synthType</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">,</span> ast<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>In this fragment, we can only break down object expressions against object types. Otherwise we synthesize a type and compare it to the expected type with </span><span><code>Type.isSubtype</code></span><span>.</span></p><p><span>To check an object expression against an object type, we match expression properties with type properties by name, then check each property value expression against the corresponding property type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">checkObject</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">:</span> ObjectExpression<span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">:</span> Type<span class="sc-ciSkZP bwSYJA">.</span>Object<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">{</span>
  <span class="sc-jcwpoC kyvWZW">const</span> astProps<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">string</span><span class="sc-ciSkZP bwSYJA">,</span> expr<span class="sc-ciSkZP bwSYJA">:</span> Expression<span class="sc-ciSkZP bwSYJA">,</span> key<span class="sc-ciSkZP bwSYJA">:</span> Identifier <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">[</span><span class="sc-ciSkZP bwSYJA">]</span> <span class="sc-ciSkZP bwSYJA">=</span>
    ast<span class="sc-ciSkZP bwSYJA">.</span>properties<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">map</span><span class="sc-ciSkZP bwSYJA">(</span>prop <span class="sc-ciSkZP bwSYJA">=&gt;</span> <span class="sc-ciSkZP bwSYJA">{</span>
      <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isObjectProperty</span><span class="sc-ciSkZP bwSYJA">(</span>prop<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">prop</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-jcwpoC kyvWZW">type</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
      <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span>prop<span class="sc-ciSkZP bwSYJA">.</span>computed<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unimplemented computed</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
      <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isIdentifier</span><span class="sc-ciSkZP bwSYJA">(</span>prop<span class="sc-ciSkZP bwSYJA">.</span>key<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">prop</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-ciSkZP bwSYJA">key</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-jcwpoC kyvWZW">type</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
      <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">isExpression</span><span class="sc-ciSkZP bwSYJA">(</span>prop<span class="sc-ciSkZP bwSYJA">.</span>value<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">bug</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">prop</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-ciSkZP bwSYJA">value</span><span class="sc-ciSkZP bwSYJA">.</span><span class="sc-jcwpoC kyvWZW">type</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
      <span class="sc-jcwpoC kyvWZW">return</span> <span class="sc-ciSkZP bwSYJA">{</span>
        name<span class="sc-ciSkZP bwSYJA">:</span> prop<span class="sc-ciSkZP bwSYJA">.</span>key<span class="sc-ciSkZP bwSYJA">.</span>name<span class="sc-ciSkZP bwSYJA">,</span>
        expr<span class="sc-ciSkZP bwSYJA">:</span> prop<span class="sc-ciSkZP bwSYJA">.</span>value <span class="sc-jcwpoC kyvWZW">as</span> Expression<span class="sc-ciSkZP bwSYJA">,</span>
        key<span class="sc-ciSkZP bwSYJA">:</span> prop<span class="sc-ciSkZP bwSYJA">.</span>key
      <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">;</span>
    <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>

  type<span class="sc-ciSkZP bwSYJA">.</span>properties<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">forEach</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">{</span> name <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">=&gt;</span> <span class="sc-ciSkZP bwSYJA">{</span>
    <span class="sc-jcwpoC kyvWZW">const</span> astProp <span class="sc-ciSkZP bwSYJA">=</span> astProps<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">find</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">:</span> astName <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">=&gt;</span> astName <span class="sc-ciSkZP bwSYJA">===</span> name<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
    <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">!</span>astProp<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">err</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">missing property </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">name</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">,</span> ast<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>

  astProps<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">forEach</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">,</span> expr<span class="sc-ciSkZP bwSYJA">,</span> key <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-ciSkZP bwSYJA">=&gt;</span> <span class="sc-ciSkZP bwSYJA">{</span>
    <span class="sc-jcwpoC kyvWZW">const</span> propType <span class="sc-ciSkZP bwSYJA">=</span> Type<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">propType</span><span class="sc-ciSkZP bwSYJA">(</span>type<span class="sc-ciSkZP bwSYJA">,</span> name<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
    <span class="sc-jcwpoC kyvWZW">if</span> <span class="sc-ciSkZP bwSYJA">(</span>propType<span class="sc-ciSkZP bwSYJA">)</span> <span class="sc-iTVJFM oxVOu">check</span><span class="sc-ciSkZP bwSYJA">(</span>expr<span class="sc-ciSkZP bwSYJA">,</span> propType<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
    <span class="sc-jcwpoC kyvWZW">else</span> <span class="sc-iTVJFM oxVOu">err</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-gXfVKN jKLUHq">extra property </span><span class="sc-ciSkZP bwSYJA">${</span><span class="sc-ciSkZP bwSYJA">name</span><span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">`</span><span class="sc-ciSkZP bwSYJA">,</span> key<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>We flag an error if the object expression is missing a property present in the type. We also flag an error if it has an extra property that&#x27;s not present in the type. You might wonder why, since an extra property can&#x27;t do any harm; in </span><span><code>isSubtype</code></span><span> we allow extra properties. But in a literal object expression, an extra property might be a bug: we meant to set an optional property but mistyped it. So we follow actual TypeScript and flag it.</span></p><p><span>Now that we&#x27;ve defined </span><span><code>check</code></span><span>, we can add a case to </span><span><code>synth</code></span><span> to synthesize </span><span><code>as</code></span><span> expressions by checking the expression against the given type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jcwpoC kyvWZW">function</span> <span class="sc-iTVJFM oxVOu">synthTSAs</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ciSkZP bwSYJA">.</span>TSAsExpression<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">:</span> Type <span class="sc-ciSkZP bwSYJA">{</span>
  <span class="sc-jcwpoC kyvWZW">const</span> type <span class="sc-ciSkZP bwSYJA">=</span> Type<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-iTVJFM oxVOu">ofTSType</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">.</span><span class="sc-jcwpoC kyvWZW">type</span>Annotation<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-iTVJFM oxVOu">check</span><span class="sc-ciSkZP bwSYJA">(</span>ast<span class="sc-ciSkZP bwSYJA">.</span>expression<span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">)</span><span class="sc-ciSkZP bwSYJA">;</span>
  <span class="sc-jcwpoC kyvWZW">return</span> type<span class="sc-ciSkZP bwSYJA">;</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>So </span><span><code>as</code></span><span> gives us a way to tell the type checker to switch from synthesis to checking. This can be useful for debugging complicated type errors. It&#x27;s also a way to hide information about the type of an expression (but the language fragment so far is too simple to give a good example of this—more later).</span></p><h2><span>Example</span></h2><p><span>Let&#x27;s walk through an example in detail:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">{</span>
  x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">7</span><span class="sc-ciSkZP bwSYJA">,</span>
  y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> a<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;foo&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> b<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;bar&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">.</span>b
<span class="sc-ciSkZP bwSYJA">}</span> <span class="sc-jcwpoC kyvWZW">as</span> <span class="sc-ciSkZP bwSYJA">{</span> x<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span><span class="sc-ciSkZP bwSYJA">,</span> y<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-carFqZ hBWCUB">number</span> <span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>(See </span><a href="https://astexplorer.net/#/gist/4adfad800891ef430cb87db4c60dc5c2/5612db7c5bd283efbbe3a79e986b0176f5717a31" class="sc-gtsrHT kFWJEY"><span>here</span></a><span> for the full AST.) Type checking starts with a call to </span><span><code>synth</code></span><span>:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">synth</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">{</span>
  type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;TSAsExpression&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
  expression<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;ObjectExpression&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> properties<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">[</span> <span class="sc-ciSkZP bwSYJA">...</span> <span class="sc-ciSkZP bwSYJA">]</span> <span class="sc-ciSkZP bwSYJA">}</span>
  <span class="sc-jcwpoC kyvWZW">type</span>Annotation<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">...</span>
<span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span></code></pre><p><span>The top-level node is </span><span><code>TSASExpression</code></span><span>, so we call </span><span><code>check</code></span><span> on the </span><span><code>expression</code></span><span> property with the given type (first translating the parsed </span><span><code>typeAnnotation</code></span><span> to our </span><span><code>Type</code></span><span> representation with </span><span><code>Type.ofTSType</code></span><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">check</span><span class="sc-ciSkZP bwSYJA">(</span>
  <span class="sc-iBzEeX glZmJR">// check this expression</span>
  <span class="sc-ciSkZP bwSYJA">{</span>
    type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;ObjectExpression&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
    properties<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">[</span>
      <span class="sc-ciSkZP bwSYJA">{</span>
        type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;ObjectProperty&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
        key<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Identifier&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;x&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
        value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;NumericLiteral&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">7</span> <span class="sc-ciSkZP bwSYJA">}</span>
      <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
      <span class="sc-ciSkZP bwSYJA">{</span>
        type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;ObjectProperty&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
        key<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Identifier&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;y&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
        value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;MemberExpression&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> <span class="sc-ciSkZP bwSYJA">...</span> <span class="sc-ciSkZP bwSYJA">}</span>
      <span class="sc-ciSkZP bwSYJA">}</span>
    <span class="sc-ciSkZP bwSYJA">]</span>
  <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
  <span class="sc-iBzEeX glZmJR">// against this type</span>
  <span class="sc-ciSkZP bwSYJA">{</span>
    type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Object&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
    properties<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">[</span>
      <span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;x&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Number&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
      <span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;y&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Number&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span> <span class="sc-ciSkZP bwSYJA">}</span>
    <span class="sc-ciSkZP bwSYJA">]</span>
  <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-ciSkZP bwSYJA">)</span></code></pre><p><span>To check an </span><span><code>ObjectExpression</code></span><span> against an </span><span><code>Object</code></span><span> type, we check each property value expression against the corresponding property type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iBzEeX glZmJR">// property x</span>
<span class="sc-iTVJFM oxVOu">check</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;NumericLiteral&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-hiKfDv dRsyqq">7</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Number&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span>

<span class="sc-iBzEeX glZmJR">// property y</span>
<span class="sc-iTVJFM oxVOu">check</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;MemberExpression&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> <span class="sc-ciSkZP bwSYJA">...</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Number&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span></code></pre><p><span>We can&#x27;t break down either of these further, so for each we </span><span><code>synth</code></span><span> a type for the expression, then compare it to the expected type with </span><span><code>isSubtype</code></span><span>. For </span><span><code>x</code></span><span> we </span><span><code>synth</code></span><span> type </span><span><code>Number</code></span><span> and check that it&#x27;s a subtype of </span><span><code>Number</code></span><span>. For </span><span><code>y</code></span><span> we first </span><span><code>synth</code></span><span> a type for </span><span><code>{ a: &quot;foo&quot;, b: &quot;bar&quot; }.b</code></span><span>:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">synth</span><span class="sc-ciSkZP bwSYJA">(</span><span class="sc-ciSkZP bwSYJA">{</span>
  type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;MemberExpression&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
  object<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span>
    type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;ObjectExpression&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
    properties<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">[</span>
      <span class="sc-ciSkZP bwSYJA">{</span>
        type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;ObjectProperty&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
        key<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Identifier&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;a&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
        value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;StringLiteral&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;foo&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span>
      <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
      <span class="sc-ciSkZP bwSYJA">{</span>
        type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;ObjectProperty&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
        key<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Identifier&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;b&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
        value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;StringLiteral&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> value<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;bar&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span>
      <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
    <span class="sc-ciSkZP bwSYJA">]</span>
  <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
  property<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Identifier&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;b&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span>
<span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">)</span></code></pre><p><span>To </span><span><code>synth</code></span><span> a type for a </span><span><code>MemberExpression</code></span><span>, we first </span><span><code>synth</code></span><span> a type for the </span><span><code>object</code></span><span> property—to </span><span><code>synth</code></span><span> a type for an </span><span><code>ObjectExpression</code></span><span> we synth types for the property values and return this type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">{</span>
  type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;Object&quot;</span><span class="sc-ciSkZP bwSYJA">,</span>
  properties<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">[</span>
    <span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;a&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;String&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span> <span class="sc-ciSkZP bwSYJA">}</span><span class="sc-ciSkZP bwSYJA">,</span>
    <span class="sc-ciSkZP bwSYJA">{</span> name<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;b&quot;</span><span class="sc-ciSkZP bwSYJA">,</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-ciSkZP bwSYJA">{</span> type<span class="sc-ciSkZP bwSYJA">:</span> <span class="sc-gXfVKN jKLUHq">&quot;String&quot;</span> <span class="sc-ciSkZP bwSYJA">}</span> <span class="sc-ciSkZP bwSYJA">}</span>
  <span class="sc-ciSkZP bwSYJA">]</span>
<span class="sc-ciSkZP bwSYJA">}</span></code></pre><p><span>then project the </span><span><code>b</code></span><span> property to get type </span><span><code>String</code></span><span> for the whole </span><span><code>MemberExpression</code></span><span>. Finally we check that </span><span><code>String</code></span><span> is a subtype of </span><span><code>Number</code></span><span>, and flag an error because it is not.</span></p><h2><span>Try it!</span></h2><p><span>You can try out the type checker below: type an expression into the top box, see its synthesized type (or an error) in the bottom box. To check an expression against a type, ascribing a type with </span><span><code>as</code></span><span>. (Remember that the only supported expressions in this fragment are primitive literals, object expressions, member expressions, and </span><span><code>as</code></span><span> ascriptions.)</span></p><iframe src="https://jaked.org/reconstructing-typescript/part1/" width="700" height="300" style="border-style:none"></iframe><h2><span>The plan</span></h2><p><span>For the full code of part 1 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part1" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part1</span></a><span>.</span></p><p><span>Next time we&#x27;ll add functions and function calls to the language—we&#x27;ll add a </span><span><em>type environment</em></span><span> to track the types of variables, and see how subtyping for functions requires </span><span><em>contravariance</em></span><span>.</span></p><ul><li><p><span></span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>Part 0: intro and background</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>Part 1: bidirectional type checking</span></a><span></span></p></li><li><p><span>Part 2: functions and function calls</span></p></li><li><p><span>Part 3: singleton / literal types and arithmetic / logical operators</span></p></li><li><p><span>Part 4: union types</span></p></li><li><p><span>Part 5: intersection types</span></p></li><li><p><span>Part 6: narrowing</span></p></li></ul><p><span>Thanks to Julia Evans, Tony Chow, and Will Lachance for helpful feedback on a draft of this post.</span></p><p><span>Please </span><a href="/blog/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p></div></body></html>