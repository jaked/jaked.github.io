<html><head><title>Reconstructing TypeScript, part 1: bidirectional type checking</title><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@jakedonham"/><meta name="twitter:creator" content="@jakedonham"/><meta name="twitter:title" content="Reconstructing TypeScript, part 1: bidirectional type checking"/><meta name="twitter:description" content="Reconstructing TypeScript, part 1: bidirectional type checking"/><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/2021-09-15-Reconstructing-TypeScript-part-1.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.bOWasK{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;overflow:auto;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"bOWasK,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.laKGqb{color:#116644;}/*!sc*/
data-styled.g38[id="sc-jJMGnK"]{content:"laKGqb,"}/*!sc*/
.dRsyqq{color:#aa1111;}/*!sc*/
data-styled.g39[id="sc-hiKfDv"]{content:"dRsyqq,"}/*!sc*/
.jKLUHq{color:#221199;}/*!sc*/
data-styled.g40[id="sc-gXfVKN"]{content:"jKLUHq,"}/*!sc*/
.lRfdj{color:#000000;}/*!sc*/
data-styled.g41[id="sc-cBoqAE"]{content:"lRfdj,"}/*!sc*/
.bwSYJA{color:#770088;}/*!sc*/
data-styled.g42[id="sc-ciSkZP"]{content:"bwSYJA,"}/*!sc*/
.kyvWZW{color:#268bd2;}/*!sc*/
data-styled.g43[id="sc-jcwpoC"]{content:"kyvWZW,"}/*!sc*/
.hBWCUB{color:#b58900;}/*!sc*/
data-styled.g44[id="sc-carFqZ"]{content:"hBWCUB,"}/*!sc*/
.oxVOu{color:#009900;}/*!sc*/
data-styled.g45[id="sc-iTVJFM"]{content:"oxVOu,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript, part 1</span></p><h1 id="reconstructing-typescript-part-1-bidirectional-type-checking"><span>Reconstructing TypeScript, part 1: bidirectional type checking</span></h1><h3 id="2021-09-15"><span><em>2021-09-15</em></span></h3><p><span>This post is part of a series about implementing type checking for a TypeScript-like language. In the </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>last post </span></a><span> I gave some background about type checking, TypeScript&#x27;s type system, and the approach we&#x27;ll use, called </span><span><em>bidirectional type checking</em></span><span>.</span></p><p><span>Now let&#x27;s write a type checker! We&#x27;re going to start with a tiny fragment of the language, and build it up incrementally in subsequent posts. In this fragment we&#x27;ll handle only primitive literals like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jJMGnK laKGqb">7</span>
<span class="sc-hiKfDv dRsyqq">&quot;TypeScript is cool.&quot;</span>
<span class="sc-gXfVKN jKLUHq">false</span></code></pre><p><span>object literals like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">{</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">7</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">9</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-cBoqAE lRfdj">{</span> foo<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;bar&quot;</span><span class="sc-cBoqAE lRfdj">,</span> baz<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-gXfVKN jKLUHq">false</span> <span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>and member expressions like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">{</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">7</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">9</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">.</span>x</code></pre><p><span>(We don&#x27;t have variables yet, so member expressions look a little weird!)</span></p><p><span>We&#x27;ll also handle </span><span><em>type ascriptions</em></span><span> like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">{</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">7</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;foo&quot;</span> <span class="sc-cBoqAE lRfdj">}</span> <span class="sc-ciSkZP bwSYJA">as</span> <span class="sc-cBoqAE lRfdj">{</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span> <span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>In actual TypeScript, </span><span><code>as</code></span><span> is an unsafe cast, a way to tell the type checker, &quot;trust me, this expression has this type!&quot; Here it is a way to guide the type checker (more on this below), but it&#x27;s not unsafe—the type checker still ensures that the program doesn&#x27;t attempt any unsupported operations.</span></p><h2 id="parsing-code-into-an-abstract-syntax-tree"><span>Parsing code into an abstract syntax tree</span></h2><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0#synthesizing-a-type-from-an-expression"><span>part 0</span></a><span> that type checking works on an </span><span><em>abstract syntax tree</em></span><span> representation of code, where each expression in a program is a node in the tree, with its subexpressions as children. So first we need to parse code strings to ASTs. We use </span><a href="https://babeljs.io/docs/en/babel-parser" class="sc-gtsrHT kFWJEY"><span>@babel/parser</span></a><span> with the TypeScript plugin (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/ast/parse.ts" class="sc-gtsrHT kFWJEY"><span>parse.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">parseExpression</span><span class="sc-cBoqAE lRfdj">(</span>input<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">string</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> Expression <span class="sc-cBoqAE lRfdj">{</span>
  <span class="sc-ciSkZP bwSYJA">return</span> Babel<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">parseExpression</span><span class="sc-cBoqAE lRfdj">(</span>input<span class="sc-cBoqAE lRfdj">,</span> <span class="sc-cBoqAE lRfdj">{</span>
    plugins<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">[</span> <span class="sc-hiKfDv dRsyqq">&#x27;typescript&#x27;</span> <span class="sc-cBoqAE lRfdj">]</span>
  <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>which produces a value of type </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2058" class="sc-gtsrHT kFWJEY"><span><code>Expression</code></span></a><span> from </span><a href="https://babeljs.io/docs/en/babel-types" class="sc-gtsrHT kFWJEY"><span>@babel/types</span></a><span>. For example, if we call </span><span><code>parseExpression</code></span><span> on an object expression</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">{</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">7</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">9</span> <span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>we get an </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L611" class="sc-gtsrHT kFWJEY"><span><code>ObjectExpression</code></span></a><span> AST with </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L634" class="sc-gtsrHT kFWJEY"><span><code>ObjectProperty</code></span></a><span> ASTs as children:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">{</span>
  type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;ObjectExpression&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
  properties<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">[</span>
    <span class="sc-cBoqAE lRfdj">{</span>
      type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;ObjectProperty&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
      key<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Identifier&quot;</span><span class="sc-cBoqAE lRfdj">,</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;x&quot;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
      value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;NumericLiteral&quot;</span><span class="sc-cBoqAE lRfdj">,</span> value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">7</span> <span class="sc-cBoqAE lRfdj">}</span>
    <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
    <span class="sc-cBoqAE lRfdj">{</span>
      type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;ObjectProperty&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
      key<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Identifier&quot;</span><span class="sc-cBoqAE lRfdj">,</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;y&quot;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
      value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;NumericLiteral&quot;</span><span class="sc-cBoqAE lRfdj">,</span> value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">9</span> <span class="sc-cBoqAE lRfdj">}</span>
    <span class="sc-cBoqAE lRfdj">}</span>
  <span class="sc-cBoqAE lRfdj">]</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>Each node has a </span><span><code>type</code></span><span> property saying what kind of syntax it represents, and each kind of node has kind-specific properties for subexpressions and other attributes. (I&#x27;ve trimmed out properties that describe the location of each AST node in the original code string.)</span></p><p><span>To keep things simple, our type checker will handle only expressions, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-hiKfDv dRsyqq">&quot;TypeScript is cool&quot;</span>
<span class="sc-cBoqAE lRfdj">{</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">7</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">9</span> <span class="sc-cBoqAE lRfdj">}</span>
x <span class="sc-cBoqAE lRfdj">&gt;</span> <span class="sc-jJMGnK laKGqb">0</span> <span class="sc-cBoqAE lRfdj">?</span> x <span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">-</span>x</code></pre><p><span>not statements, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">const</span> x <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-jJMGnK laKGqb">7</span>
<span class="sc-ciSkZP bwSYJA">for</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-ciSkZP bwSYJA">let</span> i <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-jJMGnK laKGqb">0</span><span class="sc-cBoqAE lRfdj">;</span> i <span class="sc-cBoqAE lRfdj">&lt;</span> <span class="sc-jJMGnK laKGqb">10</span><span class="sc-cBoqAE lRfdj">;</span> i<span class="sc-cBoqAE lRfdj">++</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">{</span> <span class="sc-cBoqAE lRfdj">...</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-ciSkZP bwSYJA">throw</span> <span class="sc-ciSkZP bwSYJA">new</span> <span class="sc-cBoqAE lRfdj">Error</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-hiKfDv dRsyqq">&quot;bad thing&quot;</span><span class="sc-cBoqAE lRfdj">)</span></code></pre><p><span>so we only need to parse expressions. (We&#x27;ll also parse types, see below.)</span></p><p><span>The full </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2058" class="sc-gtsrHT kFWJEY"><span><code>Expression</code></span></a><span> type is pretty complicated, and it&#x27;s not always obvious what the different properties mean. So it&#x27;s really helpful to be able to browse the AST produced by a piece of code. I use the excellent </span><a href="https://astexplorer.net/" class="sc-gtsrHT kFWJEY"><span>AST Explorer</span></a><span> for this. (Set the language to </span><span><code>JavaScript</code></span><span> and the parser to </span><span><code>@babel/parser.</code></span><span> Then click the gear icon next to </span><span><code>@babel/parser</code></span><span>, enable the </span><span><code>typescript</code></span><span> plugin, and disable the </span><span><code>flow</code></span><span> plugin.)</span></p><p><span>Be aware that AST Explorer parses programs, not expressions; so if you feed it an expression, the AST is wrapped in </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L602" class="sc-gtsrHT kFWJEY"><span><code>Program</code></span></a><span> and </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L455" class="sc-gtsrHT kFWJEY"><span><code>ExpressionStatement</code></span></a><span> nodes. Usually it&#x27;s OK to write an expression where a statement is expected, but for object expressions you need to wrap parentheses around them, or else the parser sees </span><span><code>{</code></span><span> and tries to parse a block of statements.</span></p><h2 id="representing-types"><span>Representing types</span></h2><p><span>To synthesize and check types, we need a way to represent them. In this fragment we support only a few types—primitive literals, and objects made up of properties (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/types.ts" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">type</span> <span class="sc-cBoqAE lRfdj">Type</span> <span class="sc-cBoqAE lRfdj">=</span> Null <span class="sc-cBoqAE lRfdj">|</span> Boolean <span class="sc-cBoqAE lRfdj">|</span> Number <span class="sc-cBoqAE lRfdj">|</span> String <span class="sc-cBoqAE lRfdj">|</span> Object<span class="sc-cBoqAE lRfdj">;</span>

<span class="sc-ciSkZP bwSYJA">type</span> <span class="sc-cBoqAE lRfdj">Null</span> <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Null&#x27;</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-ciSkZP bwSYJA">type</span> <span class="sc-cBoqAE lRfdj">Boolean</span> <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Boolean&#x27;</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-ciSkZP bwSYJA">type</span> <span class="sc-cBoqAE lRfdj">Number</span> <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Number&#x27;</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-ciSkZP bwSYJA">type</span> <span class="sc-cBoqAE lRfdj">String</span> <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;String&#x27;</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span>

<span class="sc-ciSkZP bwSYJA">type</span> <span class="sc-cBoqAE lRfdj">Object</span> <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-cBoqAE lRfdj">{</span>
  type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-cBoqAE lRfdj">;</span>
  properties<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">string</span><span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">:</span> Type <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">[</span><span class="sc-cBoqAE lRfdj">]</span><span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>For example, the type</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">{</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span> <span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>is represented by the value</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">{</span>
  type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-cBoqAE lRfdj">,</span>
  properties<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">[</span>
    <span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;x&#x27;</span><span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Number&#x27;</span> <span class="sc-cBoqAE lRfdj">}</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
    <span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;y&#x27;</span><span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Number&#x27;</span> <span class="sc-cBoqAE lRfdj">}</span> <span class="sc-cBoqAE lRfdj">}</span>
  <span class="sc-cBoqAE lRfdj">]</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><h3 id="constructors"><span><em>Constructors</em></span></h3><p><span>We have predefined constants and helper functions to construct types (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/constructors.ts" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">const</span> nullType<span class="sc-cBoqAE lRfdj">:</span> Null <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Null&#x27;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-ciSkZP bwSYJA">const</span> <span class="sc-jcwpoC kyvWZW">boolean</span><span class="sc-cBoqAE lRfdj">:</span> Boolean <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Boolean&#x27;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-ciSkZP bwSYJA">const</span> <span class="sc-jcwpoC kyvWZW">number</span><span class="sc-cBoqAE lRfdj">:</span> Number <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Number&#x27;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-ciSkZP bwSYJA">const</span> <span class="sc-jcwpoC kyvWZW">string</span><span class="sc-cBoqAE lRfdj">:</span> String <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;String&#x27;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">;</span></code></pre><p><span>The properties of an object type are represented as an array, but it&#x27;s often convenient to construct object types by passing an object mapping names to types, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">const</span> type <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-carFqZ hBWCUB">object</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">{</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span></code></pre><p><span>so the </span><span><code>object</code></span><span> constructor takes either an array of properties or an object mapping names to types:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">object</span><span class="sc-cBoqAE lRfdj">(</span>
  properties<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">string</span><span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">:</span> Type <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">[</span><span class="sc-cBoqAE lRfdj">]</span> <span class="sc-cBoqAE lRfdj">|</span> <span class="sc-cBoqAE lRfdj">{</span> <span class="sc-cBoqAE lRfdj">[</span>name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">string</span><span class="sc-cBoqAE lRfdj">]</span><span class="sc-cBoqAE lRfdj">:</span> Type <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> Object <span class="sc-cBoqAE lRfdj">{</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-jcwpoC kyvWZW">Array</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isArray</span><span class="sc-cBoqAE lRfdj">(</span>properties<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">{</span>
    <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-cBoqAE lRfdj">,</span> properties <span class="sc-cBoqAE lRfdj">}</span>
  <span class="sc-cBoqAE lRfdj">}</span> <span class="sc-ciSkZP bwSYJA">else</span> <span class="sc-cBoqAE lRfdj">{</span>
    <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-carFqZ hBWCUB">object</span><span class="sc-cBoqAE lRfdj">(</span>
      Object<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">entries</span><span class="sc-cBoqAE lRfdj">(</span>properties<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">map</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">[</span> name<span class="sc-cBoqAE lRfdj">,</span> type <span class="sc-cBoqAE lRfdj">]</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">=&gt;</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">,</span> <span class="sc-ciSkZP bwSYJA">type</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span>
    <span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>This is a nice example of the flexibility of union types: rather than define a separate function to convert an object argument to an array, we give the argument a union type. If </span><span><code>Array.isArray(properties)</code></span><span> is true, we know from the argument type that </span><span><code>properties</code></span><span> must be an array of </span><span><code>{ name: string, type: Type }</code></span><span> objects, so we can directly construct an </span><span><code>Object</code></span><span> type. Otherwise it must be an object mapping property names to </span><span><code>Type</code></span><span>s, so we walk the object entries to build an array.</span></p><h3 id="validators"><span><em>Validators</em></span></h3><p><span>We have validators for distinguishing different kinds of </span><span><code>Type</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/validators.ts" class="sc-gtsrHT kFWJEY"><span>validators.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">isNull</span><span class="sc-cBoqAE lRfdj">(</span>t<span class="sc-cBoqAE lRfdj">:</span> Type<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> t <span class="sc-ciSkZP bwSYJA">is</span> Null       <span class="sc-cBoqAE lRfdj">{</span> <span class="sc-ciSkZP bwSYJA">return</span> t<span class="sc-cBoqAE lRfdj">.</span>type <span class="sc-cBoqAE lRfdj">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Null&#x27;</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">isBoolean</span><span class="sc-cBoqAE lRfdj">(</span>t<span class="sc-cBoqAE lRfdj">:</span> Type<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> t <span class="sc-ciSkZP bwSYJA">is</span> Boolean <span class="sc-cBoqAE lRfdj">{</span> <span class="sc-ciSkZP bwSYJA">return</span> t<span class="sc-cBoqAE lRfdj">.</span>type <span class="sc-cBoqAE lRfdj">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Boolean&#x27;</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">isNumber</span><span class="sc-cBoqAE lRfdj">(</span>t<span class="sc-cBoqAE lRfdj">:</span> Type<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> t <span class="sc-ciSkZP bwSYJA">is</span> Number   <span class="sc-cBoqAE lRfdj">{</span> <span class="sc-ciSkZP bwSYJA">return</span> t<span class="sc-cBoqAE lRfdj">.</span>type <span class="sc-cBoqAE lRfdj">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Number&#x27;</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">isString</span><span class="sc-cBoqAE lRfdj">(</span>t<span class="sc-cBoqAE lRfdj">:</span> Type<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> t <span class="sc-ciSkZP bwSYJA">is</span> String   <span class="sc-cBoqAE lRfdj">{</span> <span class="sc-ciSkZP bwSYJA">return</span> t<span class="sc-cBoqAE lRfdj">.</span>type <span class="sc-cBoqAE lRfdj">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;String&#x27;</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">isObject</span><span class="sc-cBoqAE lRfdj">(</span>t<span class="sc-cBoqAE lRfdj">:</span> Type<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> t <span class="sc-ciSkZP bwSYJA">is</span> Object   <span class="sc-cBoqAE lRfdj">{</span> <span class="sc-ciSkZP bwSYJA">return</span> t<span class="sc-cBoqAE lRfdj">.</span>type <span class="sc-cBoqAE lRfdj">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>The return type </span><span><code>t is Null</code></span><span> (for example) is a </span><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" class="sc-gtsrHT kFWJEY"><span>type predicate</span></a><span>; when a call to the validator returns </span><span><code>true</code></span><span>, the type checker narrows </span><span><code>t</code></span><span> to type </span><span><code>Null</code></span><span>, just as it would have if the test </span><span><code>t.type === Null</code></span><span> had appeared directly in the code.</span></p><h3 id="type-module"><span><em>Type module</em></span></h3><p><span>We wrap these types, constructors, validators, and other type-related functions into a module (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/index.ts" class="sc-gtsrHT kFWJEY"><span>type/index.ts</span></a><span>) so we can write </span><span><code>Type.Boolean</code></span><span> (the type), </span><span><code>Type.boolean </code></span><span>(the constructor), </span><span><code>Type.object({ ... })</code></span><span>, </span><span><code>Type.isObject</code></span><span>, </span><span><code>Type.toString</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/toString.ts" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span>), and so on.</span></p><h3 id="parsing-types"><span><em>Parsing types</em></span></h3><p><span>For writing tests it&#x27;s useful to parse a type on its own. Babel doesn&#x27;t provide a function for this, but we can parse an </span><span><code>as</code></span><span> expression and pull out the type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">parseType</span><span class="sc-cBoqAE lRfdj">(</span>input<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">string</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> Type <span class="sc-cBoqAE lRfdj">{</span>
  <span class="sc-ciSkZP bwSYJA">const</span> ast <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-carFqZ hBWCUB">parseExpression</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">_ as </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">input</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isTSAsExpression</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unexpected </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">ast</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-ciSkZP bwSYJA">type</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">return</span> Type<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">ofTSType</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">.</span><span class="sc-ciSkZP bwSYJA">type</span>Annotation<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>Here </span><span><code>Type.ofTSType</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/ofTSType.ts" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span>) converts a Babel </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2488" class="sc-gtsrHT kFWJEY"><span><code>TSType</code></span></a><span> AST (which represents a parsed type) to our </span><span><code>Type</code></span><span> representation. And </span><span><code>bug</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) throws an exception indicating a bug in the code.</span></p><p><span>The call to </span><span><code>bug</code></span><span> shows a use of narrowing: the return type of </span><span><code>bug</code></span><span> is </span><span><code>never</code></span><span>, meaning that the function never returns a value (it throws an exception), so the TypeScript type checker reasons that in the remainder of the function, </span><span><code>AST.isTSAsExpression(ast)</code></span><span> must be true; so the type of </span><span><code>ast</code></span><span> must be </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L1961" class="sc-gtsrHT kFWJEY"><span><code>TSAsExpression</code></span></a><span> (the </span><span><code>AST</code></span><span> validators are also type predicates), and we can safely access </span><span><code>ast.typeAnnotation</code></span><span>. We use this pattern to handle unexpected cases throughout the code.</span></p><h2 id="synthesizing-types-from-expressions"><span>Synthesizing types from expressions</span></h2><p><span>Now we have enough machinery in place to do some actual type checking:</span></p><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0#synthesizing-a-type-from-an-expression"><span>part 0</span></a><span> that to </span><span><em>synthesize</em></span><span> a type </span><span><em>from</em></span><span> an expression, we synthesize the types of its subexpressions, then combine them according to the top-level operation of the expression; for atomic expressions like literal values, we return the corresponding type.</span></p><p><span>First we case over the expression type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/synth.ts" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">synth</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span>Expression<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> Type <span class="sc-cBoqAE lRfdj">{</span>
  <span class="sc-ciSkZP bwSYJA">switch</span> <span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">.</span>type<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">{</span>
    <span class="sc-ciSkZP bwSYJA">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;NullLiteral&#x27;</span><span class="sc-cBoqAE lRfdj">:</span>      <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-carFqZ hBWCUB">synthNull</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
    <span class="sc-ciSkZP bwSYJA">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;BooleanLiteral&#x27;</span><span class="sc-cBoqAE lRfdj">:</span>   <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-carFqZ hBWCUB">synthBoolean</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
    <span class="sc-ciSkZP bwSYJA">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;NumericLiteral&#x27;</span><span class="sc-cBoqAE lRfdj">:</span>   <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-carFqZ hBWCUB">synthNumber</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
    <span class="sc-ciSkZP bwSYJA">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;StringLiteral&#x27;</span><span class="sc-cBoqAE lRfdj">:</span>    <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-carFqZ hBWCUB">synthString</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
    <span class="sc-ciSkZP bwSYJA">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;ObjectExpression&#x27;</span><span class="sc-cBoqAE lRfdj">:</span> <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-carFqZ hBWCUB">synthObject</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
    <span class="sc-ciSkZP bwSYJA">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;MemberExpression&#x27;</span><span class="sc-cBoqAE lRfdj">:</span> <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-carFqZ hBWCUB">synthMember</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>

    <span class="sc-ciSkZP bwSYJA">default</span><span class="sc-cBoqAE lRfdj">:</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">ast</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-ciSkZP bwSYJA">type</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>In each </span><span><code>case</code></span><span> of the </span><span><code>switch</code></span><span>, the type of </span><span><code>ast</code></span><span> is narrowed to the corresponding arm of </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2058" class="sc-gtsrHT kFWJEY"><span><code>Expression</code></span></a><span> (which is a big union of all the kinds of expression), so the helper functions receive the specific arm type.</span></p><p><span>For primitive literals we return the corresponding type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">synthNull</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span>NullLiteral<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> Type       <span class="sc-cBoqAE lRfdj">{</span> <span class="sc-ciSkZP bwSYJA">return</span> Type<span class="sc-cBoqAE lRfdj">.</span>nullType<span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">synthBoolean</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span>BooleanLiteral<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> Type <span class="sc-cBoqAE lRfdj">{</span> <span class="sc-ciSkZP bwSYJA">return</span> Type<span class="sc-cBoqAE lRfdj">.</span><span class="sc-jcwpoC kyvWZW">boolean</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">synthNumber</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span>NumericLiteral<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> Type  <span class="sc-cBoqAE lRfdj">{</span> <span class="sc-ciSkZP bwSYJA">return</span> Type<span class="sc-cBoqAE lRfdj">.</span><span class="sc-jcwpoC kyvWZW">number</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">synthString</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span>StringLiteral<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> Type   <span class="sc-cBoqAE lRfdj">{</span> <span class="sc-ciSkZP bwSYJA">return</span> Type<span class="sc-cBoqAE lRfdj">.</span><span class="sc-jcwpoC kyvWZW">string</span><span class="sc-cBoqAE lRfdj">;</span> <span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>For object expressions (of type </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L611" class="sc-gtsrHT kFWJEY"><span><code>ObjectExpression</code></span></a><span>), we synthesize a type for each property value expression, then return an object type that associates property names to types:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">synthObject</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span>ObjectExpression<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> Type <span class="sc-cBoqAE lRfdj">{</span>
  <span class="sc-ciSkZP bwSYJA">const</span> properties <span class="sc-cBoqAE lRfdj">=</span>
    ast<span class="sc-cBoqAE lRfdj">.</span>properties<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">map</span><span class="sc-cBoqAE lRfdj">(</span>prop <span class="sc-cBoqAE lRfdj">=&gt;</span> <span class="sc-cBoqAE lRfdj">{</span>
      <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isObjectProperty</span><span class="sc-cBoqAE lRfdj">(</span>prop<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">prop</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-ciSkZP bwSYJA">type</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
      <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isIdentifier</span><span class="sc-cBoqAE lRfdj">(</span>prop<span class="sc-cBoqAE lRfdj">.</span>key<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">prop</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-cBoqAE lRfdj">key</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-ciSkZP bwSYJA">type</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
      <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isExpression</span><span class="sc-cBoqAE lRfdj">(</span>prop<span class="sc-cBoqAE lRfdj">.</span>value<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">prop</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-cBoqAE lRfdj">value</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-ciSkZP bwSYJA">type</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
      <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span>prop<span class="sc-cBoqAE lRfdj">.</span>computed<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unimplemented computed</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
      <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-cBoqAE lRfdj">{</span>
        name<span class="sc-cBoqAE lRfdj">:</span> prop<span class="sc-cBoqAE lRfdj">.</span>key<span class="sc-cBoqAE lRfdj">.</span>name<span class="sc-cBoqAE lRfdj">,</span>
        type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-carFqZ hBWCUB">synth</span><span class="sc-cBoqAE lRfdj">(</span>prop<span class="sc-cBoqAE lRfdj">.</span>value<span class="sc-cBoqAE lRfdj">)</span>
      <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">;</span>
    <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">return</span> Type<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">object</span><span class="sc-cBoqAE lRfdj">(</span>properties<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>The Babel parser parses the full JavaScript expression syntax, but we&#x27;re only implementing part of it, so we call </span><span><code>bug(`unimplemented`)</code></span><span> for cases that we don&#x27;t want to handle.</span></p><p><span>For member expressions, we synthesize the type of the left-hand side, check that it&#x27;s an object and contains the named property (using </span><span><code>Type.propType</code></span><span>, see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/propType.ts" class="sc-gtsrHT kFWJEY"><span>propType.ts</span></a><span>), and return the type of the property. We call </span><span><code>err</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) to raise an exception if these checks fail (indicating an error in the input).</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">synthMember</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span>MemberExpression<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> Type <span class="sc-cBoqAE lRfdj">{</span>
  <span class="sc-ciSkZP bwSYJA">const</span> prop <span class="sc-cBoqAE lRfdj">=</span> ast<span class="sc-cBoqAE lRfdj">.</span>property<span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isIdentifier</span><span class="sc-cBoqAE lRfdj">(</span>prop<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">prop</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-ciSkZP bwSYJA">type</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">.</span>computed<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unimplemented computed</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">const</span> object <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-carFqZ hBWCUB">synth</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">.</span>object<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span>Type<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isObject</span><span class="sc-cBoqAE lRfdj">(</span>object<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">err</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-hiKfDv dRsyqq">&#x27;. expects object&#x27;</span><span class="sc-cBoqAE lRfdj">,</span> ast<span class="sc-cBoqAE lRfdj">.</span>object<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">const</span> type <span class="sc-cBoqAE lRfdj">=</span> Type<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">propType</span><span class="sc-cBoqAE lRfdj">(</span>object<span class="sc-cBoqAE lRfdj">,</span> prop<span class="sc-cBoqAE lRfdj">.</span>name<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span>type<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">err</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">no such property </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">prop</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-cBoqAE lRfdj">name</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">,</span> prop<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">return</span> type<span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>Again we skip some cases we don&#x27;t want to handle.</span></p><h2 id="subtyping"><span>Subtyping</span></h2><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0#subtyping"><span>part 0</span></a><span> that in some cases we need to check whether a type </span><span><code>A</code></span><span> is a </span><span><em>subtype</em></span><span> of another type </span><span><code>B</code></span><span>. I find it really helpful to think of subtyping as an adversarial game: I pass a value of type </span><span><code>A</code></span><span> to an opponent, who is allowed to perform any operations on the value that are allowed by type </span><span><code>B</code></span><span>. If my opponent can&#x27;t perform any unsupported operation on the value, I win—</span><span><code>A</code></span><span> is a subtype of </span><span><code>B</code></span><span>. Otherwise my opponent wins—</span><span><code>A</code></span><span> is not a subtype of </span><span><code>B</code></span><span>.</span></p><p><span>My opponent can take the result of an operation and perform further operations on it. So </span><span><code>A</code></span><span> is a subtype of </span><span><code>B</code></span><span> when all the operations supported on </span><span><code>B</code></span><span> are also supported on </span><span><code>A</code></span><span>; and further, that the result of each operation on </span><span><code>A</code></span><span> is a subtype of the result of the same operation on </span><span><code>B</code></span><span>.</span></p><p><span>Since we have only a handful of types in this fragment, the subtyping function is simple (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/isSubtype.ts" class="sc-gtsrHT kFWJEY"><span>isSubtype.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">isSubtype</span><span class="sc-cBoqAE lRfdj">(</span>a<span class="sc-cBoqAE lRfdj">:</span> Type<span class="sc-cBoqAE lRfdj">,</span> b<span class="sc-cBoqAE lRfdj">:</span> Type<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">boolean</span> <span class="sc-cBoqAE lRfdj">{</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-carFqZ hBWCUB">isNull</span><span class="sc-cBoqAE lRfdj">(</span>a<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">&amp;&amp;</span> <span class="sc-carFqZ hBWCUB">isNull</span><span class="sc-cBoqAE lRfdj">(</span>b<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-gXfVKN jKLUHq">true</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-carFqZ hBWCUB">isBoolean</span><span class="sc-cBoqAE lRfdj">(</span>a<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">&amp;&amp;</span> <span class="sc-carFqZ hBWCUB">isBoolean</span><span class="sc-cBoqAE lRfdj">(</span>b<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-gXfVKN jKLUHq">true</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-carFqZ hBWCUB">isNumber</span><span class="sc-cBoqAE lRfdj">(</span>a<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">&amp;&amp;</span> <span class="sc-carFqZ hBWCUB">isNumber</span><span class="sc-cBoqAE lRfdj">(</span>b<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-gXfVKN jKLUHq">true</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-carFqZ hBWCUB">isString</span><span class="sc-cBoqAE lRfdj">(</span>a<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">&amp;&amp;</span> <span class="sc-carFqZ hBWCUB">isString</span><span class="sc-cBoqAE lRfdj">(</span>b<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-gXfVKN jKLUHq">true</span><span class="sc-cBoqAE lRfdj">;</span>

  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-carFqZ hBWCUB">isObject</span><span class="sc-cBoqAE lRfdj">(</span>a<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">&amp;&amp;</span> <span class="sc-carFqZ hBWCUB">isObject</span><span class="sc-cBoqAE lRfdj">(</span>b<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">{</span>
    <span class="sc-ciSkZP bwSYJA">return</span> b<span class="sc-cBoqAE lRfdj">.</span>properties<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">every</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">:</span> bName<span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">:</span> bType <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">=&gt;</span> <span class="sc-cBoqAE lRfdj">{</span>
      <span class="sc-ciSkZP bwSYJA">const</span> aType <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-carFqZ hBWCUB">propType</span><span class="sc-cBoqAE lRfdj">(</span>a<span class="sc-cBoqAE lRfdj">,</span> bName<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
      <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span>aType<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-gXfVKN jKLUHq">false</span><span class="sc-cBoqAE lRfdj">;</span>
      <span class="sc-ciSkZP bwSYJA">else</span> <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-carFqZ hBWCUB">isSubtype</span><span class="sc-cBoqAE lRfdj">(</span>aType<span class="sc-cBoqAE lRfdj">,</span> bType<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
    <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-cBoqAE lRfdj">}</span>

  <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-gXfVKN jKLUHq">false</span><span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>Each primitive type is a subtype of itself but no other type. An object type </span><span><code>A</code></span><span> is a subtype of an object type </span><span><code>B</code></span><span> if all the properties we can access on </span><span><code>B</code></span><span> can also be accessed on </span><span><code>A</code></span><span> (the order of properties doesn&#x27;t matter), and each of those properties on </span><span><code>A</code></span><span> is a subtype of the corresponding property on </span><span><code>B</code></span><span>.</span></p><p><span>For example, this type of rectangles with labelled points:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">{</span>
  upperLeft<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> label<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">string</span><span class="sc-cBoqAE lRfdj">,</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
  lowerRight<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> label<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">string</span><span class="sc-cBoqAE lRfdj">,</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>is a subtype of this type of rectangles with unlabelled points:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">{</span>
  upperLeft<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
  lowerRight<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><h2 id="checking-expressions-against-types"><span>Checking expressions against types</span></h2><p><span>Recall from </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0#checking-an-expression-against-a-type"><span>part 0</span></a><span> that to </span><span><em>check</em></span><span> an expression </span><span><em>against</em></span><span> an expected type, we break down the expression and type and recursively check each expression part against the corresponding type part. When we can&#x27;t break down the expression or type, we synthesize a type for the expression, then check to see that the synthesized type is a subtype of the expected type.</span></p><p><span>First we case over the expression and expected type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/check.ts" class="sc-gtsrHT kFWJEY"><span>check.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">check</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">:</span> Expression<span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">:</span> Type<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">{</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isObjectExpression</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">&amp;&amp;</span> Type<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isObject</span><span class="sc-cBoqAE lRfdj">(</span>type<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span>
    <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-carFqZ hBWCUB">checkObject</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>

  <span class="sc-ciSkZP bwSYJA">const</span> synthType <span class="sc-cBoqAE lRfdj">=</span> <span class="sc-carFqZ hBWCUB">synth</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span>Type<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isSubtype</span><span class="sc-cBoqAE lRfdj">(</span>synthType<span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span>
    <span class="sc-carFqZ hBWCUB">err</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">expected </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">Type</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">toString</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">type</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-hiKfDv dRsyqq">, got </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">Type</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">toString</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">synthType</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">,</span> ast<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>In this fragment, we can only break down object expressions against object types. Otherwise we synthesize a type and compare it to the expected type with </span><span><code>Type.isSubtype</code></span><span>.</span></p><p><span>To check an object expression against an object type, we match expression properties with type properties by name, then check each property value expression against the corresponding property type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">checkObject</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">:</span> ObjectExpression<span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">:</span> Type<span class="sc-cBoqAE lRfdj">.</span>Object<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">{</span>
  <span class="sc-ciSkZP bwSYJA">const</span> astProps<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">string</span><span class="sc-cBoqAE lRfdj">,</span> expr<span class="sc-cBoqAE lRfdj">:</span> Expression<span class="sc-cBoqAE lRfdj">,</span> key<span class="sc-cBoqAE lRfdj">:</span> Identifier <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">[</span><span class="sc-cBoqAE lRfdj">]</span> <span class="sc-cBoqAE lRfdj">=</span>
    ast<span class="sc-cBoqAE lRfdj">.</span>properties<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">map</span><span class="sc-cBoqAE lRfdj">(</span>prop <span class="sc-cBoqAE lRfdj">=&gt;</span> <span class="sc-cBoqAE lRfdj">{</span>
      <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isObjectProperty</span><span class="sc-cBoqAE lRfdj">(</span>prop<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">prop</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-ciSkZP bwSYJA">type</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
      <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span>prop<span class="sc-cBoqAE lRfdj">.</span>computed<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unimplemented computed</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
      <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isIdentifier</span><span class="sc-cBoqAE lRfdj">(</span>prop<span class="sc-cBoqAE lRfdj">.</span>key<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">prop</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-cBoqAE lRfdj">key</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-ciSkZP bwSYJA">type</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
      <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">isExpression</span><span class="sc-cBoqAE lRfdj">(</span>prop<span class="sc-cBoqAE lRfdj">.</span>value<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">bug</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">prop</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-cBoqAE lRfdj">value</span><span class="sc-cBoqAE lRfdj">.</span><span class="sc-ciSkZP bwSYJA">type</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
      <span class="sc-ciSkZP bwSYJA">return</span> <span class="sc-cBoqAE lRfdj">{</span>
        name<span class="sc-cBoqAE lRfdj">:</span> prop<span class="sc-cBoqAE lRfdj">.</span>key<span class="sc-cBoqAE lRfdj">.</span>name<span class="sc-cBoqAE lRfdj">,</span>
        expr<span class="sc-cBoqAE lRfdj">:</span> prop<span class="sc-cBoqAE lRfdj">.</span>value <span class="sc-ciSkZP bwSYJA">as</span> Expression<span class="sc-cBoqAE lRfdj">,</span>
        key<span class="sc-cBoqAE lRfdj">:</span> prop<span class="sc-cBoqAE lRfdj">.</span>key
      <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">;</span>
    <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>

  type<span class="sc-cBoqAE lRfdj">.</span>properties<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">forEach</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">{</span> name <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">=&gt;</span> <span class="sc-cBoqAE lRfdj">{</span>
    <span class="sc-ciSkZP bwSYJA">const</span> astProp <span class="sc-cBoqAE lRfdj">=</span> astProps<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">find</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">:</span> astName <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">=&gt;</span> astName <span class="sc-cBoqAE lRfdj">===</span> name<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
    <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">!</span>astProp<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">err</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">missing property </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">name</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">,</span> ast<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>

  astProps<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">forEach</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">,</span> expr<span class="sc-cBoqAE lRfdj">,</span> key <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span> <span class="sc-cBoqAE lRfdj">=&gt;</span> <span class="sc-cBoqAE lRfdj">{</span>
    <span class="sc-ciSkZP bwSYJA">const</span> propType <span class="sc-cBoqAE lRfdj">=</span> Type<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">propType</span><span class="sc-cBoqAE lRfdj">(</span>type<span class="sc-cBoqAE lRfdj">,</span> name<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
    <span class="sc-ciSkZP bwSYJA">if</span> <span class="sc-cBoqAE lRfdj">(</span>propType<span class="sc-cBoqAE lRfdj">)</span> <span class="sc-carFqZ hBWCUB">check</span><span class="sc-cBoqAE lRfdj">(</span>expr<span class="sc-cBoqAE lRfdj">,</span> propType<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
    <span class="sc-ciSkZP bwSYJA">else</span> <span class="sc-carFqZ hBWCUB">err</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-hiKfDv dRsyqq">extra property </span><span class="sc-cBoqAE lRfdj">${</span><span class="sc-cBoqAE lRfdj">name</span><span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">`</span><span class="sc-cBoqAE lRfdj">,</span> key<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>We flag an error if the object expression is missing a property present in the type. We also flag an error if it has an extra property that&#x27;s not present in the type. You might wonder why, since an extra property can&#x27;t do any harm; in </span><span><code>isSubtype</code></span><span> we allow extra properties. But in a literal object expression, an extra property might be a bug: we meant to set an optional property but mistyped it. So we follow actual TypeScript and flag it.</span></p><p><span>Now that we&#x27;ve defined </span><span><code>check</code></span><span>, we can add a case to </span><span><code>synth</code></span><span> to synthesize </span><span><code>as</code></span><span> expressions by checking the expression against the given type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ciSkZP bwSYJA">function</span> <span class="sc-carFqZ hBWCUB">synthTSAs</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-cBoqAE lRfdj">.</span>TSAsExpression<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">:</span> Type <span class="sc-cBoqAE lRfdj">{</span>
  <span class="sc-ciSkZP bwSYJA">const</span> type <span class="sc-cBoqAE lRfdj">=</span> Type<span class="sc-cBoqAE lRfdj">.</span><span class="sc-carFqZ hBWCUB">ofTSType</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">.</span><span class="sc-ciSkZP bwSYJA">type</span>Annotation<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-carFqZ hBWCUB">check</span><span class="sc-cBoqAE lRfdj">(</span>ast<span class="sc-cBoqAE lRfdj">.</span>expression<span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">)</span><span class="sc-cBoqAE lRfdj">;</span>
  <span class="sc-ciSkZP bwSYJA">return</span> type<span class="sc-cBoqAE lRfdj">;</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>So </span><span><code>as</code></span><span> gives us a way to tell the type checker to switch from synthesis to checking. This can be useful for debugging complicated type errors. It&#x27;s also a way to hide information about the type of an expression (but the language fragment so far is too simple to give a good example of this—more later).</span></p><h2 id="example"><span>Example</span></h2><p><span><strong>Update</strong></span><span>: if you don&#x27;t want to read through this (pretty tedious!) explanation, head down to </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1#try-it"><span>Try it!</span></a><span> and click &quot;check object error&quot; to see the call tree for this example.</span></p><p><span>Let&#x27;s walk through an example in detail:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">{</span>
  x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">7</span><span class="sc-cBoqAE lRfdj">,</span>
  y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> a<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;foo&quot;</span><span class="sc-cBoqAE lRfdj">,</span> b<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;bar&quot;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">.</span>b
<span class="sc-cBoqAE lRfdj">}</span> <span class="sc-ciSkZP bwSYJA">as</span> <span class="sc-cBoqAE lRfdj">{</span> x<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span><span class="sc-cBoqAE lRfdj">,</span> y<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jcwpoC kyvWZW">number</span> <span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>(See </span><a href="https://astexplorer.net/#/gist/4adfad800891ef430cb87db4c60dc5c2/5612db7c5bd283efbbe3a79e986b0176f5717a31" class="sc-gtsrHT kFWJEY"><span>here</span></a><span> for the full AST.) Type checking starts with a call to </span><span><code>synth</code></span><span>:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-carFqZ hBWCUB">synth</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">{</span>
  type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;TSAsExpression&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
  expression<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;ObjectExpression&quot;</span><span class="sc-cBoqAE lRfdj">,</span> properties<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">[</span> <span class="sc-cBoqAE lRfdj">...</span> <span class="sc-cBoqAE lRfdj">]</span> <span class="sc-cBoqAE lRfdj">}</span>
  <span class="sc-ciSkZP bwSYJA">type</span>Annotation<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">...</span>
<span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span></code></pre><p><span>The top-level node is </span><span><code>TSASExpression</code></span><span>, so we call </span><span><code>check</code></span><span> on the </span><span><code>expression</code></span><span> property with the given type (first translating the parsed </span><span><code>typeAnnotation</code></span><span> to our </span><span><code>Type</code></span><span> representation with </span><span><code>Type.ofTSType</code></span><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-carFqZ hBWCUB">check</span><span class="sc-cBoqAE lRfdj">(</span>
  <span class="sc-iTVJFM oxVOu">// check this expression</span>
  <span class="sc-cBoqAE lRfdj">{</span>
    type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;ObjectExpression&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
    properties<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">[</span>
      <span class="sc-cBoqAE lRfdj">{</span>
        type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;ObjectProperty&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
        key<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Identifier&quot;</span><span class="sc-cBoqAE lRfdj">,</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;x&quot;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
        value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;NumericLiteral&quot;</span><span class="sc-cBoqAE lRfdj">,</span> value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">7</span> <span class="sc-cBoqAE lRfdj">}</span>
      <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
      <span class="sc-cBoqAE lRfdj">{</span>
        type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;ObjectProperty&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
        key<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Identifier&quot;</span><span class="sc-cBoqAE lRfdj">,</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;y&quot;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
        value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;MemberExpression&quot;</span><span class="sc-cBoqAE lRfdj">,</span> <span class="sc-cBoqAE lRfdj">...</span> <span class="sc-cBoqAE lRfdj">}</span>
      <span class="sc-cBoqAE lRfdj">}</span>
    <span class="sc-cBoqAE lRfdj">]</span>
  <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
  <span class="sc-iTVJFM oxVOu">// against this type</span>
  <span class="sc-cBoqAE lRfdj">{</span>
    type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Object&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
    properties<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">[</span>
      <span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;x&quot;</span><span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Number&quot;</span> <span class="sc-cBoqAE lRfdj">}</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
      <span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;y&quot;</span><span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Number&quot;</span> <span class="sc-cBoqAE lRfdj">}</span> <span class="sc-cBoqAE lRfdj">}</span>
    <span class="sc-cBoqAE lRfdj">]</span>
  <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-cBoqAE lRfdj">)</span></code></pre><p><span>To check an </span><span><code>ObjectExpression</code></span><span> against an </span><span><code>Object</code></span><span> type, we check each property value expression against the corresponding property type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iTVJFM oxVOu">// property x</span>
<span class="sc-carFqZ hBWCUB">check</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;NumericLiteral&quot;</span><span class="sc-cBoqAE lRfdj">,</span> value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-jJMGnK laKGqb">7</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Number&quot;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span>

<span class="sc-iTVJFM oxVOu">// property y</span>
<span class="sc-carFqZ hBWCUB">check</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;MemberExpression&quot;</span><span class="sc-cBoqAE lRfdj">,</span> <span class="sc-cBoqAE lRfdj">...</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Number&quot;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span></code></pre><p><span>We can&#x27;t break down either of these further, so for each we </span><span><code>synth</code></span><span> a type for the expression, then compare it to the expected type with </span><span><code>isSubtype</code></span><span>. For </span><span><code>x</code></span><span> we </span><span><code>synth</code></span><span> type </span><span><code>Number</code></span><span> and check that it&#x27;s a subtype of </span><span><code>Number</code></span><span>. For </span><span><code>y</code></span><span> we first </span><span><code>synth</code></span><span> a type for </span><span><code>{ a: &quot;foo&quot;, b: &quot;bar&quot; }.b</code></span><span>:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-carFqZ hBWCUB">synth</span><span class="sc-cBoqAE lRfdj">(</span><span class="sc-cBoqAE lRfdj">{</span>
  type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;MemberExpression&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
  object<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span>
    type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;ObjectExpression&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
    properties<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">[</span>
      <span class="sc-cBoqAE lRfdj">{</span>
        type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;ObjectProperty&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
        key<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Identifier&quot;</span><span class="sc-cBoqAE lRfdj">,</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;a&quot;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
        value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;StringLiteral&quot;</span><span class="sc-cBoqAE lRfdj">,</span> value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;foo&quot;</span> <span class="sc-cBoqAE lRfdj">}</span>
      <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
      <span class="sc-cBoqAE lRfdj">{</span>
        type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;ObjectProperty&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
        key<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Identifier&quot;</span><span class="sc-cBoqAE lRfdj">,</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;b&quot;</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
        value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;StringLiteral&quot;</span><span class="sc-cBoqAE lRfdj">,</span> value<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;bar&quot;</span> <span class="sc-cBoqAE lRfdj">}</span>
      <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
    <span class="sc-cBoqAE lRfdj">]</span>
  <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
  property<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Identifier&quot;</span><span class="sc-cBoqAE lRfdj">,</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;b&quot;</span> <span class="sc-cBoqAE lRfdj">}</span>
<span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">)</span></code></pre><p><span>To </span><span><code>synth</code></span><span> a type for a </span><span><code>MemberExpression</code></span><span>, we first </span><span><code>synth</code></span><span> a type for the </span><span><code>object</code></span><span> property—to </span><span><code>synth</code></span><span> a type for an </span><span><code>ObjectExpression</code></span><span> we synth types for the property values and return this type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">{</span>
  type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;Object&quot;</span><span class="sc-cBoqAE lRfdj">,</span>
  properties<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">[</span>
    <span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;a&quot;</span><span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;String&quot;</span> <span class="sc-cBoqAE lRfdj">}</span> <span class="sc-cBoqAE lRfdj">}</span><span class="sc-cBoqAE lRfdj">,</span>
    <span class="sc-cBoqAE lRfdj">{</span> name<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;b&quot;</span><span class="sc-cBoqAE lRfdj">,</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-cBoqAE lRfdj">{</span> type<span class="sc-cBoqAE lRfdj">:</span> <span class="sc-hiKfDv dRsyqq">&quot;String&quot;</span> <span class="sc-cBoqAE lRfdj">}</span> <span class="sc-cBoqAE lRfdj">}</span>
  <span class="sc-cBoqAE lRfdj">]</span>
<span class="sc-cBoqAE lRfdj">}</span></code></pre><p><span>then project the </span><span><code>b</code></span><span> property to get type </span><span><code>String</code></span><span> for the whole </span><span><code>MemberExpression</code></span><span>. Finally we check that </span><span><code>String</code></span><span> is a subtype of </span><span><code>Number</code></span><span>, and flag an error because it is not.</span></p><h2 id="try-it"><span>Try it!</span></h2><p><span>You can try out the type checker below. In the top box, click on an example button or type an expression (remember that the supported expressions are primitive literals, object expressions, member expressions, and </span><span><code>as</code></span><span> ascriptions). In the bottom box you&#x27;ll see a trace of the type checker execution, ending in a synthesized type (or an error). The trace is a tree of function calls; click on a function call to expand the tree under that call, or mouse over a call to highlight the matching return value.</span></p><iframe src="https://jaked.org/reconstructing-typescript/part1/" width="700" height="500" style="border-style:none"></iframe><h2 id="the-plan"><span>The plan</span></h2><p><span>For the full code of part 1 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part1" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part1</span></a><span>.</span></p><p><span>Next time we&#x27;ll add functions and function calls to the language—we&#x27;ll add a </span><span><em>type environment</em></span><span> to track the types of variables, and see how subtyping for functions requires </span><span><em>contravariance</em></span><span>.</span></p><ul><li><p><span></span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>Part 0: intro and background</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>Part 1: bidirectional type checking</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>Part 2: functions and function calls</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-06-Reconstructing-TypeScript-part-3"><span>Part 3: operators and singleton types</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4"><span>Part 4: union types</span></a><span></span></p></li><li><p><span>Part 5: intersection types</span></p></li><li><p><span>Part 6: narrowing</span></p></li></ul><p><span>Thanks to Julia Evans, Tony Chow, and Will Lachance for helpful feedback on a draft of this post.</span></p><p><span>Please </span><a href="/blog/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p></div></body></html>