<html><head><title>How to run Electron on Linux on Docker on Mac</title><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 800px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style></head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; How to run Electron on Linux on Docker on Mac</span></p><h1><span>How to run Electron on Linux on Docker on Mac</span></h1><h3><span><em>2021-02-18</em></span></h3><p><span>My co-Recurser Hazem tried running </span><a href="https://github.com/jaked/programmable-matter" class="sc-bdfBwQ eWIPXm"><span>Programmable Matter</span></a><span> on Linux, and it didn&#x27;t work very well (I had previously run it only on my Mac). So the past few days I have been getting it running on Linux on </span><a href="https://www.docker.com/" class="sc-bdfBwQ eWIPXm"><span>Docker</span></a><span> in order to fix it. I had not used Docker before so this was an adventure! I learned a lot.</span></p><p><span>Docker lets you run virtual computers (I&#x27;ll call them </span><span><em>guests</em></span><span>, although this is not </span><a href="https://docs.docker.com/glossary/" class="sc-bdfBwQ eWIPXm"><span>official Docker terminology</span></a><span>) inside your computer (the </span><span><em>host</em></span><span>), and guests can run different operating systems from the one the host runs. You can use it to develop and test software on other OSes (or different versions of your host OS); or to bundle up a bunch of software packages so users can install and uninstall them all together; or to run programs in a restricted environment so they can&#x27;t damage the host.</span></p><p><span>I have a vague idea how this all works but I still find it extremely magical! Docker seems to be very well put together and everything worked really smoothly for me. Nonetheless I ran into a lot of puzzling stuff and did a whole lot of Googling to get it working. Mostly why this was complicated is that Programmable Matter is based on </span><a href="https://www.electronjs.org/" class="sc-bdfBwQ eWIPXm"><span>Electron</span></a><span>, which makes some unusual demands of the operating system it runs on.</span></p><p><span>Here is what I needed to do at a high level:</span></p><ul><li><p><span>learn about Docker. I went through the </span><a href="https://docs.docker.com/get-started/" class="sc-bdfBwQ eWIPXm"><span>getting started</span></a><span> tutorial, it was great.</span></p></li><li><p><span>build an </span><span><em>image</em></span><span> containing the base Linux installation and any extra libraries needed to run my app. (To run a guest computer you load an image into a </span><span><em>container</em></span><span>.)</span></p></li><li><p><span>set things up so that the app running on the guest can display a window on my Mac.</span></p></li><li><p><span>figure out some Docker security stuff.</span></p></li><li><p><span>run the app!</span></p></li></ul><h2><span>Building a Docker image</span></h2><p><span>To build an image, you write a </span><span><code>Dockerfile</code></span><span>, which is a script of actions that modify the guest computer&#x27;s storage; when the script finishes, the storage is snapshotted into a file on the host. Here&#x27;s the one I wrote (with explanations interpolated):</span></p><blockquote><pre><span>FROM node:14</span></pre></blockquote><p><span>This line names a base image to start with. Docker has a </span><a href="https://hub.docker.com/" class="sc-bdfBwQ eWIPXm"><span>repository of images</span></a><span> of various base operating systems and add-ons. This one is a Debian image with Node.js version 14 installed (see </span><a href="https://hub.docker.com/_/node" class="sc-bdfBwQ eWIPXm"><span>https://hub.docker.com/_/node</span></a><span>). There are a bunch of choices here: for example, the sample app in the tutorial uses an image with Node on top of Alpine Linux, which is a lot smaller than Debian. (I picked </span><span><code>node:14</code></span><span> because the smaller ones sounded from the docs like they might not work for me, but I should go back and try it.)</span></p><p><span>From this point on in the </span><span><code>Dockerfile</code></span><span> you can run ordinary shell commands in the context of the guest:</span></p><blockquote><pre><span># stuff needed to get Electron to run
RUN apt-get update &amp;&amp; apt-get install \
    git libx11-xcb1 libxcb-dri3-0 libxtst6 libnss3 libatk-bridge2.0-0 libgtk-3-0 libxss1 libasound2 \
    -yq --no-install-suggests --no-install-recommends \
    &amp;&amp; apt-get clean &amp;&amp; rm -rf /var/lib/apt/lists/*</span></pre></blockquote><p><span>The base images are typically pretty stripped down compared to a normal OS installation. In particular, </span><span><code>node:14</code></span><span> is missing a bunch of libraries that Electron depends on for rendering the display. I found these by trying to start the app, getting an error like</span></p><blockquote><p><span> </span><div style="background-color:#ffc0c0;padding:10px;border-radius:10px"><code>libX11-xcb.so.1: cannot open shared object file: No such file or directory</code></div><span></span></p></blockquote><p><span>searching for the missing library at </span><a href="https://www.debian.org/distrib/packages#search_contents" class="sc-bdfBwQ eWIPXm"><span>https://www.debian.org/distrib/packages#search_contents</span></a><span>, and adding the matching package. (</span><span><code>Git</code></span><span> is needed by </span><a href="https://www.electronforge.io/" class="sc-bdfBwQ eWIPXm"><span><code>electron-forge</code></span></a><span>, which I&#x27;m using to run my app.)</span></p><blockquote><pre><span># Electron doesn&#x27;t like to run as root
RUN useradd -d /programmable-matter programmable-matter
USER programmable-matter</span></pre></blockquote><p><span>If you try to run Electron as root you get</span></p><blockquote><p><span></span><div style="background-color:#ffc0c0;padding:10px;border-radius:10px"><code>Running as root without --no-sandbox is not supported.</code></div><span></span></p></blockquote><p><span>so we need to add a user (more about </span><span><code>--no-sandbox</code></span><span> below). The </span><span><code>USER</code></span><span> command changes to the given user for subsequent commands.</span></p><blockquote><pre><span>WORKDIR /programmable-matter
COPY . .
RUN npm install
RUN npx electron-rebuild</span></pre></blockquote><p><span>The </span><span><code>WORKDIR</code></span><span> command sets the working directory for subsequent commands, then </span><span><code>COPY</code></span><span> copies a file tree containing the app code from the host filesystem to the guest filesystem. This includes </span><span><code>package.json</code></span><span>, so we can run </span><span><code>npm install</code></span><span>. We also run </span><span><code>electron-rebuild</code></span><span> which builds some native code modules to match the installed Electron version. (</span><span><code>Electron-rebuild</code></span><span> is run by </span><span><code>electron-forge</code></span><span> on launch if we don&#x27;t do it here, but that causes a Docker security issue, see below; and also makes startup slower, so I moved it here.)</span></p><blockquote><pre><span># Electron needs root for sandboxing
# see https://github.com/electron/electron/issues/17972
USER root
RUN chown root /programmable-matter/node_modules/electron/dist/chrome-sandbox
RUN chmod 4755 /programmable-matter/node_modules/electron/dist/chrome-sandbox</span></pre></blockquote><p><span>Without this the app errors out with</span></p><blockquote><p><span></span><div style="background-color:#ffc0c0;padding:10px;border-radius:10px"><code>The SUID sandbox helper binary was found, but is not configured correctly.</code></div><span></span></p></blockquote><p><span>As far as I understand things: Electron is based on Chromium, which has a fancy </span><a href="http://www.chromium.org/developers/design-documents/multi-process-architecture" class="sc-bdfBwQ eWIPXm"><span>multi-process architecture</span></a><span> in which some processes are run with restricted permissions (&quot;sandboxed&quot;). Sandboxing can be done with a Linux kernel facility called &quot;user namespaces&quot;, but this facility is not enabled on some Linux distributions, so there is a workaround using a setuid helper program. However </span><span><code>npm install</code></span><span> can&#x27;t set the setuid bit without root permission, and the Electron package </span><a href="https://github.com/electron/electron/issues/17972" class="sc-bdfBwQ eWIPXm"><span>chooses not to ask for it</span></a><span>, so we need to do it explicitly. (I&#x27;m not sure whether user namespaces can be enabled on the Debian base image I started with, but I think it may use an older kernel version and this is a fairly recent feature.) </span></p><blockquote><pre><span>USER programmable-matter
CMD npm run start</span></pre></blockquote><p><span>Now we are ready to build the image with</span></p><blockquote><p><span><code>docker build -t programmable-matter .</code></span></p></blockquote><p><span>and run it with</span></p><blockquote><p><span><code>docker run programmable-matter</code></span></p></blockquote><p><span>But we get an error:</span></p><blockquote><p><span></span><div style="background-color:#ffc0c0;padding:10px;border-radius:10px"><code>Failed to move to new namespace: PID namespaces supported, Network namespace supported, but failed: errno = Operation not permitted.</code></div><span> </span></p></blockquote><h2><span>XQuartz and DISPLAY</span></h2><p><span>I like long specific error messages like this, they are easy to Google. I found </span><a href="https://stackoverflow.com/a/53975412/205191" class="sc-bdfBwQ eWIPXm"><span>this</span></a><span>, which suggests either passing the </span><span><code>--no-sandbox</code></span><span> argument or setting up a custom </span><span><code>seccomp</code></span><span> configuration. I was feeling tired and not very interested in setting up a custom configuration for something I had never heard of, so I tried </span><span><code>--no-sandbox</code></span><span>, which got me past the namespace error and on to a new one:</span></p><blockquote><p><span></span><div style="background-color:#ffc0c0;padding:10px;border-radius:10px"><code>The futex facility returned an unexpected error code.</code></div><span></span></p></blockquote><p><span>Not very helpful—I was expecting this to be hard to Google, but </span><a href="https://github.com/electron/electron/issues/24211" class="sc-bdfBwQ eWIPXm"><span>this Electron issue</span></a><span> was the second hit. Turns out I needed to set the </span><span><code>DISPLAY</code></span><span> environment variable so Electron knows where to render its windows, using </span><a href="https://en.wikipedia.org/wiki/X_Window_System" class="sc-bdfBwQ eWIPXm"><span>X</span></a><span>, the standard windowing system on Linux.</span></p><p><span>My Mac is running an implementation of the X display server, </span><a href="https://www.xquartz.org/" class="sc-bdfBwQ eWIPXm"><span>XQuartz</span></a><span>, which can receive connections from X programs and render their windows. When you&#x27;re running an X client and server on the same computer they normally connect over a Unix socket for performance (and also for security). I tried to mount the X Unix socket from the host to the guest, following </span><a href="https://blog.jessfraz.com/post/docker-containers-on-the-desktop/" class="sc-bdfBwQ eWIPXm"><span>this post</span></a><span>, but I got several variations of</span></p><blockquote><p><span></span><div style="background-color:#ffc0c0;padding:10px;border-radius:10px"><code>docker: Error response from daemon: invalid mode: /tmp/.X11-unix</code></div><span></span></p></blockquote><p><span>It turns out that mounting arbitrary Unix sockets into a container is </span><a href="https://github.com/docker/for-mac/issues/483" class="sc-bdfBwQ eWIPXm"><span>not supported on Docker for Mac</span></a><span>. Instead (following these </span><a href="https://gist.github.com/paul-krohn/e45f96181b1cf5e536325d1bdee6c949" class="sc-bdfBwQ eWIPXm"><span>instructions</span></a><span>) I set an XQuartz preference to allow connections from network clients, ran </span><span><code>xhost +localhost</code></span><span> to allow connections from </span><span><code>localhost</code></span><span>, and ran </span><span><code>docker</code></span><span> like so:</span></p><blockquote><p><span><code>docker run -e DISPLAY=host.docker.internal:0 programmable-matter</code></span></p></blockquote><p><span>It works! The guest OS can reach network ports on the host at </span><span><code>host.docker.internal</code></span><span>, and </span><span><code>-e DISPLAY=</code></span><span> passes the environment variable to the </span><span><code>CMD</code></span><span> in the </span><span><code>Dockerfile</code></span><span>. I also needed to run </span><span><code>xhost +localhost</code></span><span> so XQuartz will accept the connection. This is not secure for general use (XQuartz trusts the IP address of the incoming connection), but it seems OK for local use.</span></p><h2><span>Docker and seccomp</span></h2><p><span>After a rest on the fainting couch, I decided to try to set up </span><span><code>seccomp</code></span><span> in order to get rid of the </span><span><code>--no-sandbox</code></span><span> argument. I am not sure how much practical value this has, since the whole app is running in a container, but maybe it prevents dangerous access between app processes in the container. In any case </span><span><code>--no-sandbox</code></span><span> seems like an escape-hatch flags that should be avoided. So following </span><a href="https://stackoverflow.com/a/53975412/205191" class="sc-bdfBwQ eWIPXm"><span>these instructions</span></a><span> I tried running the container like so:</span></p><blockquote><p><span><code>docker run -e DISPLAY=host.docker.internal:0 --security-opt seccomp=chrome.json programmable-matter</code></span></p></blockquote><p><span>where </span><a href="https://github.com/jessfraz/dotfiles/blob/master/etc/docker/seccomp/chrome.json" class="sc-bdfBwQ eWIPXm"><span><code>chrome.json</code></span></a><span> is from Jessie Frazelle&#x27;s </span><a href="https://github.com/jessfraz/dotfiles/" class="sc-bdfBwQ eWIPXm"><span>dotfiles</span></a><span> (see also </span><a href="https://blog.jessfraz.com/post/how-to-use-new-docker-seccomp-profiles/" class="sc-bdfBwQ eWIPXm"><span>how it was made</span></a><span>). As far as I understand things, </span><a href="https://docs.docker.com/engine/security/seccomp/" class="sc-bdfBwQ eWIPXm"><span><code>seccomp</code></span></a><span> configures a list of Linux system calls that programs running on the guest are allowed to call, and </span><span><code>chrome.json</code></span><span> includes the namespace calls Chromium uses for sandboxing. But:</span></p><blockquote><p><span></span><div style="background-color:#ffc0c0;padding:10px;border-radius:10px"><code>EPERM: operation not permitted, copyfile &#x27;/programmable-matter/node_modules/nsfw/build/Release/nsfw.node&#x27; -&gt; &#x27;/programmable-matter/node_modules/nsfw/bin/linux-x64-80/nsfw.node&#x27;</code></div><span></span></p></blockquote><p><span>The file in question is part of a native library I&#x27;m using, </span><a href="https://github.com/Axosoft/nsfw" class="sc-bdfBwQ eWIPXm"><span>NSFW</span></a><span>, and the error comes up while </span><span><code>electron-forge</code></span><span> is running </span><span><code>electron-rebuild</code></span><span>. I thought that </span><span><code>copyfile</code></span><span> was the name of a system call so I tried adding it to </span><span><code>chrome.json</code></span><span>, but that didn&#x27;t work. I did find </span><a href="https://man7.org/linux/man-pages/man2/copy_file_range.2.html" class="sc-bdfBwQ eWIPXm"><span><code>copy_file_range</code></span></a><span>, however, and adding that one worked! I spent some time digging to find where the string </span><span><code>copyfile</code></span><span> comes from (</span><span><code>electron-forge</code></span><span> calls </span><span><code>electron-rebuild</code></span><span> calls </span><span><code>node-gyp</code></span><span> which I think generates and runs a </span><span><code>Makefile</code></span><span>) but gave up.</span></p><p><span>Finally I realized that </span><span><code>electron-rebuild</code></span><span> can be run at image build time instead of container run time; now the original </span><span><code>chrome.json</code></span><span> works. So I guess there is no </span><span><code>seccomp</code></span><span> restriction at image build time.</span></p><h2><span>The end</span></h2><p><span>Truly, friends, we live in a time of wonders! Please </span><a href="/blog/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, corrections.</span></p></div></body></html>