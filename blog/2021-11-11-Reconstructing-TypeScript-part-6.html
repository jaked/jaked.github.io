<html><head><title>How to implement a TypeScript-style type checker (Reconstructing TypeScript), part 6: narrowing</title><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@jakedonham"/><meta name="twitter:creator" content="@jakedonham"/><meta name="twitter:title" content="How to implement a TypeScript-style type checker (Reconstructing TypeScript), part 6: narrowing"/><meta name="twitter:description" content="How to implement a TypeScript-style type checker (Reconstructing TypeScript), part 6: narrowing"/><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/2021-11-11-Reconstructing-TypeScript-part-6.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.bOWasK{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;overflow:auto;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"bOWasK,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.dvHFX{color:#000000;}/*!sc*/
data-styled.g34[id="sc-ezzafa"]{content:"dvHFX,"}/*!sc*/
.fDDjHD{color:#aa1111;}/*!sc*/
data-styled.g35[id="sc-bYwzuL"]{content:"fDDjHD,"}/*!sc*/
.iehvjW{color:#770088;}/*!sc*/
data-styled.g36[id="sc-kLojOw"]{content:"iehvjW,"}/*!sc*/
.hbusih{color:#b58900;}/*!sc*/
data-styled.g37[id="sc-iklJeh"]{content:"hbusih,"}/*!sc*/
.dRsyqq{color:#116644;}/*!sc*/
data-styled.g39[id="sc-hiKfDv"]{content:"dRsyqq,"}/*!sc*/
.lRfdj{color:#221199;}/*!sc*/
data-styled.g41[id="sc-cBoqAE"]{content:"lRfdj,"}/*!sc*/
.glZmJR{color:#009900;}/*!sc*/
data-styled.g46[id="sc-iBzEeX"]{content:"glZmJR,"}/*!sc*/
.cFSLxQ{color:#268bd2;}/*!sc*/
data-styled.g47[id="sc-efHYUO"]{content:"cFSLxQ,"}/*!sc*/
.lmGFyU{color:#6f42c1;}/*!sc*/
data-styled.g48[id="sc-cTJkRt"]{content:"lmGFyU,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript, part 6</span></p><h1 id="reconstructing-typescript-part-6-narrowing"><span>Reconstructing TypeScript, part 6: narrowing</span></h1><h3 id="2021-11-11"><span><em>2021-11-11</em></span></h3><p><span>This post is part of a series about implementing type checking for a TypeScript-like language. See </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> for background, and parts </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>1</span></a><span>, </span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>2</span></a><span>, </span><a href="/blog/2021-10-06-Reconstructing-TypeScript-part-3"><span>3</span></a><span>, </span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4"><span>4</span></a><span>, </span><a href="/blog/2021-10-28-Reconstructing-TypeScript-part-5"><span>5</span></a><span> for the implementation so far.</span></p><p><span>In this part we&#x27;ll add conditional expressions like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iBzEeX glZmJR">// x: { type: &#x27;a&#x27;, a: boolean } | { type: &#x27;b&#x27;, b: string }</span>
x<span class="sc-ezzafa dvHFX">.</span>type <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span> <span class="sc-ezzafa dvHFX">?</span> x<span class="sc-ezzafa dvHFX">.</span>a <span class="sc-ezzafa dvHFX">:</span> x<span class="sc-ezzafa dvHFX">.</span>b</code></pre><p><span>and implement </span><span><em>narrowing</em></span><span>: the type checker will use information from the test to deduce a more-specific type for </span><span><code>x</code></span><span> in the true and false branches of the conditional expression, so it can check that the property accesses are safe.</span></p><h2 id="whats-narrowing"><span>What&#x27;s narrowing?</span></h2><p><span>In a conditional expression like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iBzEeX glZmJR">// x: { type: &#x27;a&#x27;, a: boolean } | { type: &#x27;b&#x27;, b: string }</span>
x<span class="sc-ezzafa dvHFX">.</span>type <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span> <span class="sc-ezzafa dvHFX">?</span> x<span class="sc-ezzafa dvHFX">.</span>a <span class="sc-ezzafa dvHFX">:</span> x<span class="sc-ezzafa dvHFX">.</span>b</code></pre><p><span>the </span><span><em>true branch</em></span><span> </span><span><code>x.a</code></span><span> is executed only when the </span><span><em>test</em></span><span> </span><span><code>x.type === &#x27;a&#x27;</code></span><span> is true, and the </span><span><em>false branch</em></span><span> </span><span><code>x.b</code></span><span> is executed only when the test is false. So while type checking the true branch we can assume that the test is true, then use information deduced from that assumption to give more-specific (</span><span><em>narrower</em></span><span>) types to variables in the environment; and similarly for the false branch.</span></p><p><span>While type checking the true branch </span><span><code>x.a</code></span><span> we assume that </span><span><code>x.type === &#x27;a&#x27;</code></span><span> is true; from that assumption and the current environment we deduce</span></p><ul><li><p><span><code>x.type</code></span><span> satisfies the type </span><span><code>&#x27;a&#x27;</code></span></p></li><li><p><span><code>x</code></span><span> satisfies the type </span><span><code>{ type: &#x27;a&#x27; }</code></span></p></li><li><p><span>we know that </span><span><code>x</code></span><span> satisfies </span><span><code>{ type: &#x27;a&#x27;, a: boolean } | { type: &#x27;b&#x27;, b: string }</code></span><span> from the current environment </span></p></li><li><p><span>but </span><span><code>{ type: &#x27;a&#x27; }</code></span><span> and </span><span><code>{ type: &#x27;b&#x27; }</code></span><span> conflict, so </span><span><code>x</code></span><span> cannot satisfy the second arm of the union</span></p></li><li><p><span>so </span><span><code>x</code></span><span> must satisfy </span><span><code>{ type: &#x27;a&#x27;, a: boolean }</code></span></p></li></ul><p><span>Using this narrower type for </span><span><code>x</code></span><span> we see that </span><span><code>x.a</code></span><span> is safe.</span></p><h2 id="narrowing-as-logical-implication"><span>Narrowing as logical implication</span></h2><p><span>It&#x27;s useful to think of the type environment as a logical statement that asserts facts about the types of variables. For example, this environment</span></p><pre class="sc-bdnxRM bOWasK"><code>x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span><span class="sc-ezzafa dvHFX">,</span> a<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">boolean</span> <span class="sc-ezzafa dvHFX">}</span> <span class="sc-ezzafa dvHFX">|</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;b&#x27;</span><span class="sc-ezzafa dvHFX">,</span> b<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">string</span> <span class="sc-ezzafa dvHFX">}</span>
y<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">string</span>
z<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">number</span></code></pre><p><span>corresponds to this logical statement</span></p><pre class="sc-bdnxRM bOWasK"><code>x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span><span class="sc-ezzafa dvHFX">,</span> a<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">boolean</span> <span class="sc-ezzafa dvHFX">}</span> <span class="sc-ezzafa dvHFX">|</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;b&#x27;</span><span class="sc-ezzafa dvHFX">,</span> b<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">string</span> <span class="sc-ezzafa dvHFX">}</span> <span class="sc-cBoqAE lRfdj">AND</span>
y<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">string</span> <span class="sc-cBoqAE lRfdj">AND</span>
z<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">number</span></code></pre><p><span>As we saw in </span><a href="/blog/2021-10-28-Reconstructing-TypeScript-part-5#whats-an-intersection-type"><span>part 5</span></a><span>, we can also think of intersection and union types as logical AND and OR; so all of these logical statements mean the same thing</span></p><pre class="sc-bdnxRM bOWasK"><code>x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span> <span class="sc-ezzafa dvHFX">|</span> <span class="sc-bYwzuL fDDjHD">&#x27;b&#x27;</span> <span class="sc-cBoqAE lRfdj">AND</span> x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span>
x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span> <span class="sc-ezzafa dvHFX">|</span> <span class="sc-bYwzuL fDDjHD">&#x27;b&#x27;</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">&amp;</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span>
x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span></code></pre><p><span>We can read a conditional test as a logical statement; then to assume it true (when we type check the true branch of a conditional), we conjoin it to the environment</span></p><pre class="sc-bdnxRM bOWasK"><code>x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span><span class="sc-ezzafa dvHFX">,</span> a<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">boolean</span> <span class="sc-ezzafa dvHFX">}</span> <span class="sc-ezzafa dvHFX">|</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;b&#x27;</span><span class="sc-ezzafa dvHFX">,</span> b<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">string</span> <span class="sc-ezzafa dvHFX">}</span> <span class="sc-cBoqAE lRfdj">AND</span>
y<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">string</span> <span class="sc-cBoqAE lRfdj">AND</span>
z<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">number</span> <span class="sc-cBoqAE lRfdj">AND</span>
x<span class="sc-ezzafa dvHFX">.</span>type <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span></code></pre><p><span>then deduce that this statement implies</span></p><pre class="sc-bdnxRM bOWasK"><code>x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span><span class="sc-ezzafa dvHFX">,</span> a<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">boolean</span> <span class="sc-ezzafa dvHFX">}</span></code></pre><p><span>However, type environments hold bindings of variables to types, so we can&#x27;t represent the statement above directly; but we can work around the limitations:</span></p><p><span>We can&#x27;t directly represent a value equality, but we can represent an equivalent singleton type: </span></p><pre class="sc-bdnxRM bOWasK"><code>x<span class="sc-ezzafa dvHFX">.</span>type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span> <span class="sc-iBzEeX glZmJR">// represents x.type === &#x27;a&#x27;</span></code></pre><p><span>We can&#x27;t directly represent the type of a member expression, but we can represent an equivalent variable binding:</span></p><pre class="sc-bdnxRM bOWasK"><code>x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span> <span class="sc-ezzafa dvHFX">}</span> <span class="sc-iBzEeX glZmJR">// represents x.type: &#x27;a&#x27;</span></code></pre><p><span>We can&#x27;t directly represent a conjunction of statements about the same variable (since type environments hold only a single type for each variable), but we can represent an equivalent intersection type:</span></p><pre class="sc-bdnxRM bOWasK"><code>x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span><span class="sc-ezzafa dvHFX">,</span> a<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">boolean</span> <span class="sc-ezzafa dvHFX">}</span> <span class="sc-ezzafa dvHFX">|</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;b&#x27;</span><span class="sc-ezzafa dvHFX">,</span> b<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">string</span> <span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">&amp;</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span> <span class="sc-ezzafa dvHFX">}</span>
<span class="sc-iBzEeX glZmJR">// represents</span>
<span class="sc-iBzEeX glZmJR">// x: { type: &#x27;a&#x27;, a: boolean } | { type: &#x27;b&#x27;, b: string } AND</span>
<span class="sc-iBzEeX glZmJR">// x: { type: &#x27;a&#x27; }</span></code></pre><p><span>In the code we&#x27;ll stick with the existing type environment representation; but keep in mind the view of the environment as a logical statement.</span></p><h2 id="representing-negation"><span>Representing negation</span></h2><p><span>To type check the false branch of the example, we need to represent the logical statement</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">NOT</span> <span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">.</span>type <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span><span class="sc-ezzafa dvHFX">)</span></code></pre><p><span>There&#x27;s no way to shoehorn this into the existing implementation—we need another kind of type: </span><span><em>negation</em></span><span> types, written </span><span><code>!t</code></span><span>. As usual we extend the </span><span><code>Type</code></span><span> union (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/type/types.ts#L66" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">type</span> <span class="sc-ezzafa dvHFX">Type</span> <span class="sc-ezzafa dvHFX">=</span> <span class="sc-ezzafa dvHFX">...</span> <span class="sc-ezzafa dvHFX">|</span> Not<span class="sc-ezzafa dvHFX">;</span>
  

<span class="sc-kLojOw iehvjW">type</span> <span class="sc-ezzafa dvHFX">Not</span> <span class="sc-ezzafa dvHFX">=</span> <span class="sc-ezzafa dvHFX">{</span>
  type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;Not&#x27;</span><span class="sc-ezzafa dvHFX">;</span>
  base<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">;</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><p><span>add a constructor (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/type/constructors.ts#L31" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>) and validator (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/type/validators.ts#L47" class="sc-gtsrHT kFWJEY"><span>validators.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">not</span><span class="sc-ezzafa dvHFX">(</span>base<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> Not <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">return</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;Not&#x27;</span><span class="sc-ezzafa dvHFX">,</span> base <span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">;</span>
<span class="sc-ezzafa dvHFX">}</span>

<span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">isNot</span><span class="sc-ezzafa dvHFX">(</span>type<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-kLojOw iehvjW">type</span> <span class="sc-kLojOw iehvjW">is</span> Not <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">return</span> type<span class="sc-ezzafa dvHFX">.</span>type <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;Not&#x27;</span><span class="sc-ezzafa dvHFX">;</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><p><span>and a case for </span><span><code>Not</code></span><span> in </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/type/toString.ts#L51" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span>. Actual TypeScript doesn&#x27;t support negation types, and the Babel parser doesn&#x27;t parse any syntax for them, so we don&#x27;t add a case to </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/type/ofTSType.ts" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span>.</span></p><p><span>Now, for the false branch </span><span><code>x.b</code></span><span>, we assume </span><span><code>x.type === &#x27;a&#x27;</code></span><span> is false and deduce</span></p><ul><li><p><span><code>x.type</code></span><span> satisfies </span><span><code>!&#x27;a&#x27;</code></span></p></li><li><p><span><code>x</code></span><span> satisfies </span><span><code>{ type: !&#x27;a&#x27; }</code></span></p></li><li><p><span>x satisfies </span><span><code>{ type: &#x27;a&#x27;, a: boolean } | { type: &#x27;b&#x27;, b: string }</code></span></p></li><li><p><span>but </span><span><code>{ type: !&#x27;a&#x27; }</code></span><span> and </span><span><code>{ type: &#x27;a&#x27; }</code></span><span> conflict, so </span><span><code>x</code></span><span> cannot satisfy the first arm of the union</span></p></li><li><p><span>so </span><span><code>x</code></span><span> must satisfy </span><span><code>{ type: &#x27;b&#x27;, b: string }</code></span></p></li></ul><p><span>so </span><span><code>x.b</code></span><span> is safe.</span></p><p><span>Negation types could be useful in ordinary programming, but we won&#x27;t support them in the whole type checker; to keep things simple we&#x27;ll use them only in narrowing. </span></p><h2 id="implementing-narrowing"><span>Implementing narrowing</span></h2><p><span>Narrowing involves several related functions—it&#x27;s a lot of code!</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>Expression<span class="sc-ezzafa dvHFX">,</span> assume<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">boolean</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> Env</code></pre><p><span>When we type check a branch of a conditional expression, we call </span><span><code>narrow</code></span><span> with the current environment, the test expression, and a flag saying whether the test is assumed to be true or false. It returns an updated environment incorporating the information deduced from the test and assumption.</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>Expression<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> Env</code></pre><p><span>When we deduce that a subexpression of the test must satisfy a type, we call </span><span><code>narrowPath</code></span><span> to incorporate it into the environment. Here a </span><span><em>path</em></span><span> is an expression that references a variable, like </span><span><code>x.type</code></span><span>; as above, we need to reason backwards until we reach a variable so we can update the environment.</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrowType</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">,</span> y<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> Type</code></pre><p><span>When we reach a variable, we call </span><span><code>narrowType</code></span><span> with the current type of the variable from the environment and the deduced type, then update the variable&#x27;s type with the result. This corresponds to a logical AND, so </span><span><code>narrowType</code></span><span> is a kind of intersection—more on this below.</span></p><h3 id="narrow"><span>narrow</span></h3><p><span>Here&#x27;s the top-level </span><span><code>narrow</code></span><span> function (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/narrow.ts#L261" class="sc-gtsrHT kFWJEY"><span>narrow.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>Expression<span class="sc-ezzafa dvHFX">,</span> assume<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">boolean</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> Env <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">switch</span> <span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>type<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;UnaryExpression&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowUnary</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">,</span> assume<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;LogicalExpression&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowLogical</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">,</span> assume<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;BinaryExpression&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowBinary</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">,</span> assume<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">default</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">,</span> assume <span class="sc-ezzafa dvHFX">?</span> Type<span class="sc-ezzafa dvHFX">.</span>truthy <span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">.</span>falsy<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">}</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><p><span>For unary, logical, and binary expressions we dispatch to AST-specific functions to break them down. Otherwise the expression is a path, so we call </span><span><code>narrowPath</code></span><span> to narrow the path to a type that satisfies </span><span><code>truthy</code></span><span> or </span><span><code>falsy</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/type/truthiness.ts#L24" class="sc-gtsrHT kFWJEY"><span>truthiness.ts</span></a><span>).</span></p><h4 id="narrowunary"><span>narrowUnary</span></h4><p><span>Assuming an expression is true is the same as assuming its negation is false (and vice versa); so for </span><span><code>!</code></span><span> we narrow the argument with the assumption flipped. Since </span><span><code>typeof</code></span><span> always returns a truthy string, we deduce nothing (but see the </span><span><code>narrowPath</code></span><span> case for </span><span><code>typeof</code></span><span> below, when it appears inside an equality test). Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/narrow.ts#L178" class="sc-gtsrHT kFWJEY"><span>narrow.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrowUnary</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>UnaryExpression<span class="sc-ezzafa dvHFX">,</span> assume<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">boolean</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">switch</span> <span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>operator<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;!&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>argument<span class="sc-ezzafa dvHFX">,</span> <span class="sc-ezzafa dvHFX">!</span>assume<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;typeof&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">return</span> env<span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">default</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-iklJeh hbusih">bug</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-bYwzuL fDDjHD">unexpected </span><span class="sc-ezzafa dvHFX">${</span><span class="sc-ezzafa dvHFX">ast</span><span class="sc-ezzafa dvHFX">.</span><span class="sc-ezzafa dvHFX">operator</span><span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">}</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><h4 id="narrowlogical"><span>narrowLogical</span></h4><p><span>When an </span><span><code>&amp;&amp;</code></span><span>-expression is assumed true, both sides must be true, so we narrow assuming both sides are true. When an </span><span><code>&amp;&amp;</code></span><span>-expression is assumed false, one side must be false: if we know the left side is true then we narrow assuming the right side is false; if we know the right side is true then we narrow assuming the left side is false; otherwise we deduce nothing. (The case for </span><span><code>||</code></span><span>-expressions follows similar reasoning.) Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/narrow.ts#L197" class="sc-gtsrHT kFWJEY"><span>narrow.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrowLogical</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>LogicalExpression<span class="sc-ezzafa dvHFX">,</span> assume<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">boolean</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">switch</span> <span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>operator<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;&amp;&amp;&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>assume<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
        env <span class="sc-ezzafa dvHFX">=</span> <span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">true</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
        <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>right<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">true</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
      <span class="sc-ezzafa dvHFX">}</span> <span class="sc-kLojOw iehvjW">else</span> <span class="sc-ezzafa dvHFX">{</span>
        <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isTruthy</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
          <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>right<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">false</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
        <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isTruthy</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>right<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
          <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">false</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
        <span class="sc-kLojOw iehvjW">else</span>
          <span class="sc-kLojOw iehvjW">return</span> env<span class="sc-ezzafa dvHFX">;</span>
      <span class="sc-ezzafa dvHFX">}</span>

    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;||&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">!</span>assume<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
        env <span class="sc-ezzafa dvHFX">=</span> <span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">false</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
        <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>right<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">false</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
      <span class="sc-ezzafa dvHFX">}</span> <span class="sc-kLojOw iehvjW">else</span> <span class="sc-ezzafa dvHFX">{</span>
        <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isFalsy</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
          <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>right<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">true</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
        <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isFalsy</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>right<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
          <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">true</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
        <span class="sc-kLojOw iehvjW">else</span>
          <span class="sc-kLojOw iehvjW">return</span> env<span class="sc-ezzafa dvHFX">;</span>
      <span class="sc-ezzafa dvHFX">}</span>

    <span class="sc-kLojOw iehvjW">default</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-iklJeh hbusih">bug</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-bYwzuL fDDjHD">unexpected AST </span><span class="sc-ezzafa dvHFX">${</span><span class="sc-ezzafa dvHFX">ast</span><span class="sc-ezzafa dvHFX">.</span><span class="sc-ezzafa dvHFX">operator</span><span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">}</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><p><span>When we don&#x27;t know that one side is true, we still know that one side must be false! We could express this by the logical statement</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">(</span><span class="sc-cBoqAE lRfdj">NOT</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">)</span> <span class="sc-cBoqAE lRfdj">OR</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-cBoqAE lRfdj">NOT</span> ast<span class="sc-ezzafa dvHFX">.</span>right<span class="sc-ezzafa dvHFX">)</span></code></pre><p><span>but we have no way to represent this statement using type environments. We have union and negation types, but they describe individual variables; </span><span><code>ast.left</code></span><span> and </span><span><code>ast.right</code></span><span> could mention different variables or be arbitrarily complicated logical statements.</span></p><p><span>Actual TypeScript doesn&#x27;t do much better here; it seems to deduce the disjunction only for tests involving the same variable:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">const</span> z <span class="sc-ezzafa dvHFX">=</span> <span class="sc-hiKfDv dRsyqq">1</span> <span class="sc-kLojOw iehvjW">as</span> <span class="sc-hiKfDv dRsyqq">1</span> <span class="sc-ezzafa dvHFX">|</span> <span class="sc-hiKfDv dRsyqq">2</span> <span class="sc-ezzafa dvHFX">|</span> <span class="sc-hiKfDv dRsyqq">3</span>

<span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>z <span class="sc-ezzafa dvHFX">!==</span> <span class="sc-hiKfDv dRsyqq">1</span> <span class="sc-ezzafa dvHFX">&amp;&amp;</span> z <span class="sc-ezzafa dvHFX">!==</span> <span class="sc-hiKfDv dRsyqq">2</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
  z <span class="sc-iBzEeX glZmJR">// z has type 3</span>
<span class="sc-ezzafa dvHFX">}</span> <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>z <span class="sc-ezzafa dvHFX">!==</span> <span class="sc-hiKfDv dRsyqq">1</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
  z <span class="sc-iBzEeX glZmJR">// z has type 2</span>
  <span class="sc-iBzEeX glZmJR">// because ((NOT (z !== 1)) OR (NOT (z !== 2))) AND (z !== 1)</span>
  <span class="sc-iBzEeX glZmJR">// implies NOT (z !== 2)</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><p><span>This doesn&#x27;t work for two different variables, or for two properties of the same object.</span></p><h4 id="narrowbinary"><span>narrowBinary</span></h4><p><span>When an </span><span><code>===</code></span><span>-expression is assumed true (or a </span><span><code>!==</code></span><span>-expression assumed false), we can deduce the logical statement</span></p><pre class="sc-bdnxRM bOWasK"><code>ast<span class="sc-ezzafa dvHFX">.</span>left <span class="sc-ezzafa dvHFX">===</span> ast<span class="sc-ezzafa dvHFX">.</span>right</code></pre><p><span>We can&#x27;t represent this directly with types and environments, but we can represent the statement that each side has the same type as the other side (since the value must satisfy both types); so we narrow each side to the type of the other.</span></p><p><span>When a </span><span><code>!==</code></span><span>-expression is assumed true (or an </span><span><code>===</code></span><span>-expression assumed false), we can deduce the logical statement</span></p><pre class="sc-bdnxRM bOWasK"><code>ast<span class="sc-ezzafa dvHFX">.</span>left <span class="sc-ezzafa dvHFX">!==</span> ast<span class="sc-ezzafa dvHFX">.</span>right</code></pre><p><span>When one side has singleton type we can narrow the other side to the negation of the singleton type; in other cases we have no way to represent the statement.</span></p><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/narrow.ts#L235" class="sc-gtsrHT kFWJEY"><span>narrow.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrowBinary</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>BinaryExpression<span class="sc-ezzafa dvHFX">,</span> assume<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">boolean</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">!</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isExpression</span><span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-iklJeh hbusih">bug</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-bYwzuL fDDjHD">unimplemented </span><span class="sc-ezzafa dvHFX">${</span><span class="sc-ezzafa dvHFX">ast</span><span class="sc-ezzafa dvHFX">.</span><span class="sc-ezzafa dvHFX">left</span><span class="sc-ezzafa dvHFX">.</span><span class="sc-kLojOw iehvjW">type</span><span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">const</span> left <span class="sc-ezzafa dvHFX">=</span> <span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">const</span> right <span class="sc-ezzafa dvHFX">=</span> <span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>right<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>operator <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;===&#x27;</span> <span class="sc-ezzafa dvHFX">&amp;&amp;</span> assume <span class="sc-ezzafa dvHFX">||</span> ast<span class="sc-ezzafa dvHFX">.</span>operator <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;!==&#x27;</span> <span class="sc-ezzafa dvHFX">&amp;&amp;</span> <span class="sc-ezzafa dvHFX">!</span>assume<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    env <span class="sc-ezzafa dvHFX">=</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">,</span> right<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
    <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>right<span class="sc-ezzafa dvHFX">,</span> left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

  <span class="sc-ezzafa dvHFX">}</span> <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>operator <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;!==&#x27;</span> <span class="sc-ezzafa dvHFX">&amp;&amp;</span> assume <span class="sc-ezzafa dvHFX">||</span> ast<span class="sc-ezzafa dvHFX">.</span>operator <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;===&#x27;</span> <span class="sc-ezzafa dvHFX">&amp;&amp;</span> <span class="sc-ezzafa dvHFX">!</span>assume<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isSingleton</span><span class="sc-ezzafa dvHFX">(</span>right<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
      env <span class="sc-ezzafa dvHFX">=</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">not</span><span class="sc-ezzafa dvHFX">(</span>right<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
    <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isSingleton</span><span class="sc-ezzafa dvHFX">(</span>left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
      env <span class="sc-ezzafa dvHFX">=</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>right<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">not</span><span class="sc-ezzafa dvHFX">(</span>left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
    <span class="sc-kLojOw iehvjW">return</span> env<span class="sc-ezzafa dvHFX">;</span>

  <span class="sc-ezzafa dvHFX">}</span> <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">return</span> env<span class="sc-ezzafa dvHFX">;</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><h3 id="narrowpath"><span>narrowPath</span></h3><p><span>Here&#x27;s the top-level </span><span><code>narrowPath</code></span><span> function (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/narrow.ts#L157" class="sc-gtsrHT kFWJEY"><span>narrow.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>Expression<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> Env <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">switch</span> <span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>type<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;Identifier&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPathIdentifier</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;MemberExpression&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPathMember</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;UnaryExpression&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPathUnary</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">default</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-kLojOw iehvjW">return</span> env<span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">}</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><p><span>For ASTs representing paths we dispatch to AST-specific functions; otherwise we deduce nothing.</span></p><h4 id="narrowpathidentifier"><span>narrowPathIdentifier</span></h4><p><span>For an identifier, we look up the current type in the environment, narrow it to the deduced type with </span><span><code>narrowType</code></span><span>, then update the environment (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/narrow.ts#L83" class="sc-gtsrHT kFWJEY"><span>narrow.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrowPathIdentifier</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>Identifier<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">const</span> ident <span class="sc-ezzafa dvHFX">=</span> env<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">get</span><span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>name<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">!</span>ident<span class="sc-ezzafa dvHFX">)</span> <span class="sc-iklJeh hbusih">bug</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-bYwzuL fDDjHD">&#x27;expected bound identifer&#x27;</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">return</span> env<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">set</span><span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>name<span class="sc-ezzafa dvHFX">,</span> <span class="sc-iklJeh hbusih">narrowType</span><span class="sc-ezzafa dvHFX">(</span>ident<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><h4 id="narrowpathmember"><span>narrowPathMember</span></h4><p><span>As above, we can&#x27;t directly represent a logical statement giving a type to a member expression like</span></p><pre class="sc-bdnxRM bOWasK"><code>x<span class="sc-ezzafa dvHFX">.</span>type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span></code></pre><p><span>so we turn it into the equivalent</span></p><pre class="sc-bdnxRM bOWasK"><code>x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-ezzafa dvHFX">{</span> type<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;a&#x27;</span> <span class="sc-ezzafa dvHFX">}</span></code></pre><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/narrow.ts#L95" class="sc-gtsrHT kFWJEY"><span>narrow.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrowPathMember</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>MemberExpression<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>computed<span class="sc-ezzafa dvHFX">)</span> <span class="sc-iklJeh hbusih">bug</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-bYwzuL fDDjHD">unimplemented computed</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">!</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isIdentifier</span><span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>property<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-iklJeh hbusih">bug</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-bYwzuL fDDjHD">unexpected </span><span class="sc-ezzafa dvHFX">${</span><span class="sc-ezzafa dvHFX">ast</span><span class="sc-ezzafa dvHFX">.</span><span class="sc-ezzafa dvHFX">property</span><span class="sc-ezzafa dvHFX">.</span><span class="sc-kLojOw iehvjW">type</span><span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>
    env<span class="sc-ezzafa dvHFX">,</span>
    ast<span class="sc-ezzafa dvHFX">.</span>object<span class="sc-ezzafa dvHFX">,</span>
    Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">object</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">{</span> <span class="sc-ezzafa dvHFX">[</span>ast<span class="sc-ezzafa dvHFX">.</span>property<span class="sc-ezzafa dvHFX">.</span>name<span class="sc-ezzafa dvHFX">]</span><span class="sc-ezzafa dvHFX">:</span> type <span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">)</span>
  <span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><h4 id="narrowpathunary"><span>narrowPathUnary</span></h4><p><span>For a logical statement like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">typeof</span> x <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;boolean&#x27;</span></code></pre><p><span>we give the left side the equivalent singleton type (via </span><span><code>narrowBinary</code></span><span>)</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">typeof</span> x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-bYwzuL fDDjHD">&#x27;boolean&#x27;</span></code></pre><p><span>then deduce information about </span><span><code>x</code></span><span> from the type of </span><span><code>typeof x</code></span><span>. Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/narrow.ts#L111" class="sc-gtsrHT kFWJEY"><span>narrow.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrowPathUnary</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>UnaryExpression<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">switch</span> <span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>operator<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;!&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">return</span> env<span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;typeof&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isSingleton</span><span class="sc-ezzafa dvHFX">(</span>type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
        <span class="sc-kLojOw iehvjW">switch</span> <span class="sc-ezzafa dvHFX">(</span>type<span class="sc-ezzafa dvHFX">.</span>value<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
          <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;boolean&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
            <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>argument<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">boolean</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
          <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;number&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
            <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>argument<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">number</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
          <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;string&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
            <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>argument<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">string</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
          <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;object&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
            <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>argument<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">object</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">{</span><span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
          <span class="sc-kLojOw iehvjW">default</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-kLojOw iehvjW">return</span> env<span class="sc-ezzafa dvHFX">;</span>
        <span class="sc-ezzafa dvHFX">}</span>
      <span class="sc-ezzafa dvHFX">}</span> <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isNot</span><span class="sc-ezzafa dvHFX">(</span>type<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">&amp;&amp;</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isSingleton</span><span class="sc-ezzafa dvHFX">(</span>type<span class="sc-ezzafa dvHFX">.</span>base<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
        <span class="sc-kLojOw iehvjW">switch</span> <span class="sc-ezzafa dvHFX">(</span>type<span class="sc-ezzafa dvHFX">.</span>base<span class="sc-ezzafa dvHFX">.</span>value<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
          <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;boolean&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
            <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>argument<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">not</span><span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">boolean</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
          <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;number&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
            <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>argument<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">not</span><span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">number</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
          <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;string&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
            <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>argument<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">not</span><span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">string</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
          <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;object&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
            <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">narrowPath</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>argument<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">not</span><span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">object</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">{</span><span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
          <span class="sc-kLojOw iehvjW">default</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-kLojOw iehvjW">return</span> env<span class="sc-ezzafa dvHFX">;</span>
        <span class="sc-ezzafa dvHFX">}</span>
      <span class="sc-ezzafa dvHFX">}</span>
      <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">return</span> env<span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">default</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-iklJeh hbusih">bug</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-bYwzuL fDDjHD">unexpected </span><span class="sc-ezzafa dvHFX">${</span><span class="sc-ezzafa dvHFX">ast</span><span class="sc-ezzafa dvHFX">.</span><span class="sc-ezzafa dvHFX">operator</span><span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">}</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><p><span>If the </span><span><code>typeof</code></span><span> a path satisfies the negation of a singleton type tag, we deduce that the path must satisfy the negation of the corresponding type. All object types are subtypes of </span><span><code>{}</code></span><span>; but we have no way to represent a type that includes all functions, so for </span><span><code>&#x27;function&#x27;</code></span><span> we deduce nothing.</span></p><h3 id="narrowtype"><span>narrowType</span></h3><p><span>As above, </span><span><code>narrowType(x, y)</code></span><span> corresponds to a logical statement that some variable has type </span><span><code>x</code></span><span> AND it has type </span><span><code>y</code></span><span>; so it&#x27;s a kind of intersection of </span><span><code>x</code></span><span> and </span><span><code>y</code></span><span>. However, we don&#x27;t implement it with </span><span><code>Type.intersection</code></span><span>. There are two reasons for this:</span></p><ul><li><p><span><code>narrowType</code></span><span> handles </span><span><code>Not</code></span><span>-types; we don&#x27;t want to hair up the rest of the type checker with </span><span><code>Not</code></span><span>-types, so we have a specialized function.</span></p></li><li><p><span><code>Type.intersection</code></span><span> doesn&#x27;t normalize inside object types (see </span><a href="/blog/2021-10-28-Reconstructing-TypeScript-part-5#normalizing-intersection-types"><span>part 5</span></a><span>), but our strategy in </span><span><code>narrowPathMember</code></span><span> produces intersections of object types that we&#x27;d like to normalize to produce more readable types.</span></p></li></ul><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/narrow.ts#L30" class="sc-gtsrHT kFWJEY"><span>narrow.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">narrowType</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">,</span> y<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> Type <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isNever</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">||</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isNever</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">never</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isUnknown</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">widenNots</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isUnknown</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-kLojOw iehvjW">return</span> x<span class="sc-ezzafa dvHFX">;</span>

  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isUnion</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
    <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">union</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">...</span>x<span class="sc-ezzafa dvHFX">.</span>types<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">map</span><span class="sc-ezzafa dvHFX">(</span>a <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-iklJeh hbusih">narrowType</span><span class="sc-ezzafa dvHFX">(</span>a<span class="sc-ezzafa dvHFX">,</span> y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isUnion</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
    <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">union</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">...</span>y<span class="sc-ezzafa dvHFX">.</span>types<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">map</span><span class="sc-ezzafa dvHFX">(</span>b <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-iklJeh hbusih">narrowType</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">,</span> b<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isIntersection</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
    <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">intersection</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">...</span>x<span class="sc-ezzafa dvHFX">.</span>types<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">map</span><span class="sc-ezzafa dvHFX">(</span>a <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-iklJeh hbusih">narrowType</span><span class="sc-ezzafa dvHFX">(</span>a<span class="sc-ezzafa dvHFX">,</span> y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isIntersection</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
    <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">intersection</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">...</span>y<span class="sc-ezzafa dvHFX">.</span>types<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">map</span><span class="sc-ezzafa dvHFX">(</span>b <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-iklJeh hbusih">narrowType</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">,</span> b<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isNot</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isSubtype</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">,</span> y<span class="sc-ezzafa dvHFX">.</span>base<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
      <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">never</span><span class="sc-ezzafa dvHFX">;</span>
    <span class="sc-ezzafa dvHFX">}</span> <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isBoolean</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">&amp;&amp;</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isSingleton</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">.</span>base<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">&amp;&amp;</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isBoolean</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">.</span>base<span class="sc-ezzafa dvHFX">.</span>base<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
      <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">singleton</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">!</span>y<span class="sc-ezzafa dvHFX">.</span>base<span class="sc-ezzafa dvHFX">.</span>value<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
    <span class="sc-ezzafa dvHFX">}</span> <span class="sc-kLojOw iehvjW">else</span> <span class="sc-ezzafa dvHFX">{</span>
      <span class="sc-kLojOw iehvjW">return</span> x<span class="sc-ezzafa dvHFX">;</span>
    <span class="sc-ezzafa dvHFX">}</span>
  <span class="sc-ezzafa dvHFX">}</span>

  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isSingleton</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">&amp;&amp;</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isSingleton</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
    <span class="sc-kLojOw iehvjW">return</span> <span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">.</span>value <span class="sc-ezzafa dvHFX">===</span> y<span class="sc-ezzafa dvHFX">.</span>value<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">?</span> x <span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">never</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isSingleton</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
    <span class="sc-kLojOw iehvjW">return</span> <span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">.</span>base<span class="sc-ezzafa dvHFX">.</span>type <span class="sc-ezzafa dvHFX">===</span> y<span class="sc-ezzafa dvHFX">.</span>type<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">?</span> x <span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">never</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isSingleton</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
    <span class="sc-kLojOw iehvjW">return</span> <span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">.</span>base<span class="sc-ezzafa dvHFX">.</span>type <span class="sc-ezzafa dvHFX">===</span> x<span class="sc-ezzafa dvHFX">.</span>type<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">?</span> y <span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">never</span><span class="sc-ezzafa dvHFX">;</span>

  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isObject</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">&amp;&amp;</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isObject</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-kLojOw iehvjW">const</span> properties <span class="sc-ezzafa dvHFX">=</span>
      x<span class="sc-ezzafa dvHFX">.</span>properties<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">map</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">{</span> name<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">:</span> xType <span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-ezzafa dvHFX">{</span>
          <span class="sc-kLojOw iehvjW">const</span> yType <span class="sc-ezzafa dvHFX">=</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">propType</span><span class="sc-ezzafa dvHFX">(</span>y<span class="sc-ezzafa dvHFX">,</span> name<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
          <span class="sc-kLojOw iehvjW">const</span> type <span class="sc-ezzafa dvHFX">=</span> yType <span class="sc-ezzafa dvHFX">?</span> <span class="sc-iklJeh hbusih">narrowType</span><span class="sc-ezzafa dvHFX">(</span>xType<span class="sc-ezzafa dvHFX">,</span> yType<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">:</span> xType<span class="sc-ezzafa dvHFX">;</span>
          <span class="sc-kLojOw iehvjW">return</span> <span class="sc-ezzafa dvHFX">{</span> name<span class="sc-ezzafa dvHFX">,</span> type <span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">;</span>
          <span class="sc-iBzEeX glZmJR">// if there are  fields in `y` that are not in `x`, ignore them</span>
        <span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">,</span>
        <span class="sc-ezzafa dvHFX">{</span> <span class="sc-ezzafa dvHFX">}</span>
      <span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
    <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>properties<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">some</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">{</span> type <span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">=&gt;</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isNever</span><span class="sc-ezzafa dvHFX">(</span>type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
      <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">never</span><span class="sc-ezzafa dvHFX">;</span>
    <span class="sc-kLojOw iehvjW">else</span>
      <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">object</span><span class="sc-ezzafa dvHFX">(</span>properties<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">}</span>

  <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">intersection</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">,</span> y<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><p><span><code>narrowType</code></span><span> is similar to </span><span><code>overlaps</code></span><span> (see </span><a href="/blog/2021-10-28-Reconstructing-TypeScript-part-5#detecting-empty-intersections"><span>part 5</span></a><span>); but instead of returning a flag it returns a type representing the overlap between its arguments (or </span><span><code>never</code></span><span> if they don&#x27;t overlap).</span></p><p><span><code>narrowType</code></span><span> accepts </span><span><code>Not</code></span><span>-types in its second argument, but does not return </span><span><code>Not-</code></span><span>types; so we never put </span><span><code>Not</code></span><span>-types in the environment, and the rest of the type checker doesn&#x27;t need to deal with them.</span></p><p><span>Normally </span><span><code>unknown &amp; t</code></span><span> </span><span><code>=== t</code></span><span> for any type </span><span><code>t</code></span><span>, but here </span><span><code>t</code></span><span> might contain </span><span><code>Not</code></span><span>-types, so in this case we call </span><span><code>widenNots</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/narrow.ts#L8" class="sc-gtsrHT kFWJEY"><span>narrow.ts</span></a><span>) to remove them.</span></p><p><span>If the second argument is </span><span><code>!t</code></span><span> and the first argument is a subtype of </span><span><code>t</code></span><span>, then there&#x27;s no overlap between them, so we return </span><span><code>never</code></span><span>. Along with the union rule, this makes types like </span><span><code>0|1 &amp; !1</code></span><span> reduce to </span><span><code>0</code></span><span>; but since </span><span><code>boolean</code></span><span> is not explicitly a union, we special-case it so </span><span><code>boolean &amp; !true</code></span><span> reduces to </span><span><code>false</code></span><span> (and vice versa).</span></p><h2 id="using-narrowing-in-type-checking"><span>Using narrowing in type checking</span></h2><p><span>OK! Now we know how to narrow type environments to incorporate information deduced from tests—let&#x27;s see how to apply it in type checking:</span></p><h3 id="synthesizing-types-from-conditional-expressions"><span>Synthesizing types from conditional expressions</span></h3><p><span>A conditional expression parses into a </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L429" class="sc-gtsrHT kFWJEY"><span><code>ConditionalExpression</code></span></a><span> AST node. To synthesize a type from it, we</span></p><ul><li><p><span>synthesize a type from the the test expression</span></p></li><li><p><span>synthesize a type from the true branch (also known as the </span><span><em>consequent</em></span><span>), using an environment narrowed with the assumption that the test is true</span></p></li><li><p><span>synthesize a type from the false branch (also known as the </span><span><em>alternate</em></span><span>), using an environment narrowed with the assumption that the test is false</span></p></li><li><p><span>return the union of the true and false branch types</span></p></li></ul><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/synth.ts#L230" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>Expression<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> Type <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-ezzafa dvHFX">...</span>
  <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;ConditionalExpression&#x27;</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">synthConditional</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">...</span>
<span class="sc-ezzafa dvHFX">}</span>

<span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">synthConditional</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>ConditionalExpression<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> Type <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">const</span> test <span class="sc-ezzafa dvHFX">=</span> <span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>test<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">const</span> <span class="sc-cTJkRt lmGFyU">consequent</span> <span class="sc-ezzafa dvHFX">=</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>test<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">true</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>consequent<span class="sc-ezzafa dvHFX">)</span>
  <span class="sc-kLojOw iehvjW">const</span> <span class="sc-cTJkRt lmGFyU">alternate</span> <span class="sc-ezzafa dvHFX">=</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>test<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">false</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>alternate<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isTruthy</span><span class="sc-ezzafa dvHFX">(</span>test<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
    <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">consequent</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isFalsy</span><span class="sc-ezzafa dvHFX">(</span>test<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
    <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">alternate</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">else</span>
    <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">union</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">consequent</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">,</span> <span class="sc-iklJeh hbusih">alternate</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><p><span>When the test is true, we return the type of the consequent directly, and don&#x27;t type check the alternate at all (and similarly when it&#x27;s false). This is a little weird! It means you can put nonsense in an untaken branch, like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cBoqAE lRfdj">true</span> <span class="sc-ezzafa dvHFX">?</span> <span class="sc-hiKfDv dRsyqq">7</span> <span class="sc-ezzafa dvHFX">:</span> <span class="sc-hiKfDv dRsyqq">7</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-hiKfDv dRsyqq">9</span><span class="sc-ezzafa dvHFX">)</span></code></pre><p><span>But it&#x27;s correct in the sense that the untaken branch is never executed, so its type (or whether it has type errors) can&#x27;t matter. And it makes it possible to check expressions against intersection types. For example, in</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">(</span>x <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-hiKfDv dRsyqq">0</span> <span class="sc-ezzafa dvHFX">+</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-kLojOw iehvjW">typeof</span> x <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;number&#x27;</span> <span class="sc-ezzafa dvHFX">?</span> x <span class="sc-ezzafa dvHFX">:</span> <span class="sc-iklJeh hbusih">x</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-hiKfDv dRsyqq">7</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-kLojOw iehvjW">as</span>
  <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">number</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-efHYUO cFSLxQ">number</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">&amp;</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">(</span>x<span class="sc-ezzafa dvHFX">:</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">(</span>n<span class="sc-ezzafa dvHFX">:</span> <span class="sc-efHYUO cFSLxQ">number</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-efHYUO cFSLxQ">number</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-efHYUO cFSLxQ">number</span><span class="sc-ezzafa dvHFX">)</span></code></pre><p><span>we check the function expression against the intersection by separately checking against each part (</span><span><code>0 +</code></span><span> before the conditional forces it to be synthesized, not checked); when checking against the first part, the environment contains </span><span><code>x: number</code></span><span>, so </span><span><code>x(7)</code></span><span> would cause a type error, but </span><span><code>typeof x === &#x27;number&#x27;</code></span><span> is true, so we don&#x27;t type check the false branch.</span></p><p><span>One way to think about what&#x27;s happening here is that if we did type check the untaken branch, </span><span><code>x</code></span><span> would be narrowed to </span><span><code>never</code></span><span>. We could add a case to </span><span><code>Type.map</code></span><span> to propagate </span><span><code>never</code></span><span>:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">map</span><span class="sc-ezzafa dvHFX">(</span>t<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cTJkRt lmGFyU">fn</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-ezzafa dvHFX">(</span>t<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">=&gt;</span> Type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isNever</span><span class="sc-ezzafa dvHFX">(</span>t<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-efHYUO cFSLxQ">never</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">...</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><p><span>Then we&#x27;d synthesize </span><span><code>never</code></span><span> from </span><span><code>x(7)</code></span><span> in the untaken branch, so the example would type check without error. But total nonsense like </span><span><code>7(9)</code></span><span> would cause an error. This might be a good idea?</span></p><p><span>Actual TypeScript flags an unreachable code error for untaken branches, but still type checks both branches.</span></p><h3 id="checking-conditional-expressions-against-types"><span>Checking conditional expressions against types</span></h3><p><span>To check a conditional expression against an expected type we</span></p><ul><li><p><span>synthesize a type from the the test expression</span></p></li><li><p><span>check the true branch against the expected type, using an environment narrowed with the assumption that the test is true</span></p></li><li><p><span>check the false branch against the expected type, using an environment narrowed with the assumption that the test is false</span></p></li></ul><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/check.ts#L55" class="sc-gtsrHT kFWJEY"><span>check.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">check</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>Expression<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-kLojOw iehvjW">void</span> <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-ezzafa dvHFX">...</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isConditionalExpression</span><span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
    <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">checkConditional</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">...</span>
<span class="sc-ezzafa dvHFX">}</span>

<span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">checkConditional</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>ConditionalExpression<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">:</span> Type<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-kLojOw iehvjW">void</span> <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">const</span> test <span class="sc-ezzafa dvHFX">=</span> <span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>test<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">const</span> <span class="sc-cTJkRt lmGFyU">consequent</span> <span class="sc-ezzafa dvHFX">=</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-iklJeh hbusih">check</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>test<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">true</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>consequent<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">)</span>
  <span class="sc-kLojOw iehvjW">const</span> <span class="sc-cTJkRt lmGFyU">alternate</span> <span class="sc-ezzafa dvHFX">=</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-iklJeh hbusih">check</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>test<span class="sc-ezzafa dvHFX">,</span> <span class="sc-cBoqAE lRfdj">false</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>alternate<span class="sc-ezzafa dvHFX">,</span> type<span class="sc-ezzafa dvHFX">)</span>
  <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isTruthy</span><span class="sc-ezzafa dvHFX">(</span>test<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-iklJeh hbusih">consequent</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">}</span> <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isFalsy</span><span class="sc-ezzafa dvHFX">(</span>test<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-iklJeh hbusih">alternate</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">}</span> <span class="sc-kLojOw iehvjW">else</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-iklJeh hbusih">consequent</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
    <span class="sc-iklJeh hbusih">alternate</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">}</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><h3 id="narrowing-in-logical-operators"><span>Narrowing in logical operators</span></h3><p><span>Because logical operators are short-circuit, we can also narrow the environment when type checking the right side. For an </span><span><code>&amp;&amp;</code></span><span>-expression, the right side is executed only when the left side is true, so we narrow assuming the left side is true (and similarly for an </span><span><code>||</code></span><span>-expression).</span></p><p><span>We can finally give a precise result type for logical expressions when we don&#x27;t know whether the left side is true or false: it&#x27;s the union of the types of the sides, but the left side is narrowed to falsy values for </span><span><code>&amp;&amp;</code></span><span> (</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND#short-circuit_evaluation" class="sc-gtsrHT kFWJEY"><span>when the left side is not falsy the right side is returned</span></a><span>) and truthy values for </span><span><code>||</code></span><span>.</span></p><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part6/src/typecheck/synth.ts#L164" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">function</span> <span class="sc-iklJeh hbusih">synthLogical</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">:</span> Env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">:</span> <span class="sc-cBoqAE lRfdj">AST</span><span class="sc-ezzafa dvHFX">.</span>LogicalExpression<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">:</span> Type <span class="sc-ezzafa dvHFX">{</span>
  <span class="sc-kLojOw iehvjW">const</span> left <span class="sc-ezzafa dvHFX">=</span> <span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">const</span> <span class="sc-cTJkRt lmGFyU">right</span> <span class="sc-ezzafa dvHFX">=</span> <span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">=&gt;</span> <span class="sc-iklJeh hbusih">synth</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">narrow</span><span class="sc-ezzafa dvHFX">(</span>env<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>left<span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>operator <span class="sc-ezzafa dvHFX">===</span> <span class="sc-bYwzuL fDDjHD">&#x27;&amp;&amp;&#x27;</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">,</span> ast<span class="sc-ezzafa dvHFX">.</span>right<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-kLojOw iehvjW">switch</span> <span class="sc-ezzafa dvHFX">(</span>ast<span class="sc-ezzafa dvHFX">.</span>operator<span class="sc-ezzafa dvHFX">)</span> <span class="sc-ezzafa dvHFX">{</span>
    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;&amp;&amp;&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isFalsy</span><span class="sc-ezzafa dvHFX">(</span>left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
        <span class="sc-kLojOw iehvjW">return</span> left<span class="sc-ezzafa dvHFX">;</span>
      <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isTruthy</span><span class="sc-ezzafa dvHFX">(</span>left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
        <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">right</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
      <span class="sc-kLojOw iehvjW">else</span>
        <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">union</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">narrowType</span><span class="sc-ezzafa dvHFX">(</span>left<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span>falsy<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">,</span> <span class="sc-iklJeh hbusih">right</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">case</span> <span class="sc-bYwzuL fDDjHD">&#x27;||&#x27;</span><span class="sc-ezzafa dvHFX">:</span>
      <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isTruthy</span><span class="sc-ezzafa dvHFX">(</span>left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
        <span class="sc-kLojOw iehvjW">return</span> left<span class="sc-ezzafa dvHFX">;</span>
      <span class="sc-kLojOw iehvjW">else</span> <span class="sc-kLojOw iehvjW">if</span> <span class="sc-ezzafa dvHFX">(</span>Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">isFalsy</span><span class="sc-ezzafa dvHFX">(</span>left<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span>
        <span class="sc-kLojOw iehvjW">return</span> <span class="sc-iklJeh hbusih">right</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
      <span class="sc-kLojOw iehvjW">else</span>
        <span class="sc-kLojOw iehvjW">return</span> Type<span class="sc-ezzafa dvHFX">.</span><span class="sc-iklJeh hbusih">union</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-iklJeh hbusih">narrowType</span><span class="sc-ezzafa dvHFX">(</span>left<span class="sc-ezzafa dvHFX">,</span> Type<span class="sc-ezzafa dvHFX">.</span>truthy<span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">,</span> <span class="sc-iklJeh hbusih">right</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>

    <span class="sc-kLojOw iehvjW">default</span><span class="sc-ezzafa dvHFX">:</span> <span class="sc-iklJeh hbusih">bug</span><span class="sc-ezzafa dvHFX">(</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-bYwzuL fDDjHD">unimplemented </span><span class="sc-ezzafa dvHFX">${</span><span class="sc-ezzafa dvHFX">ast</span><span class="sc-ezzafa dvHFX">.</span><span class="sc-ezzafa dvHFX">operator</span><span class="sc-ezzafa dvHFX">}</span><span class="sc-ezzafa dvHFX">`</span><span class="sc-ezzafa dvHFX">)</span><span class="sc-ezzafa dvHFX">;</span>
  <span class="sc-ezzafa dvHFX">}</span>
<span class="sc-ezzafa dvHFX">}</span></code></pre><h2 id="aside-narrowing-as-logical-implication-revisited"><span>Aside: narrowing as logical implication, revisited</span></h2><p><span>I wrote the narrowing code by following my nose; later I read a research paper (</span><a href="https://www2.ccs.neu.edu/racket/pubs/icfp10-thf.pdf" class="sc-gtsrHT kFWJEY"><span>Logical Types for Untyped Languages</span></a><span>) that gave me a different perspective on what the code does, and alerted me to some deficiencies:</span></p><p><span>As above, there are some logical statements that can&#x27;t be represented faithfully (such as the disjunction produced by assuming an </span><span><code>&amp;&amp;</code></span><span>-expression false).</span></p><p><span>Also, our implementation does redundant work: for example, in</span></p><pre class="sc-bdnxRM bOWasK"><code>a <span class="sc-ezzafa dvHFX">&amp;&amp;</span> b <span class="sc-ezzafa dvHFX">&amp;&amp;</span> c</code></pre><p><span><code>b</code></span><span> is typechecked in an environment narrowed with </span><span><code>a</code></span><span>, and </span><span><code>c</code></span><span> is typechecked in an environment narrowed with </span><span><code>a &amp;&amp; b</code></span><span>, which narrows </span><span><code>a</code></span><span> again. The problem is that narrowing information is not returned from </span><span><code>synth</code></span><span>, so must be reconstructed. In the paper, </span><span><code>synth</code></span><span> returns a type and also a pair of logical statements representing what can be deduced from the expression if it is assumed true or false.</span></p><p><span>It would be interesting to rewrite the type checker to use explicit logical statements to avoid these issues.</span></p><p><span>Also, I wonder if representing union and intersection types as logical statements might address the problems of incomplete subtyping (see </span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4#subtyping-union-types"><span>part 4</span></a><span> and </span><a href="/blog/2021-10-28-Reconstructing-TypeScript-part-5#subtyping-intersection-types"><span>part 5</span></a><span>). Subtyping can be seen as a kind of logical implication; maybe it can be implemented like a SAT solver? If you know something about this please get in touch!</span></p><h2 id="try-it"><span>Try it!</span></h2><p><span>You can try out the type checker below. Click on an example button or type an expression in the top box. In the bottom box you&#x27;ll see a trace of the type checker execution, ending in a synthesized type (or an error). The trace is a tree of function calls; click on a function call to expand the tree under that call, or mouse over a call to highlight the matching return value.</span></p><iframe src="https://jaked.org/reconstructing-typescript/part6/" width="700" height="500" style="border-style:none"></iframe><h2 id="i-love-it-when-a-plan-comes-together"><span>I love it when a plan comes together</span></h2><p><span>For the full code of part 6 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part6" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part6</span></a><span>. To view the changes between part 5 and part 6 see </span><a href="https://github.com/jaked/reconstructing-typescript/compare/part5...part6" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/compare/part5...part6</span></a><span>.</span></p><p><span>Here&#x27;s the whole series:</span></p><ul><li><p><span></span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>Part 0: intro and background</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>Part 1: bidirectional type checking</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>Part 2: functions and function calls</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-06-Reconstructing-TypeScript-part-3"><span>Part 3: operators and singleton types</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4"><span>Part 4: union types</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-28-Reconstructing-TypeScript-part-5"><span>Part 5: intersection types</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-11-11-Reconstructing-TypeScript-part-6"><span>Part 6: narrowing</span></a><span></span></p></li></ul><p><span>There are other interesting aspects of TypeScript that I might cover in the future, like</span></p><ul><li><p><span></span><a href="https://www.typescriptlang.org/docs/handbook/2/generics.html" class="sc-gtsrHT kFWJEY"><span>generic types</span></a><span> and type parameter inference</span></p></li><li><p><span>recursive types</span></p></li><li><p><span></span><a href="https://www.typescriptlang.org/docs/handbook/2/types-from-types.html" class="sc-gtsrHT kFWJEY"><span>type-level computation</span></a><span></span></p></li></ul><p><span>but for now this is the last part of Reconstructing TypeScript. Thanks for reading!</span></p><p><span>Please </span><a href="/blog/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p></div></body></html>