<html><head><title>How to implement a TypeScript-style type checker (Reconstructing TypeScript), part 4: union types</title><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@jakedonham"/><meta name="twitter:creator" content="@jakedonham"/><meta name="twitter:title" content="How to implement a TypeScript-style type checker (Reconstructing TypeScript), part 4: union types"/><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/2021-10-14-Reconstructing-TypeScript-part-4.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.bOWasK{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;overflow:auto;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"bOWasK,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.hbusih{color:#268bd2;}/*!sc*/
data-styled.g37[id="sc-iklJeh"]{content:"hbusih,"}/*!sc*/
.laKGqb{color:#000000;}/*!sc*/
data-styled.g38[id="sc-jJMGnK"]{content:"laKGqb,"}/*!sc*/
.dRsyqq{color:#aa1111;}/*!sc*/
data-styled.g39[id="sc-hiKfDv"]{content:"dRsyqq,"}/*!sc*/
.jKLUHq{color:#770088;}/*!sc*/
data-styled.g40[id="sc-gXfVKN"]{content:"jKLUHq,"}/*!sc*/
.lRfdj{color:#116644;}/*!sc*/
data-styled.g41[id="sc-cBoqAE"]{content:"lRfdj,"}/*!sc*/
.bwSYJA{color:#6f42c1;}/*!sc*/
data-styled.g42[id="sc-ciSkZP"]{content:"bwSYJA,"}/*!sc*/
.kyvWZW{color:#b58900;}/*!sc*/
data-styled.g43[id="sc-jcwpoC"]{content:"kyvWZW,"}/*!sc*/
.hBWCUB{color:#009900;}/*!sc*/
data-styled.g44[id="sc-carFqZ"]{content:"hBWCUB,"}/*!sc*/
.oxVOu{color:#221199;}/*!sc*/
data-styled.g45[id="sc-iTVJFM"]{content:"oxVOu,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript, part 4</span></p><h1 id="reconstructing-typescript-part-4-union-types"><span>Reconstructing TypeScript, part 4: union types</span></h1><h3 id="2021-10-14"><span><em>2021-10-14</em></span></h3><p><span>This post is part of a series about implementing type checking for a TypeScript-like language. The language fragment we&#x27;ve covered so far (in parts </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>1</span></a><span>, </span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>2</span></a><span>, and </span><a href="/blog/2021-10-06-Reconstructing-TypeScript-part-3"><span>3</span></a><span>) supports:</span></p><ul><li><p><span>primitives, object expressions and member lookups, functions and function applications, and some arithmetic and logical operators; and</span></p></li><li><p><span>primitive, object, function, and singleton types.</span></p></li></ul><p><span>In this part we&#x27;ll add </span><span><em>union</em></span><span> types like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iklJeh hbusih">string</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-iklJeh hbusih">boolean</span>
<span class="sc-hiKfDv dRsyqq">&#x27;red&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;green&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;blue&#x27;</span>
<span class="sc-jJMGnK laKGqb">{</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-gXfVKN jKLUHq">undefined</span>

<span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;cartesian&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span>
  <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;polar&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> angle<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> magnitude<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>to describe collections of values where we know each value satisfies (at least) one arm of the union, but we don&#x27;t know which one.</span></p><h2 id="whats-a-union-type"><span>What&#x27;s a union type?</span></h2><p><span>I wrote in </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0#whats-a-type-checker"><span>part 0</span></a><span> that a type</span></p><blockquote><p><span>describes attributes shared by [a collection of] values: what operations are supported; and, for some operations, what result they return.</span></p></blockquote><p><span>Now I need to complicate that explanation a little to make sense of union types.</span></p><p><span>First, a reminder that these are all ways of saying the same thing:</span></p><ul><li><p><span>a value </span><span><em>supports the operations described by</em></span><span> a type</span></p></li><li><p><span>a value </span><span><em>satisfies</em></span><span> a type</span></p></li><li><p><span>a type </span><span><em>contains</em></span><span> a value</span></p></li></ul><p><span>In what follows I&#x27;ll use all these ways to describe the same situation, don&#x27;t be confused!</span></p><p><span>Values satisfying a type may have additional attributes that aren&#x27;t described by the type (for example, extra object properties); different values may have different additional attributes; and we may view the same value as different types at different points in a program. For example, in</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">const</span> v1 <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">9</span> <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-gXfVKN jKLUHq">const</span> v2 <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;cartesian&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">9</span> <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>

<span class="sc-gXfVKN jKLUHq">const</span> <span class="sc-ciSkZP bwSYJA">magnitude</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">(</span>v<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jJMGnK laKGqb">{</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span>
  Math<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">sqrt</span><span class="sc-jJMGnK laKGqb">(</span>x <span class="sc-jJMGnK laKGqb">*</span> x <span class="sc-jJMGnK laKGqb">+</span> y <span class="sc-jJMGnK laKGqb">*</span> y<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>

<span class="sc-jcwpoC kyvWZW">magnitude</span><span class="sc-jJMGnK laKGqb">(</span>v1<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jcwpoC kyvWZW">magnitude</span><span class="sc-jJMGnK laKGqb">(</span>v2<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span></code></pre><p><span><code>v1</code></span><span> and </span><span><code>v2</code></span><span> have different types, but in the body of </span><span><code>magnitude</code></span><span> they&#x27;re viewed as the same type. So a type isn&#x27;t a complete description of a collection of values; it describes </span><span><em>what&#x27;s known</em></span><span> about the values </span><span><em>at a certain point in a program</em></span><span>.</span></p><p><span>A </span><span><em>union</em></span><span> type describes a situation where what&#x27;s known about a collection of values is that each value satisfies (at least) one of several types (called </span><span><em>arms</em></span><span> of the union), but we don&#x27;t know which one. What can we do with this knowledgeâ€”what operations are supported on union types? Since we don&#x27;t know which arm a given value satisfies, the operations supported on union types are those that are supported on </span><span><em>every</em></span><span> arm. For example, in the type</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;cartesian&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span>
  <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;polar&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> angle<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> magnitude<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>we can look up the </span><span><code>type</code></span><span> property, because it&#x27;s supported on every arm; but we can&#x27;t look up the other properties. We can also use </span><span><code>in</code></span><span> to test for the presence of properties (this is supported on all objects), test for truthiness (this is supported on all values), and so on.</span></p><p><span>Performing an operation on a value might yield information about which arm of the union the value satisfies; from that information we can deduce that additional operations are supported. For example, if the </span><span><code>type</code></span><span> property is </span><span><code>&#x27;cartesian&#x27;</code></span><span> we can deduce that the value satisfies the first arm of the union, so it&#x27;s safe to look up the </span><span><code>x</code></span><span> propertyâ€”we </span><span><em>narrow</em></span><span> the union type by eliminating some arms. (We&#x27;ll return to narrowing in part 6.)</span></p><p><span>A union with one arm contains the same values as the armâ€”every value of this type must satisfy the single arm.</span></p><p><span>A union with no arms contains no valuesâ€”a value of union type must satisfy one of the arms, but there are no arms to satisfy, so there can be no values. This type is called </span><span><code>never</code></span><span>; it&#x27;s useful to describe functions that always throw an exception (like </span><span><code>bug</code></span><span> and </span><span><code>err</code></span><span> in our implementation), or empty collections (an empty array has type </span><span><code>never[]</code></span><span>).</span></p><h2 id="equivalent-union-types"><span>Equivalent union types</span></h2><p><span>Union types give us lots of ways to describe the same collection of values:</span></p><p><span>The order of the arms of a union doesn&#x27;t matter; so for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-hiKfDv dRsyqq">&#x27;red&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;blue&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;green&#x27;</span>
<span class="sc-hiKfDv dRsyqq">&#x27;blue&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;red&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;green&#x27;</span>
<span class="sc-hiKfDv dRsyqq">&#x27;green&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;red&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;blue&#x27;</span></code></pre><p><span>all contain the same values.</span></p><p><span>If a union arm is a nested union, the arms of the inner union can be lifted up to the outer union (if a value satisfies the nested union, then it satisfies one of its arms); so for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-hiKfDv dRsyqq">&#x27;red&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-hiKfDv dRsyqq">&#x27;green&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;blue&#x27;</span><span class="sc-jJMGnK laKGqb">)</span>
<span class="sc-jJMGnK laKGqb">(</span><span class="sc-hiKfDv dRsyqq">&#x27;red&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;green&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;blue&#x27;</span>
<span class="sc-hiKfDv dRsyqq">&#x27;red&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;green&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;blue&#x27;</span></code></pre><p><span>all contain the same values.</span></p><p><span>If one arm of a union is a subtype of another, it can be removed (all values that satisfy it also satisfy the other arm); so for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;cartesian&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-jJMGnK laKGqb">{</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">{</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-iklJeh hbusih">never</span>
<span class="sc-jJMGnK laKGqb">{</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>all contain the same values. (We need to be careful about equivalent arms: in a union like </span><span><code>number | number</code></span><span> we don&#x27;t want to remove both arms because each is a subtype of the otherâ€”instead we keep just one equivalent arm.)</span></p><p><span>Finally, an object type with properties of union type supports the same operations as a union of object types; so for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">1</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-cBoqAE lRfdj">2</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">3</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-cBoqAE lRfdj">4</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">1</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-cBoqAE lRfdj">2</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">3</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">1</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-cBoqAE lRfdj">2</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">4</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">1</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">3</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-cBoqAE lRfdj">4</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">2</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">3</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-cBoqAE lRfdj">4</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>all contain the same values.</span></p><h2 id="representing-union-types"><span>Representing union types</span></h2><p><span>To represent union types, we add a </span><span><code>Union</code></span><span> arm to the </span><span><code>Type</code></span><span> union containing a list of arms, and a </span><span><code>Never</code></span><span> arm to represent </span><span><code>never</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/type/types.ts#L49" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">Type</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">...</span> <span class="sc-jJMGnK laKGqb">|</span> Never <span class="sc-jJMGnK laKGqb">|</span> Union<span class="sc-jJMGnK laKGqb">;</span>

<span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">Never</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Never&#x27;</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">Union</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Union&#x27;</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-gXfVKN jKLUHq">type</span>s<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>We add a constructor function for </span><span><code>Never</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/type/constructors.ts#L3" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>, and below for the </span><span><code>Union</code></span><span> constructor):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">const</span> <span class="sc-iklJeh hbusih">never</span><span class="sc-jJMGnK laKGqb">:</span> Never <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Never&#x27;</span> <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span></code></pre><p><span>and validator functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/type/validators.ts#L35" class="sc-gtsrHT kFWJEY"><span>validators.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">isNever</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-gXfVKN jKLUHq">is</span> Never <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> type<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Never&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">isUnion</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-gXfVKN jKLUHq">is</span> Union <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> type<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Union&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>and cases for </span><span><code>Union</code></span><span> and </span><span><code>Never</code></span><span> in </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/type/toString.ts#L31" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span> and </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/type/ofTSType.ts#L53" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span>.</span></p><h2 id="normalizing-union-types"><span>Normalizing union types</span></h2><p><span>We saw above that there are many ways union types can be equivalent. To simplify the type checker, and to make its output more readable, we normalize union types in the constructor: flatten nested unions and remove redundant arms. Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/type/union.ts" class="sc-gtsrHT kFWJEY"><span>union.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">collapseSubtypes</span><span class="sc-jJMGnK laKGqb">(</span>ts<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> ts<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">filter</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span>t1<span class="sc-jJMGnK laKGqb">,</span> i1<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span>       <span class="sc-carFqZ hBWCUB">// an arm is kept if</span>
    ts<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">every</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span>t2<span class="sc-jJMGnK laKGqb">,</span> i2<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span>             <span class="sc-carFqZ hBWCUB">// for every arm</span>
      i1 <span class="sc-jJMGnK laKGqb">===</span> i2 <span class="sc-jJMGnK laKGqb">||</span>                   <span class="sc-carFqZ hBWCUB">// (except itself)</span>
      <span class="sc-jJMGnK laKGqb">!</span><span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>t1<span class="sc-jJMGnK laKGqb">,</span> t2<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">||</span>          <span class="sc-carFqZ hBWCUB">// it&#x27;s not a subtype of the other arm</span>
      <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>t2<span class="sc-jJMGnK laKGqb">,</span> t1<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> i1 <span class="sc-jJMGnK laKGqb">&lt;</span> i2<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-carFqZ hBWCUB">// or it&#x27;s equivalent to the other arm</span>
                                     <span class="sc-carFqZ hBWCUB">// and this is the first equivalent arm</span>
    <span class="sc-jJMGnK laKGqb">)</span>
  <span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">flatten</span><span class="sc-jJMGnK laKGqb">(</span>ts<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span> <span class="sc-gXfVKN jKLUHq">as</span> Type<span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">concat</span><span class="sc-jJMGnK laKGqb">(</span>
    <span class="sc-jJMGnK laKGqb">...</span>ts<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">map</span><span class="sc-jJMGnK laKGqb">(</span>t <span class="sc-jJMGnK laKGqb">=&gt;</span> <span class="sc-jcwpoC kyvWZW">isUnion</span><span class="sc-jJMGnK laKGqb">(</span>t<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">?</span> t<span class="sc-jJMGnK laKGqb">.</span><span class="sc-gXfVKN jKLUHq">type</span>s <span class="sc-jJMGnK laKGqb">:</span> t<span class="sc-jJMGnK laKGqb">)</span>
  <span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">union</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">...</span><span class="sc-gXfVKN jKLUHq">type</span>s<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">type</span>s <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">flatten</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">type</span>s<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">type</span>s <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">collapseSubtypes</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">type</span>s<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>

  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">type</span>s<span class="sc-jJMGnK laKGqb">.</span>length <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-cBoqAE lRfdj">0</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iklJeh hbusih">never</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">type</span>s<span class="sc-jJMGnK laKGqb">.</span>length <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-cBoqAE lRfdj">1</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-gXfVKN jKLUHq">type</span>s<span class="sc-jJMGnK laKGqb">[</span><span class="sc-cBoqAE lRfdj">0</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Union&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> <span class="sc-gXfVKN jKLUHq">type</span>s <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>We don&#x27;t normalize the ordering of arms, or distribute object types over unions; so it&#x27;s still possible to write equivalent types in different ways. There are tradeoffs here among type checker performance, compact and readable types, and keeping types close to how they&#x27;re written in the code. (That&#x27;s not to say that I&#x27;ve explored these tradeoffs in any depth; I just did something straightforward that seems pretty close to what actual TypeScript does.)</span></p><p><span>Actual TypeScript normalizes types in some situations but not others; in particular, if you write down a type explictly, redundant object types aren&#x27;t removed. I don&#x27;t know why not!</span></p><h2 id="synthesizing-with-union-types"><span>Synthesizing with union types</span></h2><p><span>In our type checker so far, when synthesizing the type of an expression that operates on a subexpressionâ€”for example, a member expression like </span><span><code>foo.bar</code></span><span>â€”we synthesize the type of the subexpression, then check that it supports the operation and compute the result type, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthMember</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>MemberExpression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">const</span> prop <span class="sc-jJMGnK laKGqb">=</span> ast<span class="sc-jJMGnK laKGqb">.</span>property<span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">...</span>
  <span class="sc-gXfVKN jKLUHq">const</span> object <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>object<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">!</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isObject</span><span class="sc-jJMGnK laKGqb">(</span>object<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jcwpoC kyvWZW">err</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-hiKfDv dRsyqq">&#x27;. expects object&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>object<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">const</span> type <span class="sc-jJMGnK laKGqb">=</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">propType</span><span class="sc-jJMGnK laKGqb">(</span>object<span class="sc-jJMGnK laKGqb">,</span> prop<span class="sc-jJMGnK laKGqb">.</span>name<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">!</span>type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jcwpoC kyvWZW">err</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">no such property </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">prop</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">name</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">,</span> prop<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">return</span> type<span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>Now we need to handle the case where the subexpression has union type. We saw above that an operation is supported on a union type when it&#x27;s supported on every arm of the union. We don&#x27;t know which arm a value satisfies, and each arm might return a different result type for the operation. So the result type of the operation on the union must be the union of the result types of the operation on each arm. For example, for an expression </span><span><code>foo</code></span><span> of type</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jJMGnK laKGqb">{</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">boolean</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-jJMGnK laKGqb">{</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">string</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>the result type of </span><span><code>foo.bar</code></span><span> is</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iklJeh hbusih">boolean</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-iklJeh hbusih">string</span></code></pre><p><span>Every operation follows this same pattern, so we implement it using a helper function (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/type/map.ts" class="sc-gtsrHT kFWJEY"><span>map.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">map</span><span class="sc-jJMGnK laKGqb">(</span>t<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">,</span> <span class="sc-ciSkZP bwSYJA">fn</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jJMGnK laKGqb">(</span>t<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> Type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jcwpoC kyvWZW">isUnion</span><span class="sc-jJMGnK laKGqb">(</span>t<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jcwpoC kyvWZW">union</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">...</span>t<span class="sc-jJMGnK laKGqb">.</span><span class="sc-gXfVKN jKLUHq">type</span>s<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">map</span><span class="sc-jJMGnK laKGqb">(</span>fn<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">else</span>            <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jcwpoC kyvWZW">fn</span><span class="sc-jJMGnK laKGqb">(</span>t<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>The idea is that computing the result type of an operation from its operand type is a </span><span><code>Type =&gt; Type</code></span><span> function. We apply this function to a union type by applying it to each arm then taking the union of the results; for other types we just apply it. (Here </span><span><code>map</code></span><span> depends on normalizationâ€”</span><span><code>t.types</code></span><span> contains no unions.)</span></p><p><span>Now we synthesize a type from the subexpression as before, then map over it to compute the result type of the operation, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthMember</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>MemberExpression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">const</span> prop <span class="sc-jJMGnK laKGqb">=</span> ast<span class="sc-jJMGnK laKGqb">.</span>property<span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">...</span>
  <span class="sc-gXfVKN jKLUHq">const</span> object <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>object<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">map</span><span class="sc-jJMGnK laKGqb">(</span>object<span class="sc-jJMGnK laKGqb">,</span> object <span class="sc-jJMGnK laKGqb">=&gt;</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">!</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isObject</span><span class="sc-jJMGnK laKGqb">(</span>object<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jcwpoC kyvWZW">err</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-hiKfDv dRsyqq">&#x27;. expects object&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>object<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">const</span> type <span class="sc-jJMGnK laKGqb">=</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">propType</span><span class="sc-jJMGnK laKGqb">(</span>object<span class="sc-jJMGnK laKGqb">,</span> prop<span class="sc-jJMGnK laKGqb">.</span>name<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">!</span>type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jcwpoC kyvWZW">err</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">no such property </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">prop</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">name</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">,</span> prop<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">return</span> type<span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>We change the rest of the operations the same way (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/typecheck/synth.ts#L106" class="sc-gtsrHT kFWJEY"><span><code>synthCall</code></span></a><span>, </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/typecheck/synth.ts#L106" class="sc-gtsrHT kFWJEY"><span><code>synthBinary</code></span></a><span>, </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/typecheck/synth.ts#L106" class="sc-gtsrHT kFWJEY"><span><code>synthLogical</code></span></a><span>, </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/typecheck/synth.ts#L203" class="sc-gtsrHT kFWJEY"><span><code>synthUnary</code></span></a><span>). But when a subexpression is used without operating on itâ€”as a property value of an object expression, or passed as a function argumentâ€”then we don&#x27;t need to </span><span><code>map</code></span><span> over it, we just use the type directly. For example, in:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">const</span> value<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">string</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-iklJeh hbusih">boolean</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">...</span>
<span class="sc-gXfVKN jKLUHq">const</span> obj <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> value <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>we use the type of </span><span><code>value</code></span><span> directly as the property type, so the type of </span><span><code>obj</code></span><span> is</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">string</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-iklJeh hbusih">boolean</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>We can now improve the result type of </span><span><code>&amp;&amp;</code></span><span> (and </span><span><code>||</code></span><span>), since we can express the situation where we don&#x27;t know whether the left or right side is returned (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part4/src/typecheck/synth.ts#L167" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;&amp;&amp;&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isFalsy</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>
    <span class="sc-gXfVKN jKLUHq">return</span> left<span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">else</span> <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isTruthy</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>
    <span class="sc-gXfVKN jKLUHq">return</span> right<span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">else</span>
    <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">union</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">,</span> right<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span></code></pre><p><span>This is still not completely precise: when the left side is returned, it must be falsy, so we can narrow its type to falsy values. We&#x27;ll fix this in part 6.</span></p><h2 id="subtyping-union-types"><span>Subtyping union types</span></h2><p><span>A union type is a subtype of another type if each of its arms is a subtype of the other typeâ€”so </span><span><code>never</code></span><span>, having no arms, is a subtype of every type. A type is a subtype of a union type if it&#x27;s a subtype of at least one of the arms. (To see why these rules are valid, the view from </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1#subtyping"><span>part 1</span></a><span> of subtyping as an adversarial game might be useful.) Here&#x27;s the code:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">,</span> b<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">boolean</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isNever</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-jJMGnK laKGqb">;</span>

  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isUnion</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>
    <span class="sc-gXfVKN jKLUHq">return</span> a<span class="sc-jJMGnK laKGqb">.</span><span class="sc-gXfVKN jKLUHq">type</span>s<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">every</span><span class="sc-jJMGnK laKGqb">(</span>a <span class="sc-jJMGnK laKGqb">=&gt;</span> <span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">,</span> b<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>

  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isUnion</span><span class="sc-jJMGnK laKGqb">(</span>b<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>
    <span class="sc-gXfVKN jKLUHq">return</span> b<span class="sc-jJMGnK laKGqb">.</span><span class="sc-gXfVKN jKLUHq">type</span>s<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">some</span><span class="sc-jJMGnK laKGqb">(</span>b <span class="sc-jJMGnK laKGqb">=&gt;</span> <span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">,</span> b<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">...</span></code></pre><p><span>Unfortunately, these straightforward rules are not </span><span><em>complete</em></span><span>â€”there are pairs of types that contain the same values, but are not subtypes of one another according to this function. For example:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">a</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">1</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-cBoqAE lRfdj">2</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">b</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">1</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">2</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span><code>a</code></span><span> and </span><span><code>b</code></span><span> contain the same values, and </span><span><code>b</code></span><span> is a subtype of </span><span><code>a</code></span><span>, but </span><span><code>a</code></span><span> is not a subtype of </span><span><code>b</code></span><span> according to our </span><span><code>isSubtype</code></span><span> function. The problem is that we have to commit to a type of </span><span><code>foo</code></span><span> too early by choosing one of the arms of </span><span><code>b</code></span><span>. One approach might be to distribute object expressions over unions before (or maybe simultaneously with) checking subtyping; but let&#x27;s move on for now. (Actual TypeScript does better hereâ€”I don&#x27;t know what algorithm it uses.)</span></p><h2 id="checking-against-union-types"><span>Checking against union types</span></h2><p><span>Recall that we have two motivations for checking expressions against types:</span></p><ul><li><p><span>to produce more localized error messages (see </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0#checking-an-expression-against-a-type"><span>part 0</span></a><span>)</span></p></li><li><p><span>to avoid needing type annotations on function arguments (see </span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2#checking-function-expressions-against-function-types"><span>part 2</span></a><span>)</span></p></li></ul><p><span>For union types, we could implement a checking rule like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">checkUnion</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>Expression<span class="sc-jJMGnK laKGqb">,</span> type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">.</span>Union<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">let</span> error<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">unknown</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-gXfVKN jKLUHq">undefined</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">for</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">const</span> t <span class="sc-gXfVKN jKLUHq">of</span> type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-gXfVKN jKLUHq">type</span>s<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">try</span> <span class="sc-jJMGnK laKGqb">{</span>
      <span class="sc-jcwpoC kyvWZW">check</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">,</span> t<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">return</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-jJMGnK laKGqb">}</span>
    <span class="sc-gXfVKN jKLUHq">catch</span> <span class="sc-jJMGnK laKGqb">(</span>e<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">!</span>error<span class="sc-jJMGnK laKGqb">)</span> error <span class="sc-jJMGnK laKGqb">=</span> e<span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-jJMGnK laKGqb">}</span>
  <span class="sc-jJMGnK laKGqb">}</span>
  <span class="sc-gXfVKN jKLUHq">throw</span> error<span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>That is, try to check the expression against each arm of the union; if any arm succeeds, then the expression satisfies the union type. If no arm succeeds, throw the exception we got for the first arm.</span></p><p><span>This might let us avoid type annotations on function arguments when the expression satisfies the union type. But when the expression doesn&#x27;t satisfy the union type, the error message is much worse. For example, in</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">vector</span> <span class="sc-jJMGnK laKGqb">=</span>
  <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;cartesian&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span>
    <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;polar&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> angle<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> magnitude<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">const</span> v<span class="sc-jJMGnK laKGqb">:</span> vector <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;polar&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> angle<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jJMGnK laKGqb">...</span><span class="sc-jJMGnK laKGqb">,</span> mangitude<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jJMGnK laKGqb">...</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>(where we&#x27;re trying to make a </span><span><code>&#x27;polar&#x27;</code></span><span> vector but misspell the </span><span><code>magnitude</code></span><span> property) we&#x27;d get an error like </span><span><code>&#x27;polar&#x27; is not a subtype of &#x27;cartesian&#x27;</code></span><span>, because that&#x27;s the exception we get when trying to check the expression against the first arm.</span></p><p><span>We could come up with a fancier scheme hereâ€”maybe score the arms by how closely they match the expression?â€”but for now we&#x27;ll just fall back as usual to the default: synthesize a type from the expression, then check that it&#x27;s a subtype of the union type. That way we get a more useful error like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;polar&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> angle<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> mangitude<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-gXfVKN jKLUHq">is</span> not a subtype <span class="sc-gXfVKN jKLUHq">of</span>
  <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;cartesian&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> x<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> y<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span>
    <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;polar&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> angle<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> magnitude<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><h2 id="try-it"><span>Try it!</span></h2><p><span>You can try out the type checker below. Click on an example button or type an expression in the top box. In the bottom box you&#x27;ll see a trace of the type checker execution, ending in a synthesized type (or an error). The trace is a tree of function calls; click on a function call to expand the tree under that call, or mouse over a call to highlight the matching return value.</span></p><p><span>Anonymous functions passed to </span><span><code>Type.map</code></span><span> are labelled to match the enclosing function; and since they usually close over the subexpression AST, they&#x27;re annotated with the AST for context. So the anonymous function in </span><span><code>synthBinary</code></span><span> for an addition is labelled </span><span><code>...synthBinary[_ + _]</code></span><span>.</span></p><p><span>The only way to create union types in the current language fragment is with type ascription.</span></p><p><span>Notice the quadratic blowup in the </span><span><code>+</code></span><span> exampleâ€”maybe this is why actual TypeScript doesn&#x27;t synthesize singleton types for arithmetic operators?</span></p><iframe src="https://jaked.org/reconstructing-typescript/part4/" width="700" height="500" style="border-style:none"></iframe><h2 id="the-plan"><span>The plan</span></h2><p><span>For the full code of part 4 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part4" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part4</span></a><span>. To view the changes between part 3 and part 4 see </span><a href="https://github.com/jaked/reconstructing-typescript/compare/part3...part4" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/compare/part3...part4</span></a><span>.</span></p><p><span>Next time we&#x27;ll add </span><span><em>intersection</em></span><span> types, on the way to implementing narrowing.</span></p><ul><li><p><span></span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>Part 0: intro and background</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>Part 1: bidirectional type checking</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>Part 2: functions and function calls</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-06-Reconstructing-TypeScript-part-3"><span>Part 3: operators and singleton types</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4"><span>Part 4: union types</span></a><span></span></p></li><li><p><span>Part 5: intersection types</span></p></li><li><p><span>Part 6: narrowing</span></p></li></ul><p><span>Please </span><a href="/blog/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p></div></body></html>