<html><head><title>Reconstructing TypeScript (part 1)</title><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/unpublished/2021-08-20-Reconstructing-TypeScript-part-1.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.fUzHPW{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"fUzHPW,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.laKGqb{color:#770088;}/*!sc*/
data-styled.g38[id="sc-jJMGnK"]{content:"laKGqb,"}/*!sc*/
.dRsyqq{color:#000000;}/*!sc*/
data-styled.g39[id="sc-hiKfDv"]{content:"dRsyqq,"}/*!sc*/
.jKLUHq{color:#aa1111;}/*!sc*/
data-styled.g40[id="sc-gXfVKN"]{content:"jKLUHq,"}/*!sc*/
.lRfdj{color:#268bd2;}/*!sc*/
data-styled.g41[id="sc-cBoqAE"]{content:"lRfdj,"}/*!sc*/
.bwSYJA{color:#b58900;}/*!sc*/
data-styled.g42[id="sc-ciSkZP"]{content:"bwSYJA,"}/*!sc*/
.kyvWZW{color:#116644;}/*!sc*/
data-styled.g43[id="sc-jcwpoC"]{content:"kyvWZW,"}/*!sc*/
.hBWCUB{color:#6f42c1;}/*!sc*/
data-styled.g44[id="sc-carFqZ"]{content:"hBWCUB,"}/*!sc*/
.oxVOu{color:#221199;}/*!sc*/
data-styled.g45[id="sc-iTVJFM"]{content:"oxVOu,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript (part 1)</span></p><h1><span>Reconstructing TypeScript (part 1)</span></h1><h3><span><em>2021-08-20</em></span></h3><p><span>I&#x27;ve been building a &quot;document development environment&quot; called </span><a href="https://github.com/jaked/programmable-matter" class="sc-gtsrHT kFWJEY"><span>Programmable Matter</span></a><span> that supports live code embedded in documents, with a simple TypeScript-like programming language. It&#x27;s been fun figuring out how to implement it—the type system in </span><a href="https://www.typescriptlang.org/" class="sc-gtsrHT kFWJEY"><span>TypeScript</span></a><span> is unusual and very cool!</span></p><p><span>I want to dig into what&#x27;s cool and unusual about TypeScript by presenting a type checker for a fragment of this language (written in actual TypeScript). I&#x27;ll start with a tiny fragment and build it up over several posts. But first:</span></p><h2><span>What&#x27;s a type checker?</span></h2><p><span>You&#x27;ve probably used a type checker, and have an idea what &quot;type&quot; and &quot;type checking&quot; mean. But I want to unpack these concepts a little:</span></p><p><span>In JavaScript, a variable can hold values of different types. Suppose we don&#x27;t know what type </span><span><code>x</code></span><span> holds—maybe we know it&#x27;s a </span><span><code>string</code></span><span> or a </span><span><code>boolean</code></span><span> but not which one. If we test the type</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span><span class="sc-jJMGnK laKGqb">typeof</span> x <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;string&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-hiKfDv dRsyqq">...</span>
<span class="sc-hiKfDv dRsyqq">}</span> <span class="sc-jJMGnK laKGqb">else</span> <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-hiKfDv dRsyqq">...</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>then we can reason (at development time) that if the test succeeds (at run time) the value must have type </span><span><code>string</code></span><span>; so we can safely treat </span><span><code>x</code></span><span> as a </span><span><code>string</code></span><span> in the true branch (and a </span><span><code>boolean</code></span><span> in the false branch).</span></p><p><span>As programmers, reasoning about the behavior of programs is our main job! We mostly do it in our heads, but it&#x27;s really useful to automate it—to catch mistakes, and to support interactive development features like code completion. This is where a type checker comes in: it&#x27;s a way to reason automatically at development time about the behavior of programs at run time.</span></p><p><span>Our human reasoning can be arbitrarily creative and complex, but a type checker is just a program, so its &quot;reasoning&quot; is limited. For our purpose, a type checker just ensures that a program doesn&#x27;t attempt any unsupported operations on values (such as accessing a property that doesn&#x27;t exist on an object).</span></p><p><span>Since a type checker runs at development time, it can&#x27;t know the actual values flowing through a program at run time. Instead, for each expression in the program, it lumps together the values that might be computed by the expression, and gives the expression a type that describes operations supported on all the values. For example, in</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">const</span> vec <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span> x<span class="sc-hiKfDv dRsyqq">:</span> x<span class="sc-hiKfDv dRsyqq">,</span> y<span class="sc-hiKfDv dRsyqq">:</span> y <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">;</span></code></pre><p><span>if </span><span><code>x</code></span><span> and </span><span><code>y</code></span><span> have type </span><span><code>number</code></span><span>, then </span><span><code>vec</code></span><span> has type</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-hiKfDv dRsyqq">{</span> x<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">number</span><span class="sc-hiKfDv dRsyqq">,</span> y<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">number</span> <span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>meaning that it supports accessing the </span><span><code>x</code></span><span> or </span><span><code>y</code></span><span> property (and further that the properties are </span><span><code>number</code></span><span>). </span><span><code>x</code></span><span> and </span><span><code>y</code></span><span> may take on many different values as the program runs, so </span><span><code>vec</code></span><span> may also take on many values; all such values support accessing the </span><span><code>x</code></span><span> or </span><span><code>y</code></span><span> property.</span></p><p><span>Now, if the program contains an expression </span><span><code>vec.z</code></span><span>, we can see from the type of </span><span><code>point</code></span><span> that this is an unsupported operation. So a type checker ensures that a program doesn&#x27;t attempt any unsupported operations on </span><span><em>concrete values at run time</em></span><span> by checking that it doesn&#x27;t attempt any unsupported operations on </span><span><em>expression types at development time</em></span><span>.</span></p><h2><span>What&#x27;s cool about TypeScript?</span></h2><p><span>In most type systems, primitive types can&#x27;t be mixed, so a variable can&#x27;t hold either </span><span><code>string</code></span><span> or </span><span><code>boolean</code></span><span>. But there&#x27;s usually a way to mix certain compound types and test the type of a value. In a language with classes and objects, a variable of class </span><span><code>Shape</code></span><span> can hold objects of subclasses </span><span><code>Circle</code></span><span> or </span><span><code>Square</code></span><span>, and we can test the class of the object with </span><span><code>instanceof</code></span><span> (or some equivalent). Or in a language with variant types (aka sums or tagged unions), a variable of type </span><span><code>Tree</code></span><span> can hold values of variant arms </span><span><code>Leaf</code></span><span> or </span><span><code>Node</code></span><span>, and we can learn what arm a value is by pattern-matching.</span></p><p><span>In TypeScript, any types can be mixed. If we know that </span><span><code>x</code></span><span> holds a </span><span><code>string</code></span><span> or a </span><span><code>boolean</code></span><span> we can give it a </span><span><em>union</em></span><span> type, </span><span><code>string | boolean</code></span><span>. When we test the type in the example above, the type checker </span><span><em>narrows</em></span><span> the type of </span><span><code>x</code></span><span> in the branches of the </span><span><code>if</code></span><span> / </span><span><code>else</code></span><span> according to the result of the test: in the true branch, </span><span><code>x</code></span><span> has type </span><span><code>string</code></span><span>; in the false branch, </span><span><code>boolean</code></span><span> (if a </span><span><code>string | boolean</code></span><span> is not </span><span><code>string</code></span><span> it must be </span><span><code>boolean</code></span><span>).</span></p><p><span>This idea goes pretty far—for example, we can define a variant-like tree type as a union of leaf and node objects:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">type</span> <span class="sc-hiKfDv dRsyqq">tree</span> <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span> value<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">number</span> <span class="sc-hiKfDv dRsyqq">}</span> <span class="sc-hiKfDv dRsyqq">|</span> <span class="sc-hiKfDv dRsyqq">{</span> left<span class="sc-hiKfDv dRsyqq">:</span> tree<span class="sc-hiKfDv dRsyqq">,</span> right<span class="sc-hiKfDv dRsyqq">:</span> tree <span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>and TypeScript checks that it&#x27;s safe to use the </span><span><code>left</code></span><span> and </span><span><code>right</code></span><span> fields after we check the presence of the </span><span><code>value</code></span><span> field:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">height</span><span class="sc-hiKfDv dRsyqq">(</span>t<span class="sc-hiKfDv dRsyqq">:</span> tree<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">number</span> <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span><span class="sc-gXfVKN jKLUHq">&#x27;value&#x27;</span> <span class="sc-jJMGnK laKGqb">in</span> t<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-jcwpoC kyvWZW">1</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">else</span> <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-jcwpoC kyvWZW">1</span> <span class="sc-hiKfDv dRsyqq">+</span> Math<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">max</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-ciSkZP bwSYJA">height</span><span class="sc-hiKfDv dRsyqq">(</span>t<span class="sc-hiKfDv dRsyqq">.</span>left<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">,</span> <span class="sc-ciSkZP bwSYJA">height</span><span class="sc-hiKfDv dRsyqq">(</span>t<span class="sc-hiKfDv dRsyqq">.</span>right<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>I like programming with union types and narrowing a lot. They make it possible to get useful checking of typical JavaScript idioms that depend on run-time type tests, so it&#x27;s straightforward to translate most JavaScript code to TypeScript. And unions are an appealing alternative to variant types or class hierarchies, because they&#x27;re simpler and more flexible. (I&#x27;ll give some examples along the way to justify this claim.)</span></p><h2><span>Reconstructing TypeScript</span></h2><p><span>I have to confess—I don&#x27;t know how actual TypeScript works! There isn&#x27;t an </span><a href="https://github.com/Microsoft/TypeScript/issues/15711" class="sc-gtsrHT kFWJEY"><span>up-to-date specification</span></a><span> of how it&#x27;s supposed to work, and I haven&#x27;t tried to read the implementation. Also, the language in Programmable Matter fills a pretty different niche from actual TypeScript, so I&#x27;ve chosen to diverge from it in several ways.</span></p><p><span>What I&#x27;ll present here is a reconstruction of TypeScript, based on TypeScript&#x27;s informal documentation, experimenting with the actual TypeScript implementation, research papers about related systems, background knowledge about implementing type checkers, and my own opinions on how it should work. (I&#x27;ll point out interesting differences between this reconstruction and actual TypeScript along the way.)</span></p><h2><span>Bidirectional type checking</span></h2><p><span>As above, a type checker needs to know the type of every expression in a program, so it can check that the program doesn&#x27;t attempt any unsupported operations.</span></p><p><span>Often we can </span><span><em>synthesize</em></span><span> a type from an expression. The type of primitive expressions is easy: </span><span><code>&quot;foo&quot;</code></span><span> has type </span><span><code>string</code></span><span>, </span><span><code>true</code></span><span> has type </span><span><code>boolean</code></span><span>, and so on. For a compound expression, we can find the types of its subexpressions, then combine them according to the top-level operation of the expression—if </span><span><code>x</code></span><span> and </span><span><code>y</code></span><span> have type </span><span><code>number</code></span><span> then</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-hiKfDv dRsyqq">{</span> x<span class="sc-hiKfDv dRsyqq">:</span> x<span class="sc-hiKfDv dRsyqq">,</span> y<span class="sc-hiKfDv dRsyqq">:</span> y <span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>has type</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-hiKfDv dRsyqq">{</span> x<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">number</span><span class="sc-hiKfDv dRsyqq">,</span> y<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">number</span> <span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>When we synthesize a type from an expression, the type describes operations supported by values computed by the expression.</span></p><p><span>Sometimes we expect an expression to have a certain type based on context; then, instead of synthesizing, we can </span><span><em>check</em></span><span> an expression against the type: break down the expression and type, and recursively check each expression part against each type part; when we reach an expression that can&#x27;t be broken down, synthesize its type and compare it against the expected type. For example, when type checking a function call:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">type</span> <span class="sc-hiKfDv dRsyqq">vector</span> <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span> x<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">number</span><span class="sc-hiKfDv dRsyqq">,</span> y<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">number</span> <span class="sc-hiKfDv dRsyqq">}</span>

<span class="sc-jJMGnK laKGqb">const</span> <span class="sc-carFqZ hBWCUB">magnitude</span> <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">(</span>v<span class="sc-hiKfDv dRsyqq">:</span> vector<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">=&gt;</span> Math<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">sqrt</span><span class="sc-hiKfDv dRsyqq">(</span>v<span class="sc-hiKfDv dRsyqq">.</span>x <span class="sc-hiKfDv dRsyqq">*</span> v<span class="sc-hiKfDv dRsyqq">.</span>x <span class="sc-hiKfDv dRsyqq">+</span> v<span class="sc-hiKfDv dRsyqq">.</span>y <span class="sc-hiKfDv dRsyqq">*</span> v<span class="sc-hiKfDv dRsyqq">.</span>y<span class="sc-hiKfDv dRsyqq">)</span>

<span class="sc-jJMGnK laKGqb">const</span> m <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-ciSkZP bwSYJA">magnitude</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">{</span> x<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-jcwpoC kyvWZW">7</span><span class="sc-hiKfDv dRsyqq">,</span> y<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-gXfVKN jKLUHq">&quot;nine&quot;</span> <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span></code></pre><p><span>we break down the function argument and its expected type, then check </span><span><code>7</code></span><span> against </span><span><code>number</code></span><span> and </span><span><code>&quot;nine&quot;</code></span><span> against </span><span><code>number</code></span><span> (so discover a type error). When we check an expression against a type, we check that the operations supported by the type are also supported by values computed by the expression.</span></p><p><span>This approach—synthesize a type from an expression when we don&#x27;t know what type to expect, check an expression against a type when we do—is called </span><span><em>bidirectional type checking</em></span><span>, so named because type information flows in two directions in the AST: from leaves to root when synthesizing, from root to leaves when checking. Actual TypeScript mostly follows this approach, so that&#x27;s what we&#x27;ll do.</span></p><p><span>Now let&#x27;s write a type checker! (For the full code of part 1 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part1" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part1</span></a><span>.)</span></p><h2><span>Representing types</span></h2><p><span>In this first fragment we&#x27;ll support only a few types—primitives and objects made up of properties (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/types.ts" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">type</span> <span class="sc-hiKfDv dRsyqq">Type</span> <span class="sc-hiKfDv dRsyqq">=</span> Null <span class="sc-hiKfDv dRsyqq">|</span> Boolean <span class="sc-hiKfDv dRsyqq">|</span> Number <span class="sc-hiKfDv dRsyqq">|</span> String <span class="sc-hiKfDv dRsyqq">|</span> Object<span class="sc-hiKfDv dRsyqq">;</span>

<span class="sc-jJMGnK laKGqb">type</span> <span class="sc-hiKfDv dRsyqq">Null</span> <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span> type<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Null&#x27;</span><span class="sc-hiKfDv dRsyqq">;</span> <span class="sc-hiKfDv dRsyqq">}</span>
<span class="sc-jJMGnK laKGqb">type</span> <span class="sc-hiKfDv dRsyqq">Boolean</span> <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span> type<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Boolean&#x27;</span><span class="sc-hiKfDv dRsyqq">;</span> <span class="sc-hiKfDv dRsyqq">}</span>
<span class="sc-jJMGnK laKGqb">type</span> <span class="sc-hiKfDv dRsyqq">Number</span> <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span> type<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Number&#x27;</span><span class="sc-hiKfDv dRsyqq">;</span> <span class="sc-hiKfDv dRsyqq">}</span>
<span class="sc-jJMGnK laKGqb">type</span> <span class="sc-hiKfDv dRsyqq">String</span> <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span> type<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;String&#x27;</span><span class="sc-hiKfDv dRsyqq">;</span> <span class="sc-hiKfDv dRsyqq">}</span>

<span class="sc-jJMGnK laKGqb">type</span> <span class="sc-hiKfDv dRsyqq">Object</span> <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span>
  type<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Object&#x27;</span><span class="sc-hiKfDv dRsyqq">;</span>
  properties<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-hiKfDv dRsyqq">{</span> name<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">string</span><span class="sc-hiKfDv dRsyqq">,</span> type<span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">[</span><span class="sc-hiKfDv dRsyqq">]</span><span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>(We don&#x27;t have an </span><span><code>any</code></span><span> type. In actual TypeScript </span><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any" class="sc-gtsrHT kFWJEY"><span><code>any</code></span><span> is an escape hatch from type checking</span></a><span>, to accommodate existing JavaScript that doesn&#x27;t fit into the type system; here we won&#x27;t provide any escape hatches.)</span></p><p><span>When consuming types we&#x27;ll work directly with these objects; but we have helper functions to construct them (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/constructors.ts" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">const</span> nullType<span class="sc-hiKfDv dRsyqq">:</span> Null <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span> type<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Null&#x27;</span> <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-jJMGnK laKGqb">const</span> <span class="sc-cBoqAE lRfdj">boolean</span><span class="sc-hiKfDv dRsyqq">:</span> Boolean <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span> type<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Boolean&#x27;</span> <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-jJMGnK laKGqb">const</span> <span class="sc-cBoqAE lRfdj">number</span><span class="sc-hiKfDv dRsyqq">:</span> Number <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span> type<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Number&#x27;</span> <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-jJMGnK laKGqb">const</span> <span class="sc-cBoqAE lRfdj">string</span><span class="sc-hiKfDv dRsyqq">:</span> String <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-hiKfDv dRsyqq">{</span> type<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;String&#x27;</span> <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">;</span></code></pre><p><span>We represent object properties as an array, but it&#x27;s often convenient to construct object types by passing an object mapping names to types:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">const</span> type <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-ciSkZP bwSYJA">object</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">{</span> foo<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">boolean</span><span class="sc-hiKfDv dRsyqq">,</span> bar<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">string</span> <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span></code></pre><p><span>so the </span><span><code>object</code></span><span> constructor takes either:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">object</span><span class="sc-hiKfDv dRsyqq">(</span>
  properties<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-hiKfDv dRsyqq">{</span> name<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">string</span><span class="sc-hiKfDv dRsyqq">,</span> type<span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">[</span><span class="sc-hiKfDv dRsyqq">]</span> <span class="sc-hiKfDv dRsyqq">|</span> <span class="sc-hiKfDv dRsyqq">{</span> <span class="sc-hiKfDv dRsyqq">[</span>name<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">string</span><span class="sc-hiKfDv dRsyqq">]</span><span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">}</span>
<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> Object <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span><span class="sc-cBoqAE lRfdj">Array</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">isArray</span><span class="sc-hiKfDv dRsyqq">(</span>properties<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">{</span>
    <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-hiKfDv dRsyqq">{</span> type<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-gXfVKN jKLUHq">&#x27;Object&#x27;</span><span class="sc-hiKfDv dRsyqq">,</span> properties <span class="sc-hiKfDv dRsyqq">}</span>
  <span class="sc-hiKfDv dRsyqq">}</span> <span class="sc-jJMGnK laKGqb">else</span> <span class="sc-hiKfDv dRsyqq">{</span>
    <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-ciSkZP bwSYJA">object</span><span class="sc-hiKfDv dRsyqq">(</span>
      Object<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">entries</span><span class="sc-hiKfDv dRsyqq">(</span>properties<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">map</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">[</span> name<span class="sc-hiKfDv dRsyqq">,</span> type <span class="sc-hiKfDv dRsyqq">]</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">=&gt;</span> <span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">{</span> name<span class="sc-hiKfDv dRsyqq">,</span> <span class="sc-jJMGnK laKGqb">type</span> <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">)</span>
    <span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-hiKfDv dRsyqq">}</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>This is a nice example of the flexibility of union types: rather than define a separate function to convert an object argument to an array, we give the argument a union type.</span></p><p><span>We wrap constructors and other type-related functions into a module (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/index.ts" class="sc-gtsrHT kFWJEY"><span>type/index.ts</span></a><span>) so we can write </span><span><code>Type.object</code></span><span>, </span><span><code>Type.toString</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/toString.ts" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span>), and so on.</span></p><h2><span>Parsing code</span></h2><p><span>To parse code into an abstract syntax tree we&#x27;ll use </span><a href="https://babeljs.io/docs/en/babel-parser" class="sc-gtsrHT kFWJEY"><span>@babel/parser</span></a><span>, which parses JavaScript with TypeScript extensions to a </span><a href="https://babeljs.io/docs/en/babel-types" class="sc-gtsrHT kFWJEY"><span>@babel/types</span></a><span> AST (with </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts" class="sc-gtsrHT kFWJEY"><span>this TypeScript type</span></a><span>).</span></p><p><span>To keep things simple we&#x27;ll handle only </span><span><code>Expression</code></span><span> nodes in the AST (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/ast/parse.ts" class="sc-gtsrHT kFWJEY"><span>parse.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">parseExpression</span><span class="sc-hiKfDv dRsyqq">(</span>input<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">string</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> Expression <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-jJMGnK laKGqb">return</span> Babel<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">parseExpression</span><span class="sc-hiKfDv dRsyqq">(</span>input<span class="sc-hiKfDv dRsyqq">,</span> <span class="sc-hiKfDv dRsyqq">{</span>
    plugins<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-hiKfDv dRsyqq">[</span> <span class="sc-gXfVKN jKLUHq">&#x27;typescript&#x27;</span> <span class="sc-hiKfDv dRsyqq">]</span>
  <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>For writing tests it&#x27;s convenient to be able to parse types separately:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">parseType</span><span class="sc-hiKfDv dRsyqq">(</span>input<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">string</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-jJMGnK laKGqb">const</span> ast <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-ciSkZP bwSYJA">parseExpression</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">_ as </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">input</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">!==</span> <span class="sc-gXfVKN jKLUHq">&#x27;TSAsExpression&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">unexpected </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">ast</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-jJMGnK laKGqb">type</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">return</span> Type<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">ofTSType</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-jJMGnK laKGqb">type</span>Annotation<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>Here </span><span><code>Type.ofTSType</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/ofTSType.ts" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span>) converts a Babel </span><span><code>TSType</code></span><span> AST to our </span><span><code>Type</code></span><span> representation, and </span><span><code>bug</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) throws an exception.</span></p><p><span>The call to </span><span><code>bug</code></span><span> shows a use of narrowing: the return type of </span><span><code>bug</code></span><span> is </span><span><code>never</code></span><span>, meaning that the function never returns a value (it throws an exception), so the TypeScript type checker reasons that in the remainder of the function, </span><span><code>ast.type !== &#x27;TSAsExpression&#x27;</code></span><span> must be false. Therefore </span><span><code>ast.type === &#x27;TSAsExpression&#x27;</code></span><span> and we can safely access </span><span><code>typeAnnotation</code></span><span>.</span></p><p><span>It&#x27;s really helpful to be able to browse the AST produced by a piece of code. I use the excellent </span><a href="https://astexplorer.net/" class="sc-gtsrHT kFWJEY"><span>AST Explorer</span></a><span> for this—set the language to &quot;JavaScript&quot; and the parser to &quot;@babel/parser&quot;; TypeScript extensions are parsed without special configuration.</span></p><h2><span>Synthesizing types from expressions</span></h2><p><span>In this first fragment we&#x27;ll support only a few kinds of expression: primitive literals, object literals (like </span><span><code>{ x: x, y: y }</code></span><span>), and member expressions (like </span><span><code>vec.x</code></span><span>). To synthesize the type of an expression, we first case over the expression type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/synth.ts" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">synth</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">:</span> Expression<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-jJMGnK laKGqb">switch</span> <span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">.</span>type<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">{</span>
    <span class="sc-jJMGnK laKGqb">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;NullLiteral&#x27;</span><span class="sc-hiKfDv dRsyqq">:</span>      <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-ciSkZP bwSYJA">synthNull</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-jJMGnK laKGqb">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;BooleanLiteral&#x27;</span><span class="sc-hiKfDv dRsyqq">:</span>   <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-ciSkZP bwSYJA">synthBoolean</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-jJMGnK laKGqb">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;NumericLiteral&#x27;</span><span class="sc-hiKfDv dRsyqq">:</span>   <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-ciSkZP bwSYJA">synthNumber</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-jJMGnK laKGqb">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;StringLiteral&#x27;</span><span class="sc-hiKfDv dRsyqq">:</span>    <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-ciSkZP bwSYJA">synthString</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-jJMGnK laKGqb">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;ObjectExpression&#x27;</span><span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-ciSkZP bwSYJA">synthObject</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-jJMGnK laKGqb">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;MemberExpression&#x27;</span><span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-ciSkZP bwSYJA">synthMember</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-jJMGnK laKGqb">case</span> <span class="sc-gXfVKN jKLUHq">&#x27;TSAsExpression&#x27;</span><span class="sc-hiKfDv dRsyqq">:</span>   <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-ciSkZP bwSYJA">synthTSAs</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>

    <span class="sc-jJMGnK laKGqb">default</span><span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">ast</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-jJMGnK laKGqb">type</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-hiKfDv dRsyqq">}</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>For primitive literals we return the corresponding type:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">synthNull</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">:</span> NullLiteral<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">{</span> <span class="sc-jJMGnK laKGqb">return</span> Type<span class="sc-hiKfDv dRsyqq">.</span>nullType<span class="sc-hiKfDv dRsyqq">;</span> <span class="sc-hiKfDv dRsyqq">}</span>
<span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">synthBoolean</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">:</span> BooleanLiteral<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">{</span> <span class="sc-jJMGnK laKGqb">return</span> Type<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-cBoqAE lRfdj">boolean</span><span class="sc-hiKfDv dRsyqq">;</span> <span class="sc-hiKfDv dRsyqq">}</span>
<span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">synthNumber</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">:</span> NumericLiteral<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">{</span> <span class="sc-jJMGnK laKGqb">return</span> Type<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-cBoqAE lRfdj">number</span><span class="sc-hiKfDv dRsyqq">;</span> <span class="sc-hiKfDv dRsyqq">}</span>
<span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">synthString</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">:</span> StringLiteral<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">{</span> <span class="sc-jJMGnK laKGqb">return</span> Type<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-cBoqAE lRfdj">string</span><span class="sc-hiKfDv dRsyqq">;</span> <span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>For object expressions, we synthesize a type for each property value expression, then return an object type mapping property names to types:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">synthObject</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">:</span> ObjectExpression<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-jJMGnK laKGqb">const</span> properties <span class="sc-hiKfDv dRsyqq">=</span>
    ast<span class="sc-hiKfDv dRsyqq">.</span>properties<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">map</span><span class="sc-hiKfDv dRsyqq">(</span>prop <span class="sc-hiKfDv dRsyqq">=&gt;</span> <span class="sc-hiKfDv dRsyqq">{</span>
      <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>prop<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">!==</span> <span class="sc-gXfVKN jKLUHq">&#x27;ObjectProperty&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">prop</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-jJMGnK laKGqb">type</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
      <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>prop<span class="sc-hiKfDv dRsyqq">.</span>computed<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">unimplemented computed</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
      <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>prop<span class="sc-hiKfDv dRsyqq">.</span>key<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">!==</span> <span class="sc-gXfVKN jKLUHq">&#x27;Identifier&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">prop</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-hiKfDv dRsyqq">key</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-jJMGnK laKGqb">type</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
      <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-hiKfDv dRsyqq">{</span>
        name<span class="sc-hiKfDv dRsyqq">:</span> prop<span class="sc-hiKfDv dRsyqq">.</span>key<span class="sc-hiKfDv dRsyqq">.</span>name<span class="sc-hiKfDv dRsyqq">,</span>
        type<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-ciSkZP bwSYJA">synth</span><span class="sc-hiKfDv dRsyqq">(</span>prop<span class="sc-hiKfDv dRsyqq">.</span>value <span class="sc-jJMGnK laKGqb">as</span> Expression<span class="sc-hiKfDv dRsyqq">)</span>
      <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">return</span> Type<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">object</span><span class="sc-hiKfDv dRsyqq">(</span>properties<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>We call </span><span><code>bug(`unimplemented`)</code></span><span> when the object expression contains the spread operator (</span><span><code>...</code></span><span>) or a computed property name (</span><span><code>[name]: value</code></span><span>). (We&#x27;re obliged to cast </span><span><code>prop.value</code></span><span> here because the Babel AST type is imprecise—it uses </span><span><code>ObjectProperty</code></span><span> for both </span><span><code>ObjectExpression</code></span><span>s and </span><span><code>ObjectPattern</code></span><span>s, so permits non-</span><span><code>Expression</code></span><span> pattern nodes, even though they don&#x27;t actually appear.)</span></p><p><span>For member expressions, we synthesize the type of the left-hand side, check that it&#x27;s an object that contains the named member, and return the type of the member. We call </span><span><code>err</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) to raise an exception if these checks fail.</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">synthMember</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">:</span> MemberExpression<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">.</span>computed<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">unimplemented computed</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">const</span> prop <span class="sc-hiKfDv dRsyqq">=</span> ast<span class="sc-hiKfDv dRsyqq">.</span>property<span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>prop<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">!==</span> <span class="sc-gXfVKN jKLUHq">&#x27;Identifier&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">prop</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-jJMGnK laKGqb">type</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">const</span> object <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-ciSkZP bwSYJA">synth</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">.</span>object<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>object<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">!==</span> <span class="sc-gXfVKN jKLUHq">&#x27;Object&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">err</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-gXfVKN jKLUHq">&#x27;. expects object&#x27;</span><span class="sc-hiKfDv dRsyqq">,</span> ast<span class="sc-hiKfDv dRsyqq">.</span>object<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">const</span> <span class="sc-jJMGnK laKGqb">type</span>Prop <span class="sc-hiKfDv dRsyqq">=</span>
    object<span class="sc-hiKfDv dRsyqq">.</span>properties<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">find</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">{</span> name<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-jJMGnK laKGqb">type</span>Name <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">=&gt;</span> <span class="sc-jJMGnK laKGqb">type</span>Name <span class="sc-hiKfDv dRsyqq">===</span> prop<span class="sc-hiKfDv dRsyqq">.</span>name<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">!</span><span class="sc-jJMGnK laKGqb">type</span>Prop<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">err</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">no such property </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">prop</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-hiKfDv dRsyqq">name</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">,</span> prop<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-jJMGnK laKGqb">type</span>Prop<span class="sc-hiKfDv dRsyqq">.</span>type<span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>Again we don&#x27;t implement computed property names.</span></p><p><span>Finally for </span><span><code>as</code></span><span> expressions we synthesize by checking the expression against the given type:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">synthTSAs</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">:</span> TSAsExpression<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> Type <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-jJMGnK laKGqb">const</span> type <span class="sc-hiKfDv dRsyqq">=</span> Type<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">ofTSType</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-jJMGnK laKGqb">type</span>Annotation<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-ciSkZP bwSYJA">check</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">.</span>expression<span class="sc-hiKfDv dRsyqq">,</span> type<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">return</span> type<span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>In actual TypeScript, </span><span><code><em>expression</em></code></span><span><code> as </code></span><span><code><em>type</em></code></span><span> is an unsafe cast; here it&#x27;s a </span><span><em>type ascription</em></span><span> that we can use to direct the type checker to check rather than synthesize a particular expression, but it can&#x27;t cast to an unrelated type.</span></p><h2><span>Checking expressions against types</span></h2><p><span>To check an expression against a type, we first case over the expression and type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/check.ts" class="sc-gtsrHT kFWJEY"><span>check.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">check</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">:</span> Expression<span class="sc-hiKfDv dRsyqq">,</span> type<span class="sc-hiKfDv dRsyqq">:</span> Type<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;ObjectExpression&#x27;</span> <span class="sc-hiKfDv dRsyqq">&amp;&amp;</span> type<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Object&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span>
    <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-ciSkZP bwSYJA">checkObject</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">,</span> type<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>

  <span class="sc-jJMGnK laKGqb">const</span> synthType <span class="sc-hiKfDv dRsyqq">=</span> <span class="sc-ciSkZP bwSYJA">synth</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">!</span>Type<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">isSubtype</span><span class="sc-hiKfDv dRsyqq">(</span>synthType<span class="sc-hiKfDv dRsyqq">,</span> type<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">)</span>
    <span class="sc-ciSkZP bwSYJA">err</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">expected </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">Type</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">toString</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">type</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-gXfVKN jKLUHq">, got </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">Type</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">toString</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">synthType</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">,</span> ast<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>Object expressions are the only ones we can break down in this fragment; we synthesize types for other expressions and compare then with </span><span><code>Type.isSubtype</code></span><span> (more on this below).</span></p><p><span>To check an object expression against an object type, we check the value expression for each property against the corresponding type. We raise an exception if the object expression is missing a property present in the type, or if it has a property that&#x27;s not present in the type.</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">checkObject</span><span class="sc-hiKfDv dRsyqq">(</span>ast<span class="sc-hiKfDv dRsyqq">:</span> ObjectExpression<span class="sc-hiKfDv dRsyqq">,</span> type<span class="sc-hiKfDv dRsyqq">:</span> Type<span class="sc-hiKfDv dRsyqq">.</span>Object<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-jJMGnK laKGqb">const</span> astProps<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-hiKfDv dRsyqq">{</span> name<span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">string</span><span class="sc-hiKfDv dRsyqq">,</span> expr<span class="sc-hiKfDv dRsyqq">:</span> Expression<span class="sc-hiKfDv dRsyqq">,</span> key<span class="sc-hiKfDv dRsyqq">:</span> Identifier <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">[</span><span class="sc-hiKfDv dRsyqq">]</span> <span class="sc-hiKfDv dRsyqq">=</span>
    ast<span class="sc-hiKfDv dRsyqq">.</span>properties<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">map</span><span class="sc-hiKfDv dRsyqq">(</span>prop <span class="sc-hiKfDv dRsyqq">=&gt;</span> <span class="sc-hiKfDv dRsyqq">{</span>
      <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>prop<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">!==</span> <span class="sc-gXfVKN jKLUHq">&#x27;ObjectProperty&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">prop</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-jJMGnK laKGqb">type</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
      <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>prop<span class="sc-hiKfDv dRsyqq">.</span>computed<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">unimplemented computed</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
      <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>prop<span class="sc-hiKfDv dRsyqq">.</span>key<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">!==</span> <span class="sc-gXfVKN jKLUHq">&#x27;Identifier&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">unimplemented </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">prop</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-hiKfDv dRsyqq">key</span><span class="sc-hiKfDv dRsyqq">.</span><span class="sc-jJMGnK laKGqb">type</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
      <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-hiKfDv dRsyqq">{</span>
        name<span class="sc-hiKfDv dRsyqq">:</span> prop<span class="sc-hiKfDv dRsyqq">.</span>key<span class="sc-hiKfDv dRsyqq">.</span>name<span class="sc-hiKfDv dRsyqq">,</span>
        expr<span class="sc-hiKfDv dRsyqq">:</span> prop<span class="sc-hiKfDv dRsyqq">.</span>value <span class="sc-jJMGnK laKGqb">as</span> Expression<span class="sc-hiKfDv dRsyqq">,</span>
        key<span class="sc-hiKfDv dRsyqq">:</span> prop<span class="sc-hiKfDv dRsyqq">.</span>key
      <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>

  type<span class="sc-hiKfDv dRsyqq">.</span>properties<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">forEach</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">{</span> name <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">=&gt;</span> <span class="sc-hiKfDv dRsyqq">{</span>
    <span class="sc-jJMGnK laKGqb">const</span> astProp <span class="sc-hiKfDv dRsyqq">=</span> astProps<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">find</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">{</span> name<span class="sc-hiKfDv dRsyqq">:</span> astName <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">=&gt;</span> astName <span class="sc-hiKfDv dRsyqq">===</span> name<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">!</span>astProp<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">err</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">missing property </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">name</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">,</span> ast<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>

  astProps<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">forEach</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">{</span> name<span class="sc-hiKfDv dRsyqq">,</span> expr<span class="sc-hiKfDv dRsyqq">,</span> key <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">=&gt;</span> <span class="sc-hiKfDv dRsyqq">{</span>
    <span class="sc-jJMGnK laKGqb">const</span> prop <span class="sc-hiKfDv dRsyqq">=</span>
      type<span class="sc-hiKfDv dRsyqq">.</span>properties<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">find</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">{</span> name<span class="sc-hiKfDv dRsyqq">:</span> propName <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">=&gt;</span> propName <span class="sc-hiKfDv dRsyqq">===</span> name<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>prop<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-ciSkZP bwSYJA">check</span><span class="sc-hiKfDv dRsyqq">(</span>expr<span class="sc-hiKfDv dRsyqq">,</span> prop<span class="sc-hiKfDv dRsyqq">.</span>type<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-jJMGnK laKGqb">else</span> <span class="sc-ciSkZP bwSYJA">err</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-gXfVKN jKLUHq">extra property </span><span class="sc-hiKfDv dRsyqq">${</span><span class="sc-hiKfDv dRsyqq">name</span><span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">`</span><span class="sc-hiKfDv dRsyqq">,</span> key<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>Again we don&#x27;t implement spreads or computed property names. </span></p><h2><span>Subtyping</span></h2><p><span>In </span><span><code>check</code></span><span>, when we can&#x27;t break down the expression or type, we synthesize a type and compare it to the expected type. Recall that checking an expression against a type means checking that the expression supports the operations described by the type; recall also that the type synthesized for an expression describes the operations it supports. So, putting these together, to compare types here we need to check that the operations supported by the </span><span><em>expected</em></span><span> type are also supported by the </span><span><em>synthesized</em></span><span> type. When the operations supported by type </span><span><code>B</code></span><span> are also supported by type </span><span><code>A</code></span><span>, we say that </span><span><code>A</code></span><span> is a </span><span><em>subtype</em></span><span> of </span><span><code>B</code></span><span> , or </span><span><code>A &lt;: B</code></span><span>.</span></p><p><span>When </span><span><code>A &lt;: B</code></span><span>, then an operation supported on </span><span><code>B</code></span><span> is also supported on </span><span><code>A</code></span><span>. So it makes sense that subtyping should be reflexive (</span><span><code>A &lt;: A</code></span><span> for any </span><span><code>A</code></span><span>) and transitive (if </span><span><code>A &lt;: B</code></span><span> and </span><span><code>B &lt;: C</code></span><span> then </span><span><code>A &lt;: C</code></span><span> for any </span><span><code>A</code></span><span>, </span><span><code>B</code></span><span>, and </span><span><code>C</code></span><span>).</span></p><p><span>Here&#x27;s a function to check subtyping (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/isSubtype.ts" class="sc-gtsrHT kFWJEY"><span>isSubtype.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-jJMGnK laKGqb">function</span> <span class="sc-ciSkZP bwSYJA">isSubtype</span><span class="sc-hiKfDv dRsyqq">(</span>a<span class="sc-hiKfDv dRsyqq">:</span> Type<span class="sc-hiKfDv dRsyqq">,</span> b<span class="sc-hiKfDv dRsyqq">:</span> Type<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">:</span> <span class="sc-cBoqAE lRfdj">boolean</span> <span class="sc-hiKfDv dRsyqq">{</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>a<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Null&#x27;</span> <span class="sc-hiKfDv dRsyqq">&amp;&amp;</span> b<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Null&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>a<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Boolean&#x27;</span> <span class="sc-hiKfDv dRsyqq">&amp;&amp;</span> b<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Boolean&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>a<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Number&#x27;</span> <span class="sc-hiKfDv dRsyqq">&amp;&amp;</span> b<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Number&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>a<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;String&#x27;</span> <span class="sc-hiKfDv dRsyqq">&amp;&amp;</span> b<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;String&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-hiKfDv dRsyqq">;</span>

  <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span>a<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Object&#x27;</span> <span class="sc-hiKfDv dRsyqq">&amp;&amp;</span> b<span class="sc-hiKfDv dRsyqq">.</span>type <span class="sc-hiKfDv dRsyqq">===</span> <span class="sc-gXfVKN jKLUHq">&#x27;Object&#x27;</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">{</span>
    <span class="sc-jJMGnK laKGqb">return</span> b<span class="sc-hiKfDv dRsyqq">.</span>properties<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">every</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">{</span> name<span class="sc-hiKfDv dRsyqq">:</span> bName<span class="sc-hiKfDv dRsyqq">,</span> type<span class="sc-hiKfDv dRsyqq">:</span> bType <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">=&gt;</span> <span class="sc-hiKfDv dRsyqq">{</span>
      <span class="sc-jJMGnK laKGqb">const</span> aProp <span class="sc-hiKfDv dRsyqq">=</span> a<span class="sc-hiKfDv dRsyqq">.</span>properties<span class="sc-hiKfDv dRsyqq">.</span><span class="sc-ciSkZP bwSYJA">find</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">{</span> name<span class="sc-hiKfDv dRsyqq">:</span> aName <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-hiKfDv dRsyqq">=&gt;</span> aName <span class="sc-hiKfDv dRsyqq">===</span> bName<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
      <span class="sc-jJMGnK laKGqb">if</span> <span class="sc-hiKfDv dRsyqq">(</span><span class="sc-hiKfDv dRsyqq">!</span>aProp<span class="sc-hiKfDv dRsyqq">)</span> <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-iTVJFM oxVOu">false</span><span class="sc-hiKfDv dRsyqq">;</span>
      <span class="sc-jJMGnK laKGqb">else</span> <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-ciSkZP bwSYJA">isSubtype</span><span class="sc-hiKfDv dRsyqq">(</span>aProp<span class="sc-hiKfDv dRsyqq">.</span>type<span class="sc-hiKfDv dRsyqq">,</span> bType<span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
    <span class="sc-hiKfDv dRsyqq">}</span><span class="sc-hiKfDv dRsyqq">)</span><span class="sc-hiKfDv dRsyqq">;</span>
  <span class="sc-hiKfDv dRsyqq">}</span>

  <span class="sc-jJMGnK laKGqb">return</span> <span class="sc-iTVJFM oxVOu">false</span><span class="sc-hiKfDv dRsyqq">;</span>
<span class="sc-hiKfDv dRsyqq">}</span></code></pre><p><span>An object type </span><span><code>A</code></span><span> is a subtype of an object type </span><span><code>B</code></span><span> if all the properties we can access on </span><span><code>B</code></span><span> can also be accessed on </span><span><code>A</code></span><span>, and each of those fields in </span><span><code>A</code></span><span> is a subtype of the corresponding field in </span><span><code>B</code></span><span>; the order of fields doesn&#x27;t matter.</span></p><h2><span>Try it!</span></h2><p><span>You can try out the type checker below; it synthesizes a type from the expression, but you can try checking by ascribing a type with </span><span><code>as</code></span><span>. Remember that the only supported expressions in this fragment are primitive literals, object expressions, property accesses, and </span><span><code>as</code></span><span> ascriptions.</span></p><iframe src="https://jaked.org/reconstructing-typescript/part1/" width="700" height="300" style="border-style:none"></iframe><h2><span>Here&#x27;s the plan</span></h2><ul><li><p><span>Part 1: bidirectional type checking</span></p></li><li><p><span>Part 2: functions and function calls</span></p></li><li><p><span>Part 3: singleton / literal types and arithmetic / logical operators</span></p></li><li><p><span>Part 4: union types</span></p></li><li><p><span>Part 5: intersection types</span></p></li><li><p><span>Part 6: narrowing</span></p></li></ul><h2><span>References</span></h2><p><span>On bidirectional type checking see Pierce and Turner, </span><a href="https://www.cis.upenn.edu/~bcpierce/papers/lti-toplas.pdf" class="sc-gtsrHT kFWJEY"><span>Local Type Inference</span></a><span>.</span></p><p><span>The </span><a href="https://github.com/microsoft/TypeScript/blob/main/doc/TypeScript%20Language%20Specification%20-%20ARCHIVED.pdf?raw=true" class="sc-gtsrHT kFWJEY"><span>TypeScript Language Specification</span></a><span> is 5 years out of date but still interesting.</span></p><p><span></span></p><p><span>Please </span><a href="/blog/unpublished/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p></div></body></html>