<html><head><title>Reconstructing TypeScript (part 1)</title><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/unpublished/2021-09-03-Reconstructing-TypeScript-part-1.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.fUzHPW{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"fUzHPW,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.fHUQtx{color:#770088;}/*!sc*/
data-styled.g30[id="sc-cxNHIi"]{content:"fHUQtx,"}/*!sc*/
.hpRDUw{color:#000000;}/*!sc*/
data-styled.g31[id="sc-lmgQwP"]{content:"hpRDUw,"}/*!sc*/
.bojiJp{color:#b58900;}/*!sc*/
data-styled.g32[id="sc-iJCRrE"]{content:"bojiJp,"}/*!sc*/
.bYgUJS{color:#aa1111;}/*!sc*/
data-styled.g33[id="sc-giAqHp"]{content:"bYgUJS,"}/*!sc*/
.fDDjHD{color:#268bd2;}/*!sc*/
data-styled.g35[id="sc-bYwzuL"]{content:"fDDjHD,"}/*!sc*/
.laKGqb{color:#116644;}/*!sc*/
data-styled.g38[id="sc-jJMGnK"]{content:"laKGqb,"}/*!sc*/
.jKLUHq{color:#221199;}/*!sc*/
data-styled.g40[id="sc-gXfVKN"]{content:"jKLUHq,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript (part 1)</span></p><h1><span>Reconstructing TypeScript (part 1): bidirectional type checking</span></h1><h3><span><em>2021-09-03</em></span></h3><p><span>This post is part of a series about implementing type checking for a TypeScript-like lanaguge. In the </span><a href="/blog/unpublished/2021-09-03-Reconstructing-TypeScript-part-0"><span>last post</span></a><span> I gave some background about type checking, TypeScript&#x27;s type system, and the approach we&#x27;ll use, called </span><span><em>bidirectional type checking</em></span><span>.</span></p><p><span>Now let&#x27;s write a type checker! We&#x27;re going to start with a tiny fragment of the language, and build it up incrementally in subsequent posts.</span></p><p><span>For the full code of part 1 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part1" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part1</span></a><span>.</span></p><h2><span>Parsing code into an abstract syntax tree</span></h2><p><span>Recall that type checking works on an </span><span><em>abstract syntax tree</em></span><span>, where each expression in a program is a node, with its subexpressions as children.</span></p><p><span>TypeScript has two main categories of syntax: </span><span><em>expressions</em></span><span> and </span><span><em>statements</em></span><span>. Expressions return a value—here are some expressions:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-lmgQwP hpRDUw">[</span><span class="sc-jJMGnK laKGqb">1</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-jJMGnK laKGqb">2</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-jJMGnK laKGqb">3</span><span class="sc-lmgQwP hpRDUw">]</span>
x <span class="sc-lmgQwP hpRDUw">&gt;</span> <span class="sc-jJMGnK laKGqb">0</span> <span class="sc-lmgQwP hpRDUw">?</span> <span class="sc-jJMGnK laKGqb">1</span><span class="sc-lmgQwP hpRDUw">/</span>x <span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-jJMGnK laKGqb">0</span>
<span class="sc-lmgQwP hpRDUw">(</span>degreesCelsius<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-jJMGnK laKGqb">32</span> <span class="sc-lmgQwP hpRDUw">+</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-jJMGnK laKGqb">9</span><span class="sc-lmgQwP hpRDUw">/</span><span class="sc-jJMGnK laKGqb">5</span> <span class="sc-lmgQwP hpRDUw">*</span> degreesCelsius<span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>Statements don&#x27;t return a value, but have some side-effect—here are some statements:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">const</span> x <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-jJMGnK laKGqb">7</span>
<span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span>x <span class="sc-lmgQwP hpRDUw">&gt;</span> <span class="sc-jJMGnK laKGqb">0</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-jJMGnK laKGqb">1</span><span class="sc-lmgQwP hpRDUw">/</span>x <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-cxNHIi fHUQtx">else</span> <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-jJMGnK laKGqb">0</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-cxNHIi fHUQtx">throw</span> <span class="sc-cxNHIi fHUQtx">new</span> <span class="sc-lmgQwP hpRDUw">Error</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-giAqHp bYgUJS">&#x27;bad thing&#x27;</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>To keep things simple, our language will support only expressions.</span></p><p><span>To parse the text of expressions into an abstract syntax tree, we&#x27;ll use </span><a href="https://babeljs.io/docs/en/babel-parser" class="sc-gtsrHT kFWJEY"><span>@babel/parser</span></a><span>, which produces a </span><a href="https://babeljs.io/docs/en/babel-types" class="sc-gtsrHT kFWJEY"><span>@babel/types</span></a><span> AST satisfying the </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2058" class="sc-gtsrHT kFWJEY"><span><code>Expression</code></span></a><span> type. Fortunately Babel provides a function to parse only expression syntax. Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/ast/parse.ts" class="sc-gtsrHT kFWJEY"><span>parse.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">parseExpression</span><span class="sc-lmgQwP hpRDUw">(</span>input<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Expression <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-cxNHIi fHUQtx">return</span> Babel<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">parseExpression</span><span class="sc-lmgQwP hpRDUw">(</span>input<span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-lmgQwP hpRDUw">{</span>
    plugins<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">[</span> <span class="sc-giAqHp bYgUJS">&#x27;typescript&#x27;</span> <span class="sc-lmgQwP hpRDUw">]</span>
  <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>If we call this function on an object expression</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-jJMGnK laKGqb">7</span><span class="sc-lmgQwP hpRDUw">,</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-jJMGnK laKGqb">9</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>we get an </span><span><code>ObjectExpression</code></span><span> AST with </span><span><code>ObjectProperty</code></span><span> ASTs as children</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-lmgQwP hpRDUw">{</span>
  type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&quot;ObjectExpression&quot;</span><span class="sc-lmgQwP hpRDUw">,</span>
  properties<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">[</span>
    <span class="sc-lmgQwP hpRDUw">{</span>
      type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&quot;ObjectProperty&quot;</span><span class="sc-lmgQwP hpRDUw">,</span>
      key<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&quot;Identifier&quot;</span><span class="sc-lmgQwP hpRDUw">,</span> name<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&quot;x&quot;</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">,</span>
      value<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&quot;NumericLiteral&quot;</span><span class="sc-lmgQwP hpRDUw">,</span> value<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-jJMGnK laKGqb">7</span> <span class="sc-lmgQwP hpRDUw">}</span>
    <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">,</span>
    <span class="sc-lmgQwP hpRDUw">{</span>
      type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&quot;ObjectProperty&quot;</span><span class="sc-lmgQwP hpRDUw">,</span>
      key<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&quot;Identifier&quot;</span><span class="sc-lmgQwP hpRDUw">,</span> name<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&quot;y&quot;</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">,</span>
      value<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&quot;NumericLiteral&quot;</span><span class="sc-lmgQwP hpRDUw">,</span> value<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-jJMGnK laKGqb">9</span> <span class="sc-lmgQwP hpRDUw">}</span>
    <span class="sc-lmgQwP hpRDUw">}</span>
  <span class="sc-lmgQwP hpRDUw">]</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>Each node has a </span><span><code>type</code></span><span> property saying what kind of syntax it represents; each kind of node has specific properties for subexpressions and other attributes. (I&#x27;ve trimmed properties that describe the location in the original code string of each AST node.) </span></p><p><span>It&#x27;s really helpful to be able to browse the AST produced by a piece of code. I use the excellent </span><a href="https://astexplorer.net/" class="sc-gtsrHT kFWJEY"><span>AST Explorer</span></a><span> for this—set the language to &quot;JavaScript&quot; and the parser to &quot;@babel/parser&quot; (TypeScript extensions are parsed without special configuration).</span></p><p><span>Be aware that AST Explorer parses statements, not expressions. Usually it&#x27;s OK to write an expression where a statement is expected, but for object expressions you need to wrap parentheses around them, or else the parser sees </span><span><code>{</code></span><span> and tries to parse a block of statements.</span></p><h2><span>Representing types</span></h2><p><span>To synthesize and check types, we need a way to represent them. In this fragment we&#x27;ll support only a few types—primitives and objects made up of properties (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/types.ts" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">type</span> <span class="sc-lmgQwP hpRDUw">Type</span> <span class="sc-lmgQwP hpRDUw">=</span> Null <span class="sc-lmgQwP hpRDUw">|</span> Boolean <span class="sc-lmgQwP hpRDUw">|</span> Number <span class="sc-lmgQwP hpRDUw">|</span> String <span class="sc-lmgQwP hpRDUw">|</span> Object<span class="sc-lmgQwP hpRDUw">;</span>

<span class="sc-cxNHIi fHUQtx">type</span> <span class="sc-lmgQwP hpRDUw">Null</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&#x27;Null&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-cxNHIi fHUQtx">type</span> <span class="sc-lmgQwP hpRDUw">Boolean</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&#x27;Boolean&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-cxNHIi fHUQtx">type</span> <span class="sc-lmgQwP hpRDUw">Number</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&#x27;Number&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-cxNHIi fHUQtx">type</span> <span class="sc-lmgQwP hpRDUw">String</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&#x27;String&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>

<span class="sc-cxNHIi fHUQtx">type</span> <span class="sc-lmgQwP hpRDUw">Object</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span>
  type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&#x27;Object&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span>
  properties<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> name<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><h3><span>Constructors</span></h3><p><span>It&#x27;s convenient to have some predefined constants and helper functions to construct types (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/constructors.ts" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">const</span> nullType<span class="sc-lmgQwP hpRDUw">:</span> Null <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&#x27;Null&#x27;</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-cxNHIi fHUQtx">const</span> <span class="sc-bYwzuL fDDjHD">boolean</span><span class="sc-lmgQwP hpRDUw">:</span> Boolean <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&#x27;Boolean&#x27;</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-cxNHIi fHUQtx">const</span> <span class="sc-bYwzuL fDDjHD">number</span><span class="sc-lmgQwP hpRDUw">:</span> Number <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&#x27;Number&#x27;</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-cxNHIi fHUQtx">const</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-lmgQwP hpRDUw">:</span> String <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&#x27;String&#x27;</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">;</span></code></pre><p><span>We represent object properties as an array, but it&#x27;s often convenient to construct object types by passing an object mapping names to types, like:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">const</span> type <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-iJCRrE bojiJp">object</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">boolean</span><span class="sc-lmgQwP hpRDUw">,</span> bar<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">string</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span></code></pre><p><span>so the </span><span><code>object</code></span><span> constructor takes either an array of properties or an object mapping names to types:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">object</span><span class="sc-lmgQwP hpRDUw">(</span>
  properties<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> name<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-lmgQwP hpRDUw">[</span>name<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Object <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-bYwzuL fDDjHD">Array</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">isArray</span><span class="sc-lmgQwP hpRDUw">(</span>properties<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">&#x27;Object&#x27;</span><span class="sc-lmgQwP hpRDUw">,</span> properties <span class="sc-lmgQwP hpRDUw">}</span>
  <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-cxNHIi fHUQtx">else</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-iJCRrE bojiJp">object</span><span class="sc-lmgQwP hpRDUw">(</span>
      Object<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">entries</span><span class="sc-lmgQwP hpRDUw">(</span>properties<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">map</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">[</span> name<span class="sc-lmgQwP hpRDUw">,</span> type <span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> name<span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-cxNHIi fHUQtx">type</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span>
    <span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>This is a nice example of the flexibility of union types: rather than define a separate function to convert an object argument to an array, we give the argument a union type. If </span><span><code>Array.isArray(properties)</code></span><span> is true, we know from the argument type that </span><span><code>properties</code></span><span> must be an array of </span><span><code>{ name: string, type: Type }</code></span><span> objects, so we can directly construct an </span><span><code>Object</code></span><span>. Otherwise it must be an object mapping property names to </span><span><code>Type</code></span><span>s, so we walk the object entries to build an array.</span></p><h3><span>Validators</span></h3><p><span>It&#x27;s also convenient to define validators for different kinds of </span><span><code>Type</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/validators.ts" class="sc-gtsrHT kFWJEY"><span>validators.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">isNull</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> t <span class="sc-cxNHIi fHUQtx">is</span> Null       <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-cxNHIi fHUQtx">return</span> t<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-giAqHp bYgUJS">&#x27;Null&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">isBoolean</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> t <span class="sc-cxNHIi fHUQtx">is</span> Boolean <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-cxNHIi fHUQtx">return</span> t<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-giAqHp bYgUJS">&#x27;Boolean&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">isNumber</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> t <span class="sc-cxNHIi fHUQtx">is</span> Number   <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-cxNHIi fHUQtx">return</span> t<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-giAqHp bYgUJS">&#x27;Number&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">isString</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> t <span class="sc-cxNHIi fHUQtx">is</span> String   <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-cxNHIi fHUQtx">return</span> t<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-giAqHp bYgUJS">&#x27;String&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">isObject</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> t <span class="sc-cxNHIi fHUQtx">is</span> Object   <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-cxNHIi fHUQtx">return</span> t<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-giAqHp bYgUJS">&#x27;Object&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>The return type </span><span><code>t is Null</code></span><span> is a </span><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" class="sc-gtsrHT kFWJEY"><span>type predicate</span></a><span>; when a call to the validator returns </span><span><code>true</code></span><span>, the type checker narrows </span><span><code>t</code></span><span> to type </span><span><code>Null</code></span><span>, just as it would have if the test </span><span><code>t.type === Null</code></span><span> had appeared directly in the code.</span></p><h3><span>Type module</span></h3><p><span>We wrap constructors, validators, and other type-related functions into a module (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/index.ts" class="sc-gtsrHT kFWJEY"><span>type/index.ts</span></a><span>) so we can write </span><span><code>Type.boolean, Type.object({ ... })</code></span><span>, </span><span><code>Type.isObject</code></span><span>, </span><span><code>Type.toString</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/toString.ts" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span>), and so on.</span></p><p><span>The </span><span><code>Type</code></span><span> module has a helper function to look up the type of a property in an object type:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">propType</span><span class="sc-lmgQwP hpRDUw">(</span>type<span class="sc-lmgQwP hpRDUw">:</span> Object<span class="sc-lmgQwP hpRDUw">,</span> name<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-cxNHIi fHUQtx">undefined</span> <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-cxNHIi fHUQtx">const</span> prop <span class="sc-lmgQwP hpRDUw">=</span> type<span class="sc-lmgQwP hpRDUw">.</span>properties<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">find</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> name<span class="sc-lmgQwP hpRDUw">:</span> propName <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> propName <span class="sc-lmgQwP hpRDUw">===</span> name<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span>prop<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-cxNHIi fHUQtx">return</span> prop<span class="sc-lmgQwP hpRDUw">.</span>type<span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><h3><span>Parsing types</span></h3><p><span>For writing tests it&#x27;s convenient to parse a type on its own. Babel doesn&#x27;t provide a function for this, but we can parse an </span><span><code>as</code></span><span> expression and pull out the type:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">parseType</span><span class="sc-lmgQwP hpRDUw">(</span>input<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-cxNHIi fHUQtx">const</span> ast <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-iJCRrE bojiJp">parseExpression</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">_ as </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">input</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">isTSAsExpression</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">bug</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">unexpected </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">ast</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-cxNHIi fHUQtx">type</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">return</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">ofTSType</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-cxNHIi fHUQtx">type</span>Annotation<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>Here </span><span><code>Type.ofTSType</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/ofTSType.ts" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span>) converts a Babel </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L2488" class="sc-gtsrHT kFWJEY"><span><code>TSType</code></span></a><span> AST to our </span><span><code>Type</code></span><span> representation, and </span><span><code>bug</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) throws an exception.</span></p><p><span>The call to </span><span><code>bug</code></span><span> shows a use of narrowing: the return type of </span><span><code>bug</code></span><span> is </span><span><code>never</code></span><span>, meaning that the function never returns a value (it throws an exception), so the TypeScript type checker reasons that in the remainder of the function, </span><span><code>ast.type !== &#x27;TSAsExpression&#x27;</code></span><span> must be false. Then </span><span><code>ast.type === &#x27;TSAsExpression&#x27;</code></span><span>, the type of </span><span><code>ast</code></span><span> must be </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L1961" class="sc-gtsrHT kFWJEY"><span><code>TSAsExpression</code></span></a><span>, and we can safely access </span><span><code>typeAnnotation</code></span><span>.</span></p><h2><span>Synthesizing types from expressions</span></h2><p><span>Recall that to </span><span><em>synthesize</em></span><span> a type </span><span><em>from</em></span><span> an expression, we synthesize the types of its subexpressions, then combine them according to the top-level operation of the expression; for atomic expressions like literal values, we return the corresponding type.</span></p><p><span>In this fragment we&#x27;ll support only a few kinds of expression: primitive literal values (like </span><span><code>7</code></span><span> or </span><span><code>true</code></span><span>), object literals (like </span><span><code>{ x: x, y: y }</code></span><span>), and member expressions (like </span><span><code>vec.x</code></span><span>). To synthesize the type of an expression, we first case over the expression type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/synth.ts" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">synth</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span>Expression<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-cxNHIi fHUQtx">switch</span> <span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">.</span>type<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-cxNHIi fHUQtx">case</span> <span class="sc-giAqHp bYgUJS">&#x27;NullLiteral&#x27;</span><span class="sc-lmgQwP hpRDUw">:</span>      <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-iJCRrE bojiJp">synthNull</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-cxNHIi fHUQtx">case</span> <span class="sc-giAqHp bYgUJS">&#x27;BooleanLiteral&#x27;</span><span class="sc-lmgQwP hpRDUw">:</span>   <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-iJCRrE bojiJp">synthBoolean</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-cxNHIi fHUQtx">case</span> <span class="sc-giAqHp bYgUJS">&#x27;NumericLiteral&#x27;</span><span class="sc-lmgQwP hpRDUw">:</span>   <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-iJCRrE bojiJp">synthNumber</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-cxNHIi fHUQtx">case</span> <span class="sc-giAqHp bYgUJS">&#x27;StringLiteral&#x27;</span><span class="sc-lmgQwP hpRDUw">:</span>    <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-iJCRrE bojiJp">synthString</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-cxNHIi fHUQtx">case</span> <span class="sc-giAqHp bYgUJS">&#x27;ObjectExpression&#x27;</span><span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-iJCRrE bojiJp">synthObject</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-cxNHIi fHUQtx">case</span> <span class="sc-giAqHp bYgUJS">&#x27;MemberExpression&#x27;</span><span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-iJCRrE bojiJp">synthMember</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>

    <span class="sc-cxNHIi fHUQtx">default</span><span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iJCRrE bojiJp">bug</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">unimplemented </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">ast</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-cxNHIi fHUQtx">type</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>For primitive literals we return the corresponding type:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">synthNull</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span>NullLiteral<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type       <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-cxNHIi fHUQtx">return</span> Type<span class="sc-lmgQwP hpRDUw">.</span>nullType<span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">synthBoolean</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span>BooleanLiteral<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-cxNHIi fHUQtx">return</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-bYwzuL fDDjHD">boolean</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">synthNumber</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span>NumericLiteral<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type  <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-cxNHIi fHUQtx">return</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-bYwzuL fDDjHD">number</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">synthString</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span>StringLiteral<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type   <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-cxNHIi fHUQtx">return</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-bYwzuL fDDjHD">string</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>For object expressions (of type </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L611" class="sc-gtsrHT kFWJEY"><span><code>ObjectExpression</code></span></a><span>), we synthesize a type for each property value expression, then return an object type mapping property names to types:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">synthObject</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span>ObjectExpression<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-cxNHIi fHUQtx">const</span> properties <span class="sc-lmgQwP hpRDUw">=</span>
    ast<span class="sc-lmgQwP hpRDUw">.</span>properties<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">map</span><span class="sc-lmgQwP hpRDUw">(</span>prop <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-lmgQwP hpRDUw">{</span>
      <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">isObjectProperty</span><span class="sc-lmgQwP hpRDUw">(</span>prop<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">bug</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">unimplemented </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">prop</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-cxNHIi fHUQtx">type</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">isIdentifier</span><span class="sc-lmgQwP hpRDUw">(</span>prop<span class="sc-lmgQwP hpRDUw">.</span>key<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">bug</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">unimplemented </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">prop</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-lmgQwP hpRDUw">key</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-cxNHIi fHUQtx">type</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">isExpression</span><span class="sc-lmgQwP hpRDUw">(</span>prop<span class="sc-lmgQwP hpRDUw">.</span>value<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">bug</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">unimplemented </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">prop</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-lmgQwP hpRDUw">value</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-cxNHIi fHUQtx">type</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span>prop<span class="sc-lmgQwP hpRDUw">.</span>computed<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">bug</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">unimplemented computed</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-lmgQwP hpRDUw">{</span>
        name<span class="sc-lmgQwP hpRDUw">:</span> prop<span class="sc-lmgQwP hpRDUw">.</span>key<span class="sc-lmgQwP hpRDUw">.</span>name<span class="sc-lmgQwP hpRDUw">,</span>
        type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iJCRrE bojiJp">synth</span><span class="sc-lmgQwP hpRDUw">(</span>prop<span class="sc-lmgQwP hpRDUw">.</span>value<span class="sc-lmgQwP hpRDUw">)</span>
      <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">return</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">object</span><span class="sc-lmgQwP hpRDUw">(</span>properties<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>The Babel parser parses the full JavaScript expression syntax, but we&#x27;re only implementing part of it, so we call </span><span><code>bug(`unimplemented`)</code></span><span> for cases that we don&#x27;t want to handle.</span></p><p><span>For member expressions, we synthesize the type of the left-hand side, check that it&#x27;s an object that contains the named member, and return the type of the member. We call </span><span><code>err</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) to raise an exception if these checks fail.</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">synthMember</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span>MemberExpression<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-cxNHIi fHUQtx">const</span> prop <span class="sc-lmgQwP hpRDUw">=</span> ast<span class="sc-lmgQwP hpRDUw">.</span>property<span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span><span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">isIdentifier</span><span class="sc-lmgQwP hpRDUw">(</span>prop<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">bug</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">unimplemented </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">prop</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-cxNHIi fHUQtx">type</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">.</span>computed<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">bug</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">unimplemented computed</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">const</span> object <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-iJCRrE bojiJp">synth</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">.</span>object<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span>Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">isObject</span><span class="sc-lmgQwP hpRDUw">(</span>object<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">err</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-giAqHp bYgUJS">&#x27;. expects object&#x27;</span><span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">.</span>object<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">const</span> type <span class="sc-lmgQwP hpRDUw">=</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">propType</span><span class="sc-lmgQwP hpRDUw">(</span>object<span class="sc-lmgQwP hpRDUw">,</span> prop<span class="sc-lmgQwP hpRDUw">.</span>name<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span>type<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">err</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">no such property </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">prop</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-lmgQwP hpRDUw">name</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">,</span> prop<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">return</span> type<span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>Again we skip some cases we don&#x27;t want to handle.</span></p><h2><span>Subtyping</span></h2><p><span>Recall that to check an expression against a type (we&#x27;ll show the code for this in the next section) we need to check </span><span><em>subtyping</em></span><span>: a type </span><span><code>A</code></span><span> is a subtype of a type </span><span><code>B</code></span><span> when all the operations supported on </span><span><code>B</code></span><span> are also supported on </span><span><code>A</code></span><span>.</span></p><p><span>Here&#x27;s a function to check subtyping (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/isSubtype.ts" class="sc-gtsrHT kFWJEY"><span>isSubtype.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">isSubtype</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">,</span> b<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">boolean</span> <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iJCRrE bojiJp">isNull</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;&amp;</span> <span class="sc-iJCRrE bojiJp">isNull</span><span class="sc-lmgQwP hpRDUw">(</span>b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-gXfVKN jKLUHq">true</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iJCRrE bojiJp">isBoolean</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;&amp;</span> <span class="sc-iJCRrE bojiJp">isBoolean</span><span class="sc-lmgQwP hpRDUw">(</span>b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-gXfVKN jKLUHq">true</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iJCRrE bojiJp">isNumber</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;&amp;</span> <span class="sc-iJCRrE bojiJp">isNumber</span><span class="sc-lmgQwP hpRDUw">(</span>b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-gXfVKN jKLUHq">true</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iJCRrE bojiJp">isString</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;&amp;</span> <span class="sc-iJCRrE bojiJp">isString</span><span class="sc-lmgQwP hpRDUw">(</span>b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-gXfVKN jKLUHq">true</span><span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iJCRrE bojiJp">isObject</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;&amp;</span> <span class="sc-iJCRrE bojiJp">isObject</span><span class="sc-lmgQwP hpRDUw">(</span>b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-cxNHIi fHUQtx">return</span> b<span class="sc-lmgQwP hpRDUw">.</span>properties<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">every</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> name<span class="sc-lmgQwP hpRDUw">:</span> bName<span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">:</span> bType <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-lmgQwP hpRDUw">{</span>
      <span class="sc-cxNHIi fHUQtx">const</span> aType <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-iJCRrE bojiJp">propType</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">,</span> bName<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span>aType<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-gXfVKN jKLUHq">false</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-cxNHIi fHUQtx">else</span> <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-iJCRrE bojiJp">isSubtype</span><span class="sc-lmgQwP hpRDUw">(</span>aType<span class="sc-lmgQwP hpRDUw">,</span> bType<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">}</span>

  <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-gXfVKN jKLUHq">false</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>An object type </span><span><code>A</code></span><span> is a subtype of an object type </span><span><code>B</code></span><span> if all the properties we can access on </span><span><code>B</code></span><span> can also be accessed on </span><span><code>A</code></span><span>, and each of those fields in </span><span><code>A</code></span><span> is a subtype of the corresponding field in </span><span><code>B</code></span><span>; the order of properties doesn&#x27;t matter.</span></p><h2><span>Checking expressions against types</span></h2><p><span>To check an expression against a type, we first case over the expression and type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/check.ts" class="sc-gtsrHT kFWJEY"><span>check.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">check</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">:</span> Expression<span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-giAqHp bYgUJS">&#x27;ObjectExpression&#x27;</span> <span class="sc-lmgQwP hpRDUw">&amp;&amp;</span> type<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-giAqHp bYgUJS">&#x27;Object&#x27;</span><span class="sc-lmgQwP hpRDUw">)</span>
    <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-iJCRrE bojiJp">checkObject</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-cxNHIi fHUQtx">const</span> synthType <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-iJCRrE bojiJp">synth</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span>Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">isSubtype</span><span class="sc-lmgQwP hpRDUw">(</span>synthType<span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span>
    <span class="sc-iJCRrE bojiJp">err</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">expected </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">Type</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">toString</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">type</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-giAqHp bYgUJS">, got </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">Type</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">toString</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">synthType</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>Object expressions are the only ones we can break down in this fragment; we synthesize types for other expressions and compare then with </span><span><code>Type.isSubtype</code></span><span> (more on this below).</span></p><p><span>To check an object expression against an object type, we check the value expression for each property against the corresponding type. We raise an exception if the object expression is missing a property present in the type, or if it has a property that&#x27;s not present in the type.</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">checkObject</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">:</span> ObjectExpression<span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">.</span>Object<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-cxNHIi fHUQtx">const</span> astProps<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> name<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-lmgQwP hpRDUw">,</span> expr<span class="sc-lmgQwP hpRDUw">:</span> Expression<span class="sc-lmgQwP hpRDUw">,</span> key<span class="sc-lmgQwP hpRDUw">:</span> Identifier <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span> <span class="sc-lmgQwP hpRDUw">=</span>
    ast<span class="sc-lmgQwP hpRDUw">.</span>properties<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">map</span><span class="sc-lmgQwP hpRDUw">(</span>prop <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-lmgQwP hpRDUw">{</span>
      <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span>prop<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">!==</span> <span class="sc-giAqHp bYgUJS">&#x27;ObjectProperty&#x27;</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">bug</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">unimplemented </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">prop</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-cxNHIi fHUQtx">type</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span>prop<span class="sc-lmgQwP hpRDUw">.</span>computed<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">bug</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">unimplemented computed</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span>prop<span class="sc-lmgQwP hpRDUw">.</span>key<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">!==</span> <span class="sc-giAqHp bYgUJS">&#x27;Identifier&#x27;</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">bug</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">unimplemented </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">prop</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-lmgQwP hpRDUw">key</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-cxNHIi fHUQtx">type</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-cxNHIi fHUQtx">return</span> <span class="sc-lmgQwP hpRDUw">{</span>
        name<span class="sc-lmgQwP hpRDUw">:</span> prop<span class="sc-lmgQwP hpRDUw">.</span>key<span class="sc-lmgQwP hpRDUw">.</span>name<span class="sc-lmgQwP hpRDUw">,</span>
        expr<span class="sc-lmgQwP hpRDUw">:</span> prop<span class="sc-lmgQwP hpRDUw">.</span>value <span class="sc-cxNHIi fHUQtx">as</span> Expression<span class="sc-lmgQwP hpRDUw">,</span>
        key<span class="sc-lmgQwP hpRDUw">:</span> prop<span class="sc-lmgQwP hpRDUw">.</span>key
      <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>

  type<span class="sc-lmgQwP hpRDUw">.</span>properties<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">forEach</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> name <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-cxNHIi fHUQtx">const</span> astProp <span class="sc-lmgQwP hpRDUw">=</span> astProps<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">find</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> name<span class="sc-lmgQwP hpRDUw">:</span> astName <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> astName <span class="sc-lmgQwP hpRDUw">===</span> name<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span>astProp<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">err</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">missing property </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">name</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>

  astProps<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">forEach</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> name<span class="sc-lmgQwP hpRDUw">,</span> expr<span class="sc-lmgQwP hpRDUw">,</span> key <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-cxNHIi fHUQtx">const</span> prop <span class="sc-lmgQwP hpRDUw">=</span>
      type<span class="sc-lmgQwP hpRDUw">.</span>properties<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">find</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> name<span class="sc-lmgQwP hpRDUw">:</span> propName <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> propName <span class="sc-lmgQwP hpRDUw">===</span> name<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-cxNHIi fHUQtx">if</span> <span class="sc-lmgQwP hpRDUw">(</span>prop<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-iJCRrE bojiJp">check</span><span class="sc-lmgQwP hpRDUw">(</span>expr<span class="sc-lmgQwP hpRDUw">,</span> prop<span class="sc-lmgQwP hpRDUw">.</span>type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-cxNHIi fHUQtx">else</span> <span class="sc-iJCRrE bojiJp">err</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-giAqHp bYgUJS">extra property </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">name</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">,</span> key<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>Again we don&#x27;t implement spreads or computed property names.</span></p><p><span>Finally for </span><span><code>as</code></span><span> expressions we synthesize by checking the expression against the given type:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-cxNHIi fHUQtx">function</span> <span class="sc-iJCRrE bojiJp">synthTSAs</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-gXfVKN jKLUHq">AST</span><span class="sc-lmgQwP hpRDUw">.</span>TSAsExpression<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-cxNHIi fHUQtx">const</span> type <span class="sc-lmgQwP hpRDUw">=</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-iJCRrE bojiJp">ofTSType</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-cxNHIi fHUQtx">type</span>Annotation<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-iJCRrE bojiJp">check</span><span class="sc-lmgQwP hpRDUw">(</span>ast<span class="sc-lmgQwP hpRDUw">.</span>expression<span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-cxNHIi fHUQtx">return</span> type<span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>In actual TypeScript, </span><span><code><em>expression</em></code></span><span><code> as </code></span><span><code><em>type</em></code></span><span> is an unsafe cast; here it&#x27;s a </span><span><em>type ascription</em></span><span> that we can use to direct the type checker to check rather than synthesize a particular expression, but it can&#x27;t cast to an unrelated type.</span></p><h2><span>Try it!</span></h2><p><span>You can try out the type checker below; it synthesizes a type from the expression, but you can try checking by ascribing a type with </span><span><code>as</code></span><span>. Remember that the only supported expressions in this fragment are primitive literals, object expressions, property accesses, and </span><span><code>as</code></span><span> ascriptions.</span></p><iframe src="https://jaked.org/reconstructing-typescript/part1/" width="700" height="300" style="border-style:none"></iframe><h2><span>Here&#x27;s the plan</span></h2><p><span>Next time we&#x27;ll add functions and function calls to the language—we&#x27;ll add a </span><span><em>type environment</em></span><span> to track the types of variables; and see how subtyping for functions requires </span><span><em>contravariance</em></span><span>.</span></p><ul><li><p><span></span><a href="/blog/unpublished/2021-09-03-Reconstructing-TypeScript-part-0"><span>Part 0: intro and background</span></a><span></span></p></li><li><p><span></span><a href="/blog/unpublished/2021-09-03-Reconstructing-TypeScript-part-1"><span>Part 1: bidirectional type checking</span></a><span></span></p></li><li><p><span>Part 2: functions and function calls</span></p></li><li><p><span>Part 3: singleton / literal types and arithmetic / logical operators</span></p></li><li><p><span>Part 4: union types</span></p></li><li><p><span>Part 5: intersection types</span></p></li><li><p><span>Part 6: narrowing</span></p></li></ul><p><span>Thanks to Julia Evans, Tony Chow, and Will Lachance for helpful feedback on a draft of this post.</span></p><p><span>Please </span><a href="/blog/unpublished/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p></div></body></html>