<html><head><title>Reconstructing TypeScript (part 1)</title><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/unpublished/2021-09-03-Reconstructing-TypeScript-part-1.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.fUzHPW{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"fUzHPW,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.hbusih{color:#770088;}/*!sc*/
data-styled.g37[id="sc-iklJeh"]{content:"hbusih,"}/*!sc*/
.laKGqb{color:#000000;}/*!sc*/
data-styled.g38[id="sc-jJMGnK"]{content:"laKGqb,"}/*!sc*/
.dRsyqq{color:#aa1111;}/*!sc*/
data-styled.g39[id="sc-hiKfDv"]{content:"dRsyqq,"}/*!sc*/
.jKLUHq{color:#268bd2;}/*!sc*/
data-styled.g40[id="sc-gXfVKN"]{content:"jKLUHq,"}/*!sc*/
.bwSYJA{color:#b58900;}/*!sc*/
data-styled.g42[id="sc-ciSkZP"]{content:"bwSYJA,"}/*!sc*/
.hBWCUB{color:#221199;}/*!sc*/
data-styled.g44[id="sc-carFqZ"]{content:"hBWCUB,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript (part 1)</span></p><h1><span>Reconstructing TypeScript (part 1)</span></h1><h3><span><em>2021-09-03</em></span></h3><p><span>Now let&#x27;s write a type checker! (For the full code of part 1 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part1" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part1</span></a><span>.)</span></p><h2><span>Representing types</span></h2><p><span>In this first fragment we&#x27;ll support only a few types—primitives and objects made up of properties (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/types.ts" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">type</span> <span class="sc-jJMGnK laKGqb">Type</span> <span class="sc-jJMGnK laKGqb">=</span> Null <span class="sc-jJMGnK laKGqb">|</span> Boolean <span class="sc-jJMGnK laKGqb">|</span> Number <span class="sc-jJMGnK laKGqb">|</span> String <span class="sc-jJMGnK laKGqb">|</span> Object<span class="sc-jJMGnK laKGqb">;</span>

<span class="sc-iklJeh hbusih">type</span> <span class="sc-jJMGnK laKGqb">Null</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Null&#x27;</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-iklJeh hbusih">type</span> <span class="sc-jJMGnK laKGqb">Boolean</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Boolean&#x27;</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-iklJeh hbusih">type</span> <span class="sc-jJMGnK laKGqb">Number</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Number&#x27;</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-iklJeh hbusih">type</span> <span class="sc-jJMGnK laKGqb">String</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;String&#x27;</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-iklJeh hbusih">type</span> <span class="sc-jJMGnK laKGqb">Object</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span>
  type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
  properties<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jJMGnK laKGqb">{</span> name<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">string</span><span class="sc-jJMGnK laKGqb">,</span> type<span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>(We don&#x27;t have an </span><span><code>any</code></span><span> type. In actual TypeScript </span><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#any" class="sc-gtsrHT kFWJEY"><span><code>any</code></span><span> is an escape hatch from type checking</span></a><span>, to accommodate existing JavaScript that doesn&#x27;t fit into the type system; here we won&#x27;t provide any escape hatches.)</span></p><p><span>When consuming types we&#x27;ll work directly with these objects; but we have helper functions to construct them (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/constructors.ts" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">const</span> nullType<span class="sc-jJMGnK laKGqb">:</span> Null <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Null&#x27;</span> <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-iklJeh hbusih">const</span> <span class="sc-gXfVKN jKLUHq">boolean</span><span class="sc-jJMGnK laKGqb">:</span> Boolean <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Boolean&#x27;</span> <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-iklJeh hbusih">const</span> <span class="sc-gXfVKN jKLUHq">number</span><span class="sc-jJMGnK laKGqb">:</span> Number <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Number&#x27;</span> <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-iklJeh hbusih">const</span> <span class="sc-gXfVKN jKLUHq">string</span><span class="sc-jJMGnK laKGqb">:</span> String <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;String&#x27;</span> <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span></code></pre><p><span>We represent object properties as an array, but it&#x27;s often convenient to construct object types by passing an object mapping names to types:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">const</span> type <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-ciSkZP bwSYJA">object</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">boolean</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">string</span> <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span></code></pre><p><span>so the </span><span><code>object</code></span><span> constructor takes either:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">object</span><span class="sc-jJMGnK laKGqb">(</span>
  properties<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jJMGnK laKGqb">{</span> name<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">string</span><span class="sc-jJMGnK laKGqb">,</span> type<span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-jJMGnK laKGqb">{</span> <span class="sc-jJMGnK laKGqb">[</span>name<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">string</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Object <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">Array</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">isArray</span><span class="sc-jJMGnK laKGqb">(</span>properties<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-iklJeh hbusih">return</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> properties <span class="sc-jJMGnK laKGqb">}</span>
  <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-iklJeh hbusih">else</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-iklJeh hbusih">return</span> <span class="sc-ciSkZP bwSYJA">object</span><span class="sc-jJMGnK laKGqb">(</span>
      Object<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">entries</span><span class="sc-jJMGnK laKGqb">(</span>properties<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">map</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">[</span> name<span class="sc-jJMGnK laKGqb">,</span> type <span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">{</span> name<span class="sc-jJMGnK laKGqb">,</span> <span class="sc-iklJeh hbusih">type</span> <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>
    <span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>This is a nice example of the flexibility of union types: rather than define a separate function to convert an object argument to an array, we give the argument a union type.</span></p><p><span>We wrap constructors and other type-related functions into a module (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/index.ts" class="sc-gtsrHT kFWJEY"><span>type/index.ts</span></a><span>) so we can write </span><span><code>Type.object</code></span><span>, </span><span><code>Type.toString</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/toString.ts" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span>), and so on.</span></p><h2><span>Parsing code</span></h2><p><span>To parse code into an abstract syntax tree we&#x27;ll use </span><a href="https://babeljs.io/docs/en/babel-parser" class="sc-gtsrHT kFWJEY"><span>@babel/parser</span></a><span>, which parses JavaScript with TypeScript extensions to a </span><a href="https://babeljs.io/docs/en/babel-types" class="sc-gtsrHT kFWJEY"><span>@babel/types</span></a><span> AST (with </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts" class="sc-gtsrHT kFWJEY"><span>this TypeScript type</span></a><span>).</span></p><p><span>To keep things simple we&#x27;ll handle only </span><span><code>Expression</code></span><span> nodes in the AST (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/ast/parse.ts" class="sc-gtsrHT kFWJEY"><span>parse.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">parseExpression</span><span class="sc-jJMGnK laKGqb">(</span>input<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">string</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Expression <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-iklJeh hbusih">return</span> Babel<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">parseExpression</span><span class="sc-jJMGnK laKGqb">(</span>input<span class="sc-jJMGnK laKGqb">,</span> <span class="sc-jJMGnK laKGqb">{</span>
    plugins<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jJMGnK laKGqb">[</span> <span class="sc-hiKfDv dRsyqq">&#x27;typescript&#x27;</span> <span class="sc-jJMGnK laKGqb">]</span>
  <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>For writing tests it&#x27;s convenient to be able to parse types separately:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">parseType</span><span class="sc-jJMGnK laKGqb">(</span>input<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">string</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-iklJeh hbusih">const</span> ast <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-ciSkZP bwSYJA">parseExpression</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">_ as </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">input</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">!==</span> <span class="sc-hiKfDv dRsyqq">&#x27;TSAsExpression&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unexpected </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">ast</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">type</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">ofTSType</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">type</span>Annotation<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>Here </span><span><code>Type.ofTSType</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/ofTSType.ts" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span>) converts a Babel </span><span><code>TSType</code></span><span> AST to our </span><span><code>Type</code></span><span> representation, and </span><span><code>bug</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) throws an exception.</span></p><p><span>The call to </span><span><code>bug</code></span><span> shows a use of narrowing: the return type of </span><span><code>bug</code></span><span> is </span><span><code>never</code></span><span>, meaning that the function never returns a value (it throws an exception), so the TypeScript type checker reasons that in the remainder of the function, </span><span><code>ast.type !== &#x27;TSAsExpression&#x27;</code></span><span> must be false. Therefore </span><span><code>ast.type === &#x27;TSAsExpression&#x27;</code></span><span> and we can safely access </span><span><code>typeAnnotation</code></span><span>.</span></p><p><span>It&#x27;s really helpful to be able to browse the AST produced by a piece of code. I use the excellent </span><a href="https://astexplorer.net/" class="sc-gtsrHT kFWJEY"><span>AST Explorer</span></a><span> for this—set the language to &quot;JavaScript&quot; and the parser to &quot;@babel/parser&quot;; TypeScript extensions are parsed without special configuration.</span></p><h2><span>Synthesizing types from expressions</span></h2><p><span>In this first fragment we&#x27;ll support only a few kinds of expression: primitive literals, object literals (like </span><span><code>{ x: x, y: y }</code></span><span>), and member expressions (like </span><span><code>vec.x</code></span><span>). To synthesize the type of an expression, we first case over the expression type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/synth.ts" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">synth</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">:</span> Expression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-iklJeh hbusih">switch</span> <span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-iklJeh hbusih">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;NullLiteral&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>      <span class="sc-iklJeh hbusih">return</span> <span class="sc-ciSkZP bwSYJA">synthNull</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-iklJeh hbusih">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;BooleanLiteral&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>   <span class="sc-iklJeh hbusih">return</span> <span class="sc-ciSkZP bwSYJA">synthBoolean</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-iklJeh hbusih">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;NumericLiteral&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>   <span class="sc-iklJeh hbusih">return</span> <span class="sc-ciSkZP bwSYJA">synthNumber</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-iklJeh hbusih">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;StringLiteral&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>    <span class="sc-iklJeh hbusih">return</span> <span class="sc-ciSkZP bwSYJA">synthString</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-iklJeh hbusih">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;ObjectExpression&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">return</span> <span class="sc-ciSkZP bwSYJA">synthObject</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-iklJeh hbusih">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;MemberExpression&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">return</span> <span class="sc-ciSkZP bwSYJA">synthMember</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-iklJeh hbusih">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;TSAsExpression&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>   <span class="sc-iklJeh hbusih">return</span> <span class="sc-ciSkZP bwSYJA">synthTSAs</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>

    <span class="sc-iklJeh hbusih">default</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">ast</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">type</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>For primitive literals we return the corresponding type:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">synthNull</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">:</span> NullLiteral<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span> <span class="sc-iklJeh hbusih">return</span> Type<span class="sc-jJMGnK laKGqb">.</span>nullType<span class="sc-jJMGnK laKGqb">;</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">synthBoolean</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">:</span> BooleanLiteral<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span> <span class="sc-iklJeh hbusih">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-gXfVKN jKLUHq">boolean</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">synthNumber</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">:</span> NumericLiteral<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span> <span class="sc-iklJeh hbusih">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-gXfVKN jKLUHq">number</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">synthString</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">:</span> StringLiteral<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span> <span class="sc-iklJeh hbusih">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-gXfVKN jKLUHq">string</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>For object expressions, we synthesize a type for each property value expression, then return an object type mapping property names to types:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">synthObject</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">:</span> ObjectExpression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-iklJeh hbusih">const</span> properties <span class="sc-jJMGnK laKGqb">=</span>
    ast<span class="sc-jJMGnK laKGqb">.</span>properties<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">map</span><span class="sc-jJMGnK laKGqb">(</span>prop <span class="sc-jJMGnK laKGqb">=&gt;</span> <span class="sc-jJMGnK laKGqb">{</span>
      <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>prop<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">!==</span> <span class="sc-hiKfDv dRsyqq">&#x27;ObjectProperty&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">prop</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">type</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>prop<span class="sc-jJMGnK laKGqb">.</span>computed<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented computed</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>prop<span class="sc-jJMGnK laKGqb">.</span>key<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">!==</span> <span class="sc-hiKfDv dRsyqq">&#x27;Identifier&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">prop</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">key</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">type</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-iklJeh hbusih">return</span> <span class="sc-jJMGnK laKGqb">{</span>
        name<span class="sc-jJMGnK laKGqb">:</span> prop<span class="sc-jJMGnK laKGqb">.</span>key<span class="sc-jJMGnK laKGqb">.</span>name<span class="sc-jJMGnK laKGqb">,</span>
        type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-ciSkZP bwSYJA">synth</span><span class="sc-jJMGnK laKGqb">(</span>prop<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-iklJeh hbusih">as</span> Expression<span class="sc-jJMGnK laKGqb">)</span>
      <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">object</span><span class="sc-jJMGnK laKGqb">(</span>properties<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>We call </span><span><code>bug(`unimplemented`)</code></span><span> when the object expression contains the spread operator (</span><span><code>...</code></span><span>) or a computed property name (</span><span><code>[name]: value</code></span><span>). (We&#x27;re obliged to cast </span><span><code>prop.value</code></span><span> here because the Babel AST type is imprecise—it uses </span><span><code>ObjectProperty</code></span><span> for both </span><span><code>ObjectExpression</code></span><span>s and </span><span><code>ObjectPattern</code></span><span>s, so permits non-</span><span><code>Expression</code></span><span> pattern nodes, even though they don&#x27;t actually appear.)</span></p><p><span>For member expressions, we synthesize the type of the left-hand side, check that it&#x27;s an object that contains the named member, and return the type of the member. We call </span><span><code>err</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/util/err.ts" class="sc-gtsrHT kFWJEY"><span>err.ts</span></a><span>) to raise an exception if these checks fail.</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">synthMember</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">:</span> MemberExpression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>computed<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented computed</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">const</span> prop <span class="sc-jJMGnK laKGqb">=</span> ast<span class="sc-jJMGnK laKGqb">.</span>property<span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>prop<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">!==</span> <span class="sc-hiKfDv dRsyqq">&#x27;Identifier&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">prop</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">type</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">const</span> object <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-ciSkZP bwSYJA">synth</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>object<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>object<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">!==</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">err</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-hiKfDv dRsyqq">&#x27;. expects object&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>object<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">const</span> <span class="sc-iklJeh hbusih">type</span>Prop <span class="sc-jJMGnK laKGqb">=</span>
    object<span class="sc-jJMGnK laKGqb">.</span>properties<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">find</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">{</span> name<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">type</span>Name <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> <span class="sc-iklJeh hbusih">type</span>Name <span class="sc-jJMGnK laKGqb">===</span> prop<span class="sc-jJMGnK laKGqb">.</span>name<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">!</span><span class="sc-iklJeh hbusih">type</span>Prop<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">err</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">no such property </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">prop</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">name</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">,</span> prop<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">return</span> <span class="sc-iklJeh hbusih">type</span>Prop<span class="sc-jJMGnK laKGqb">.</span>type<span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>Again we don&#x27;t implement computed property names.</span></p><p><span>Finally for </span><span><code>as</code></span><span> expressions we synthesize by checking the expression against the given type:</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">synthTSAs</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">:</span> TSAsExpression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-iklJeh hbusih">const</span> type <span class="sc-jJMGnK laKGqb">=</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">ofTSType</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">type</span>Annotation<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-ciSkZP bwSYJA">check</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>expression<span class="sc-jJMGnK laKGqb">,</span> type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">return</span> type<span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>In actual TypeScript, </span><span><code><em>expression</em></code></span><span><code> as </code></span><span><code><em>type</em></code></span><span> is an unsafe cast; here it&#x27;s a </span><span><em>type ascription</em></span><span> that we can use to direct the type checker to check rather than synthesize a particular expression, but it can&#x27;t cast to an unrelated type.</span></p><h2><span>Checking expressions against types</span></h2><p><span>To check an expression against a type, we first case over the expression and type and dispatch to helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/typecheck/check.ts" class="sc-gtsrHT kFWJEY"><span>check.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">check</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">:</span> Expression<span class="sc-jJMGnK laKGqb">,</span> type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;ObjectExpression&#x27;</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> type<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-jJMGnK laKGqb">)</span>
    <span class="sc-iklJeh hbusih">return</span> <span class="sc-ciSkZP bwSYJA">checkObject</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">,</span> type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>

  <span class="sc-iklJeh hbusih">const</span> synthType <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-ciSkZP bwSYJA">synth</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">!</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>synthType<span class="sc-jJMGnK laKGqb">,</span> type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>
    <span class="sc-ciSkZP bwSYJA">err</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">expected </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">Type</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">toString</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">type</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-hiKfDv dRsyqq">, got </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">Type</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">toString</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">synthType</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>Object expressions are the only ones we can break down in this fragment; we synthesize types for other expressions and compare then with </span><span><code>Type.isSubtype</code></span><span> (more on this below).</span></p><p><span>To check an object expression against an object type, we check the value expression for each property against the corresponding type. We raise an exception if the object expression is missing a property present in the type, or if it has a property that&#x27;s not present in the type.</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">checkObject</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">:</span> ObjectExpression<span class="sc-jJMGnK laKGqb">,</span> type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">.</span>Object<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-iklJeh hbusih">const</span> astProps<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jJMGnK laKGqb">{</span> name<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">string</span><span class="sc-jJMGnK laKGqb">,</span> expr<span class="sc-jJMGnK laKGqb">:</span> Expression<span class="sc-jJMGnK laKGqb">,</span> key<span class="sc-jJMGnK laKGqb">:</span> Identifier <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span> <span class="sc-jJMGnK laKGqb">=</span>
    ast<span class="sc-jJMGnK laKGqb">.</span>properties<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">map</span><span class="sc-jJMGnK laKGqb">(</span>prop <span class="sc-jJMGnK laKGqb">=&gt;</span> <span class="sc-jJMGnK laKGqb">{</span>
      <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>prop<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">!==</span> <span class="sc-hiKfDv dRsyqq">&#x27;ObjectProperty&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">prop</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">type</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>prop<span class="sc-jJMGnK laKGqb">.</span>computed<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented computed</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>prop<span class="sc-jJMGnK laKGqb">.</span>key<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">!==</span> <span class="sc-hiKfDv dRsyqq">&#x27;Identifier&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">prop</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">key</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">type</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-iklJeh hbusih">return</span> <span class="sc-jJMGnK laKGqb">{</span>
        name<span class="sc-jJMGnK laKGqb">:</span> prop<span class="sc-jJMGnK laKGqb">.</span>key<span class="sc-jJMGnK laKGqb">.</span>name<span class="sc-jJMGnK laKGqb">,</span>
        expr<span class="sc-jJMGnK laKGqb">:</span> prop<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-iklJeh hbusih">as</span> Expression<span class="sc-jJMGnK laKGqb">,</span>
        key<span class="sc-jJMGnK laKGqb">:</span> prop<span class="sc-jJMGnK laKGqb">.</span>key
      <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>

  type<span class="sc-jJMGnK laKGqb">.</span>properties<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">forEach</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">{</span> name <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-iklJeh hbusih">const</span> astProp <span class="sc-jJMGnK laKGqb">=</span> astProps<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">find</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">{</span> name<span class="sc-jJMGnK laKGqb">:</span> astName <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> astName <span class="sc-jJMGnK laKGqb">===</span> name<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">!</span>astProp<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">err</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">missing property </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">name</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>

  astProps<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">forEach</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">{</span> name<span class="sc-jJMGnK laKGqb">,</span> expr<span class="sc-jJMGnK laKGqb">,</span> key <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-iklJeh hbusih">const</span> prop <span class="sc-jJMGnK laKGqb">=</span>
      type<span class="sc-jJMGnK laKGqb">.</span>properties<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">find</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">{</span> name<span class="sc-jJMGnK laKGqb">:</span> propName <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> propName <span class="sc-jJMGnK laKGqb">===</span> name<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>prop<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-ciSkZP bwSYJA">check</span><span class="sc-jJMGnK laKGqb">(</span>expr<span class="sc-jJMGnK laKGqb">,</span> prop<span class="sc-jJMGnK laKGqb">.</span>type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-iklJeh hbusih">else</span> <span class="sc-ciSkZP bwSYJA">err</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">extra property </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">name</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">,</span> key<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>Again we don&#x27;t implement spreads or computed property names. </span></p><h2><span>Subtyping</span></h2><p><span>In </span><span><code>check</code></span><span>, when we can&#x27;t break down the expression or type, we synthesize a type and compare it to the expected type. Recall that checking an expression against a type means checking that the expression supports the operations described by the type; recall also that the type synthesized for an expression describes the operations it supports. So, putting these together, to compare types here we need to check that the operations supported by the </span><span><em>expected</em></span><span> type are also supported by the </span><span><em>synthesized</em></span><span> type. When the operations supported by type </span><span><code>B</code></span><span> are also supported by type </span><span><code>A</code></span><span>, we say that </span><span><code>A</code></span><span> is a </span><span><em>subtype</em></span><span> of </span><span><code>B</code></span><span> , or </span><span><code>A &lt;: B</code></span><span>.</span></p><p><span>When </span><span><code>A &lt;: B</code></span><span>, then an operation supported on </span><span><code>B</code></span><span> is also supported on </span><span><code>A</code></span><span>. So it makes sense that subtyping should be reflexive (</span><span><code>A &lt;: A</code></span><span> for any </span><span><code>A</code></span><span>) and transitive (if </span><span><code>A &lt;: B</code></span><span> and </span><span><code>B &lt;: C</code></span><span> then </span><span><code>A &lt;: C</code></span><span> for any </span><span><code>A</code></span><span>, </span><span><code>B</code></span><span>, and </span><span><code>C</code></span><span>).</span></p><p><span>Here&#x27;s a function to check subtyping (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part1/src/type/isSubtype.ts" class="sc-gtsrHT kFWJEY"><span>isSubtype.ts</span></a><span>):</span></p><pre class="sc-bdnxRM fUzHPW"><code><span class="sc-iklJeh hbusih">function</span> <span class="sc-ciSkZP bwSYJA">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">,</span> b<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">boolean</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Null&#x27;</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> b<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Null&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-iklJeh hbusih">return</span> <span class="sc-carFqZ hBWCUB">true</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Boolean&#x27;</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> b<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Boolean&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-iklJeh hbusih">return</span> <span class="sc-carFqZ hBWCUB">true</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Number&#x27;</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> b<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Number&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-iklJeh hbusih">return</span> <span class="sc-carFqZ hBWCUB">true</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;String&#x27;</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> b<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;String&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-iklJeh hbusih">return</span> <span class="sc-carFqZ hBWCUB">true</span><span class="sc-jJMGnK laKGqb">;</span>

  <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> b<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-iklJeh hbusih">return</span> b<span class="sc-jJMGnK laKGqb">.</span>properties<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">every</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">{</span> name<span class="sc-jJMGnK laKGqb">:</span> bName<span class="sc-jJMGnK laKGqb">,</span> type<span class="sc-jJMGnK laKGqb">:</span> bType <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> <span class="sc-jJMGnK laKGqb">{</span>
      <span class="sc-iklJeh hbusih">const</span> aProp <span class="sc-jJMGnK laKGqb">=</span> a<span class="sc-jJMGnK laKGqb">.</span>properties<span class="sc-jJMGnK laKGqb">.</span><span class="sc-ciSkZP bwSYJA">find</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">{</span> name<span class="sc-jJMGnK laKGqb">:</span> aName <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> aName <span class="sc-jJMGnK laKGqb">===</span> bName<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-iklJeh hbusih">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">!</span>aProp<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-iklJeh hbusih">return</span> <span class="sc-carFqZ hBWCUB">false</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-iklJeh hbusih">else</span> <span class="sc-iklJeh hbusih">return</span> <span class="sc-ciSkZP bwSYJA">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>aProp<span class="sc-jJMGnK laKGqb">.</span>type<span class="sc-jJMGnK laKGqb">,</span> bType<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>

  <span class="sc-iklJeh hbusih">return</span> <span class="sc-carFqZ hBWCUB">false</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>An object type </span><span><code>A</code></span><span> is a subtype of an object type </span><span><code>B</code></span><span> if all the properties we can access on </span><span><code>B</code></span><span> can also be accessed on </span><span><code>A</code></span><span>, and each of those fields in </span><span><code>A</code></span><span> is a subtype of the corresponding field in </span><span><code>B</code></span><span>; the order of fields doesn&#x27;t matter.</span></p><h2><span>Try it!</span></h2><p><span>You can try out the type checker below; it synthesizes a type from the expression, but you can try checking by ascribing a type with </span><span><code>as</code></span><span>. Remember that the only supported expressions in this fragment are primitive literals, object expressions, property accesses, and </span><span><code>as</code></span><span> ascriptions.</span></p><iframe src="https://jaked.org/reconstructing-typescript/part1/" width="700" height="300" style="border-style:none"></iframe><h2><span>Here&#x27;s the plan</span></h2><ul><li><p><span>Part 0: intro and overview</span></p></li><li><p><span>Part 1: bidirectional type checking</span></p></li><li><p><span>Part 2: functions and function calls</span></p></li><li><p><span>Part 3: singleton / literal types and arithmetic / logical operators</span></p></li><li><p><span>Part 4: union types</span></p></li><li><p><span>Part 5: intersection types</span></p></li><li><p><span>Part 6: narrowing</span></p></li></ul><h2><span>References</span></h2><p><span>On bidirectional type checking see Pierce and Turner, </span><a href="https://www.cis.upenn.edu/~bcpierce/papers/lti-toplas.pdf" class="sc-gtsrHT kFWJEY"><span>Local Type Inference</span></a><span>.</span></p><p><span>The </span><a href="https://github.com/microsoft/TypeScript/blob/main/doc/TypeScript%20Language%20Specification%20-%20ARCHIVED.pdf?raw=true" class="sc-gtsrHT kFWJEY"><span>TypeScript Language Specification</span></a><span> is 5 years out of date but still interesting.</span></p><p><span></span></p><p><span>Please </span><a href="/blog/unpublished/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p></div></body></html>