<html><head><title>Reconstructing TypeScript, part 2: functions and function types</title><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/2021-09-27-Reconstructing-TypeScript-part-2.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.bOWasK{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;overflow:auto;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"bOWasK,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.fHUQtx{color:#116644;}/*!sc*/
data-styled.g30[id="sc-cxNHIi"]{content:"fHUQtx,"}/*!sc*/
.hpRDUw{color:#aa1111;}/*!sc*/
data-styled.g31[id="sc-lmgQwP"]{content:"hpRDUw,"}/*!sc*/
.bojiJp{color:#221199;}/*!sc*/
data-styled.g32[id="sc-iJCRrE"]{content:"bojiJp,"}/*!sc*/
.bYgUJS{color:#000000;}/*!sc*/
data-styled.g33[id="sc-giAqHp"]{content:"bYgUJS,"}/*!sc*/
.dvHFX{color:#770088;}/*!sc*/
data-styled.g34[id="sc-ezzafa"]{content:"dvHFX,"}/*!sc*/
.fDDjHD{color:#268bd2;}/*!sc*/
data-styled.g35[id="sc-bYwzuL"]{content:"fDDjHD,"}/*!sc*/
.iehvjW{color:#b58900;}/*!sc*/
data-styled.g36[id="sc-kLojOw"]{content:"iehvjW,"}/*!sc*/
.fqbJCS{color:#6f42c1;}/*!sc*/
data-styled.g50[id="sc-dPaNzc"]{content:"fqbJCS,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript, part 2</span></p><h1 id="reconstructing-typescript-part-2-functions-and-function-calls"><span>Reconstructing TypeScript, part 2: functions and function calls</span></h1><h3 id="2021-09-27"><span><em>2021-09-27</em></span></h3><p><span>This post is part of a series about implementing type checking for a TypeScript-like language. In the </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>last post</span></a><span> we walked through the code for type checking a small fragment of the language, with only primitive literals, object expressions, and member expressions.</span></p><p><span>In this part we&#x27;ll add function definitions like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-giAqHp bYgUJS">(</span>x<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">number</span><span class="sc-giAqHp bYgUJS">,</span> y<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">number</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">{</span> x<span class="sc-giAqHp bYgUJS">:</span> x<span class="sc-giAqHp bYgUJS">,</span> y<span class="sc-giAqHp bYgUJS">:</span> y <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">)</span></code></pre><p><span>and function calls like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">f</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-cxNHIi fHUQtx">7</span><span class="sc-giAqHp bYgUJS">,</span> <span class="sc-cxNHIi fHUQtx">9</span><span class="sc-giAqHp bYgUJS">)</span></code></pre><p><span>Since function definitions bind variables that can be used in the body of the function, we&#x27;ll need to handle variable expressions like</span></p><pre class="sc-bdnxRM bOWasK"><code>x
y</code></pre><p><span>and also keep track of the types of variables. Let&#x27;s start there:</span></p><h2 id="environments"><span>Environments</span></h2><p><span>An </span><span><em>environment</em></span><span> is a table mapping variable names to types. A </span><span><em>binding</em></span><span> is a single name-to-type entry in the environment. When type checking a function definition, we add a binding for each argument to the environment; when we encounter a variable in the function body, we look up its type in the environment; and we drop the new bindings after type checking the function, since they&#x27;re no longer in scope.</span></p><p><span>A straightforward way to implement this is with &quot;functional update&quot;: to add a binding to an environment, copy the old environment and add the new binding. The old environment is not affected, so when we&#x27;re finished type checking the function we discard the new environment and go back to the using the old one.</span></p><p><span>Here&#x27;s the environment type (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part2/src/typecheck/env.ts" class="sc-gtsrHT kFWJEY"><span>env.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">type</span> <span class="sc-giAqHp bYgUJS">Env</span> <span class="sc-giAqHp bYgUJS">=</span> <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-kLojOw iehvjW">get</span><span class="sc-giAqHp bYgUJS">(</span>name<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">:</span> Type <span class="sc-giAqHp bYgUJS">|</span> <span class="sc-ezzafa dvHFX">undefined</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-kLojOw iehvjW">set</span><span class="sc-giAqHp bYgUJS">(</span>name<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-giAqHp bYgUJS">,</span> type<span class="sc-giAqHp bYgUJS">:</span> Type<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">:</span> Env<span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-kLojOw iehvjW">entries</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">:</span> IterableIterator<span class="sc-giAqHp bYgUJS">&lt;</span><span class="sc-giAqHp bYgUJS">[</span><span class="sc-bYwzuL fDDjHD">string</span><span class="sc-giAqHp bYgUJS">,</span> Type<span class="sc-giAqHp bYgUJS">]</span><span class="sc-giAqHp bYgUJS">&gt;</span><span class="sc-giAqHp bYgUJS">;</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><p><span>We can </span><span><code>get</code></span><span> the type of a variable (it might be </span><span><code>undefined</code></span><span> if the variable is unbound) or </span><span><code>set</code></span><span> the type of a variable (returning a new environment). For debugging we can iterate over the </span><span><code>entries</code></span><span> (bindings) in an environment.</span></p><p><span>Here&#x27;s the environment constructor:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">function</span> <span class="sc-kLojOw iehvjW">Env</span><span class="sc-giAqHp bYgUJS">(</span>map<span class="sc-giAqHp bYgUJS">:</span> Map<span class="sc-giAqHp bYgUJS">&lt;</span><span class="sc-bYwzuL fDDjHD">string</span><span class="sc-giAqHp bYgUJS">,</span> Type<span class="sc-giAqHp bYgUJS">&gt;</span> <span class="sc-giAqHp bYgUJS">|</span> <span class="sc-giAqHp bYgUJS">{</span> <span class="sc-giAqHp bYgUJS">[</span>name<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-giAqHp bYgUJS">]</span><span class="sc-giAqHp bYgUJS">:</span> Type <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">:</span> Env <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span>map <span class="sc-ezzafa dvHFX">instanceof</span> <span class="sc-giAqHp bYgUJS">Map</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">{</span>
    <span class="sc-ezzafa dvHFX">return</span> <span class="sc-giAqHp bYgUJS">{</span>
      <span class="sc-dPaNzc fqbJCS">get</span><span class="sc-giAqHp bYgUJS">:</span> <span class="sc-giAqHp bYgUJS">(</span>name<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span> map<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">get</span><span class="sc-giAqHp bYgUJS">(</span>name<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">,</span>
      <span class="sc-dPaNzc fqbJCS">set</span><span class="sc-giAqHp bYgUJS">:</span> <span class="sc-giAqHp bYgUJS">(</span>name<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">string</span><span class="sc-giAqHp bYgUJS">,</span> type<span class="sc-giAqHp bYgUJS">:</span> Type<span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span>
        <span class="sc-kLojOw iehvjW">Env</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-ezzafa dvHFX">new</span> <span class="sc-giAqHp bYgUJS">Map</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">[</span><span class="sc-giAqHp bYgUJS">...</span>map<span class="sc-giAqHp bYgUJS">,</span> <span class="sc-giAqHp bYgUJS">[</span>name<span class="sc-giAqHp bYgUJS">,</span> type<span class="sc-giAqHp bYgUJS">]</span><span class="sc-giAqHp bYgUJS">]</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span>
      <span class="sc-dPaNzc fqbJCS">entries</span><span class="sc-giAqHp bYgUJS">:</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span> map<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">entries</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">)</span>
    <span class="sc-giAqHp bYgUJS">}</span>
  <span class="sc-giAqHp bYgUJS">}</span> <span class="sc-ezzafa dvHFX">else</span> <span class="sc-giAqHp bYgUJS">{</span>
    <span class="sc-ezzafa dvHFX">return</span> <span class="sc-kLojOw iehvjW">Env</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-ezzafa dvHFX">new</span> <span class="sc-giAqHp bYgUJS">Map</span><span class="sc-giAqHp bYgUJS">(</span>Object<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">entries</span><span class="sc-giAqHp bYgUJS">(</span>map<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-giAqHp bYgUJS">}</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><p><span>Bindings are stored in an underlying </span><span><code>Map</code></span><span>; to </span><span><code>get</code></span><span> the type of a variable, just look it up in the </span><span><code>Map</code></span><span>; to </span><span><code>set</code></span><span> the type of a variable, copy the </span><span><code>Map</code></span><span> and add the new binding. Like the </span><span><code>Type.object</code></span><span> constructor from </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1#constructors"><span>part 1</span></a><span>, </span><span><code>Env</code></span><span> can also take an object mapping names to types.</span></p><p><span>Finally we have an </span><span><code>Env</code></span><span> module with an </span><span><code>empty</code></span><span> environment; and we export these all under the same name:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">module</span> Env <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-ezzafa dvHFX">export</span> <span class="sc-ezzafa dvHFX">const</span> empty <span class="sc-giAqHp bYgUJS">=</span> <span class="sc-kLojOw iehvjW">Env</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">{</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
<span class="sc-giAqHp bYgUJS">}</span>

<span class="sc-ezzafa dvHFX">export</span> <span class="sc-ezzafa dvHFX">default</span> Env<span class="sc-giAqHp bYgUJS">;</span></code></pre><p><span>so we can refer to them uniformly as </span><span><code>Env</code></span><span>:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">import</span> Env <span class="sc-ezzafa dvHFX">from</span> <span class="sc-lmgQwP hpRDUw">&#x27;./env&#x27;</span><span class="sc-giAqHp bYgUJS">;</span>

<span class="sc-ezzafa dvHFX">const</span> env1<span class="sc-giAqHp bYgUJS">:</span> Env <span class="sc-giAqHp bYgUJS">=</span> Env<span class="sc-giAqHp bYgUJS">.</span>empty<span class="sc-giAqHp bYgUJS">;</span>
<span class="sc-ezzafa dvHFX">const</span> env2<span class="sc-giAqHp bYgUJS">:</span> Env <span class="sc-giAqHp bYgUJS">=</span> <span class="sc-kLojOw iehvjW">Env</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">{</span> foo<span class="sc-giAqHp bYgUJS">:</span> Type<span class="sc-giAqHp bYgUJS">.</span><span class="sc-bYwzuL fDDjHD">string</span> <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span></code></pre><p><span>(This relies on TypeScript&#x27;s </span><a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html" class="sc-gtsrHT kFWJEY"><span>declaration merging</span></a><span>—honestly I don&#x27;t understand it very well, but it does what I want here.)</span></p><h2 id="representing-function-types"><span>Representing function types</span></h2><p><span>To represent function types we add an arm to the </span><span><code>Type</code></span><span> union from </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1#representing-types"><span>part 1</span></a><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part2/src/type/types.ts#L30" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">type</span> <span class="sc-giAqHp bYgUJS">Type</span> <span class="sc-giAqHp bYgUJS">=</span> <span class="sc-giAqHp bYgUJS">...</span> <span class="sc-giAqHp bYgUJS">|</span> <span class="sc-bYwzuL fDDjHD">Function</span><span class="sc-giAqHp bYgUJS">;</span>
 
<span class="sc-ezzafa dvHFX">type</span> <span class="sc-bYwzuL fDDjHD">Function</span> <span class="sc-giAqHp bYgUJS">=</span> <span class="sc-giAqHp bYgUJS">{</span>
  type<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-lmgQwP hpRDUw">&#x27;Function&#x27;</span><span class="sc-giAqHp bYgUJS">;</span>
  args<span class="sc-giAqHp bYgUJS">:</span> Type<span class="sc-giAqHp bYgUJS">[</span><span class="sc-giAqHp bYgUJS">]</span><span class="sc-giAqHp bYgUJS">;</span>
  ret<span class="sc-giAqHp bYgUJS">:</span> Type<span class="sc-giAqHp bYgUJS">;</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><p><span>For example, a function type</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-giAqHp bYgUJS">(</span>x<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">number</span><span class="sc-giAqHp bYgUJS">,</span> y<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">number</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span> <span class="sc-bYwzuL fDDjHD">number</span></code></pre><p><span>is represented as</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-giAqHp bYgUJS">{</span>
  type<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-lmgQwP hpRDUw">&#x27;Function&#x27;</span><span class="sc-giAqHp bYgUJS">,</span>
  args<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-giAqHp bYgUJS">[</span> Type<span class="sc-giAqHp bYgUJS">.</span><span class="sc-bYwzuL fDDjHD">number</span><span class="sc-giAqHp bYgUJS">,</span> Type<span class="sc-giAqHp bYgUJS">.</span><span class="sc-bYwzuL fDDjHD">number</span> <span class="sc-giAqHp bYgUJS">]</span><span class="sc-giAqHp bYgUJS">,</span>
  ret<span class="sc-giAqHp bYgUJS">:</span> Type<span class="sc-giAqHp bYgUJS">.</span><span class="sc-bYwzuL fDDjHD">number</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><p><span>(We don&#x27;t store the argument names; they aren&#x27;t needed during type checking.)</span></p><p><span>We also add a constructor function (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part2/src/type/constructors.ts#L16" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">function</span> <span class="sc-kLojOw iehvjW">functionType</span><span class="sc-giAqHp bYgUJS">(</span>args<span class="sc-giAqHp bYgUJS">:</span> Types<span class="sc-giAqHp bYgUJS">.</span>Type<span class="sc-giAqHp bYgUJS">[</span><span class="sc-giAqHp bYgUJS">]</span><span class="sc-giAqHp bYgUJS">,</span> ret<span class="sc-giAqHp bYgUJS">:</span> Types<span class="sc-giAqHp bYgUJS">.</span>Type<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">:</span> Types<span class="sc-giAqHp bYgUJS">.</span><span class="sc-bYwzuL fDDjHD">Function</span> <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-ezzafa dvHFX">return</span> <span class="sc-giAqHp bYgUJS">{</span> type<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-lmgQwP hpRDUw">&#x27;Function&#x27;</span><span class="sc-giAqHp bYgUJS">,</span> args<span class="sc-giAqHp bYgUJS">,</span> ret <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">;</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><p><span>and a validator function (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part2/src/type/validators.ts#L23" class="sc-gtsrHT kFWJEY"><span>validators.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">export</span> <span class="sc-ezzafa dvHFX">function</span> <span class="sc-kLojOw iehvjW">isFunction</span><span class="sc-giAqHp bYgUJS">(</span>type<span class="sc-giAqHp bYgUJS">:</span> Types<span class="sc-giAqHp bYgUJS">.</span>Type<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">:</span> <span class="sc-ezzafa dvHFX">type</span> <span class="sc-ezzafa dvHFX">is</span> Types<span class="sc-giAqHp bYgUJS">.</span><span class="sc-bYwzuL fDDjHD">Function</span> <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-ezzafa dvHFX">return</span> type<span class="sc-giAqHp bYgUJS">.</span>type <span class="sc-giAqHp bYgUJS">===</span> <span class="sc-lmgQwP hpRDUw">&#x27;Function&#x27;</span><span class="sc-giAqHp bYgUJS">;</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><p><span>and cases for function types in </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part2/src/type/toString.ts#L18" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span> and </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part2/src/type/ofTSType.ts#L27" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span></span></p><h2 id="synthesizing-types-from-expressions"><span>Synthesizing types from expressions</span></h2><p><span>Now we can add cases to synthesize types (see </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1#synthesizing-types-from-expressions"><span>part 1</span></a><span>) from variable, function, and call expressions. First we need to update </span><span><code>synth</code></span><span> to take the current environment as an argument, and pass it down to all its helper functions and recursive calls; then add cases to dispatch to new helper functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part2/src/typecheck/synth.ts#L118" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">function</span> <span class="sc-kLojOw iehvjW">synth</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">:</span> Env<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span>Expression<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">:</span> Type <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-giAqHp bYgUJS">...</span>
  <span class="sc-ezzafa dvHFX">case</span> <span class="sc-lmgQwP hpRDUw">&#x27;Identifier&#x27;</span><span class="sc-giAqHp bYgUJS">:</span>              <span class="sc-ezzafa dvHFX">return</span> <span class="sc-kLojOw iehvjW">synthIdentifier</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">case</span> <span class="sc-lmgQwP hpRDUw">&#x27;ArrowFunctionExpression&#x27;</span><span class="sc-giAqHp bYgUJS">:</span> <span class="sc-ezzafa dvHFX">return</span> <span class="sc-kLojOw iehvjW">synthFunction</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">case</span> <span class="sc-lmgQwP hpRDUw">&#x27;CallExpression&#x27;</span><span class="sc-giAqHp bYgUJS">:</span>          <span class="sc-ezzafa dvHFX">return</span> <span class="sc-kLojOw iehvjW">synthCall</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-giAqHp bYgUJS">...</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><h3 id="variable-expressions"><span>Variable expressions</span></h3><p><span>To synthesize a type from a variable expression, we look it up in the environment:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">function</span> <span class="sc-kLojOw iehvjW">synthIdentifier</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">:</span> Env<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span>Identifier<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">:</span> Type <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-ezzafa dvHFX">const</span> type <span class="sc-giAqHp bYgUJS">=</span> env<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">get</span><span class="sc-giAqHp bYgUJS">(</span>ast<span class="sc-giAqHp bYgUJS">.</span>name<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">!</span>type<span class="sc-giAqHp bYgUJS">)</span> <span class="sc-kLojOw iehvjW">err</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">unbound identifier &#x27;</span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">ast</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">name</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-lmgQwP hpRDUw">&#x27;</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">return</span> type<span class="sc-giAqHp bYgUJS">;</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><p><span>or fail if the variable isn&#x27;t bound.</span></p><h3 id="function-expressions"><span>Function expressions</span></h3><p><span>To synthesize a type from a function expression like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-giAqHp bYgUJS">(</span>x<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">number</span><span class="sc-giAqHp bYgUJS">,</span> y<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">number</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">{</span> x<span class="sc-giAqHp bYgUJS">:</span> x<span class="sc-giAqHp bYgUJS">,</span> y<span class="sc-giAqHp bYgUJS">:</span> y <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">)</span></code></pre><p><span>we:</span></p><ul><li><p><span>add bindings to the environment for each function argument and its type;</span></p></li><li><p><span>synthesize the type of the function body using the new environment; and</span></p></li><li><p><span>return a function type from the argument types to the return type.</span></p></li></ul><p><span>Here&#x27;s the code:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">function</span> <span class="sc-kLojOw iehvjW">synthFunction</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">:</span> Env<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span>ArrowFunctionExpression<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">:</span> Type <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">!</span><span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isExpression</span><span class="sc-giAqHp bYgUJS">(</span>ast<span class="sc-giAqHp bYgUJS">.</span>body<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-kLojOw iehvjW">bug</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">unimplemented </span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">ast</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">body</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-ezzafa dvHFX">type</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">)</span>
  <span class="sc-ezzafa dvHFX">const</span> bindings <span class="sc-giAqHp bYgUJS">=</span> ast<span class="sc-giAqHp bYgUJS">.</span>params<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">map</span><span class="sc-giAqHp bYgUJS">(</span>param <span class="sc-giAqHp bYgUJS">=&gt;</span> <span class="sc-giAqHp bYgUJS">{</span>
    <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">!</span><span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isIdentifier</span><span class="sc-giAqHp bYgUJS">(</span>param<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-kLojOw iehvjW">bug</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">unimplemented </span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">param</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-ezzafa dvHFX">type</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
    <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">!</span>param<span class="sc-giAqHp bYgUJS">.</span><span class="sc-ezzafa dvHFX">type</span>Annotation<span class="sc-giAqHp bYgUJS">)</span> <span class="sc-kLojOw iehvjW">err</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">type required for &#x27;</span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">param</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">name</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-lmgQwP hpRDUw">&#x27;</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">,</span> param<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
    <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">!</span><span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isTSTypeAnnotation</span><span class="sc-giAqHp bYgUJS">(</span>param<span class="sc-giAqHp bYgUJS">.</span><span class="sc-ezzafa dvHFX">type</span>Annotation<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-kLojOw iehvjW">bug</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">unimplemented </span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">param</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-ezzafa dvHFX">type</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
    <span class="sc-ezzafa dvHFX">return</span> <span class="sc-giAqHp bYgUJS">{</span>
      name<span class="sc-giAqHp bYgUJS">:</span> param<span class="sc-giAqHp bYgUJS">.</span>name<span class="sc-giAqHp bYgUJS">,</span>
      type<span class="sc-giAqHp bYgUJS">:</span> Type<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">ofTSType</span><span class="sc-giAqHp bYgUJS">(</span>param<span class="sc-giAqHp bYgUJS">.</span><span class="sc-ezzafa dvHFX">type</span>Annotation<span class="sc-giAqHp bYgUJS">.</span><span class="sc-ezzafa dvHFX">type</span>Annotation<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">,</span>
    <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">const</span> args <span class="sc-giAqHp bYgUJS">=</span> bindings<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">map</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">{</span> <span class="sc-ezzafa dvHFX">type</span> <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span> type<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">const</span> bodyEnv <span class="sc-giAqHp bYgUJS">=</span>
    bindings<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">reduce</span><span class="sc-giAqHp bYgUJS">(</span>
      <span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">,</span> <span class="sc-giAqHp bYgUJS">{</span> name<span class="sc-giAqHp bYgUJS">,</span> <span class="sc-ezzafa dvHFX">type</span> <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span> env<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">set</span><span class="sc-giAqHp bYgUJS">(</span>name<span class="sc-giAqHp bYgUJS">,</span> type<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">,</span>
      env
    <span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">const</span> ret <span class="sc-giAqHp bYgUJS">=</span> <span class="sc-kLojOw iehvjW">synth</span><span class="sc-giAqHp bYgUJS">(</span>bodyEnv<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">.</span>body<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">return</span> Type<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">functionType</span><span class="sc-giAqHp bYgUJS">(</span>args<span class="sc-giAqHp bYgUJS">,</span> ret<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><p><span>We require that function arguments have type annotations so we can bind them in the environment, and convert the type annotations to our </span><span><code>Type</code></span><span> representation with </span><span><code>ofTSType</code></span><span>. As usual we exclude some syntax that we don&#x27;t handle.</span></p><h3 id="call-expressions"><span>Call expressions</span></h3><p><span>To synthesize a type from a call expression like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">f</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-cxNHIi fHUQtx">7</span><span class="sc-giAqHp bYgUJS">,</span> <span class="sc-cxNHIi fHUQtx">9</span><span class="sc-giAqHp bYgUJS">)</span></code></pre><p><span> we:</span></p><ul><li><p><span>synthesize the type of the left-hand side (the </span><span><em>callee</em></span><span>);</span></p></li><li><p><span>if it&#x27;s not a function type, fail;</span></p></li><li><p><span>check (see </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1#checking-expressions-against-types"><span>part 1</span></a><span>) each argument expression against the corresponding argument type; and</span></p></li><li><p><span>return the callee&#x27;s return type.</span></p></li></ul><p><span>Here&#x27;s the code:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">function</span> <span class="sc-kLojOw iehvjW">synthCall</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">:</span> Env<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span>CallExpression<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">:</span> Type <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">!</span><span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isExpression</span><span class="sc-giAqHp bYgUJS">(</span>ast<span class="sc-giAqHp bYgUJS">.</span>callee<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-kLojOw iehvjW">bug</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">unimplemented </span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">ast</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">callee</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-ezzafa dvHFX">type</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">const</span> callee <span class="sc-giAqHp bYgUJS">=</span> <span class="sc-kLojOw iehvjW">synth</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">.</span>callee<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">!</span>Type<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isFunction</span><span class="sc-giAqHp bYgUJS">(</span>callee<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-kLojOw iehvjW">err</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">call expects function</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">.</span>callee<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span>callee<span class="sc-giAqHp bYgUJS">.</span>args<span class="sc-giAqHp bYgUJS">.</span>length <span class="sc-giAqHp bYgUJS">!==</span> ast<span class="sc-giAqHp bYgUJS">.</span>arguments<span class="sc-giAqHp bYgUJS">.</span>length<span class="sc-giAqHp bYgUJS">)</span>
    <span class="sc-kLojOw iehvjW">err</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">expected </span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">callee</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">args</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">length</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-lmgQwP hpRDUw"> args, got </span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">ast</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">arguments</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">length</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-lmgQwP hpRDUw"> args</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  callee<span class="sc-giAqHp bYgUJS">.</span>args<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">forEach</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">(</span>type<span class="sc-giAqHp bYgUJS">,</span> i<span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span> <span class="sc-giAqHp bYgUJS">{</span>
    <span class="sc-ezzafa dvHFX">const</span> arg <span class="sc-giAqHp bYgUJS">=</span> ast<span class="sc-giAqHp bYgUJS">.</span>arguments<span class="sc-giAqHp bYgUJS">[</span>i<span class="sc-giAqHp bYgUJS">]</span><span class="sc-giAqHp bYgUJS">;</span>
    <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">!</span><span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isExpression</span><span class="sc-giAqHp bYgUJS">(</span>arg<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-kLojOw iehvjW">bug</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">unimplemented </span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">arg</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-ezzafa dvHFX">type</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">)</span>
    <span class="sc-kLojOw iehvjW">check</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">,</span> arg<span class="sc-giAqHp bYgUJS">,</span> type<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">return</span> callee<span class="sc-giAqHp bYgUJS">.</span>ret<span class="sc-giAqHp bYgUJS">;</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><p><span>It would be safe to allow a call to have fewer arguments than expected by the callee&#x27;s type when the missing arguments have types that are subtypes of </span><span><code>undefined</code></span><span>; I left this out for simplicity. To get this behavior in actual TypeScript you need to explicitly mark the argument as optional (with a trailing </span><span><code>?</code></span><span>). It would also be safe to allow calls with extra arguments, but it isn&#x27;t useful, and might be a bug, so better to flag an error.</span></p><h2 id="subtyping-function-types"><span>Subtyping function types</span></h2><p><span>When is a function type </span><span><code>A1 =&gt; A2</code></span><span> a subtype of </span><span><code>B1 =&gt; B2</code></span><span>?</span></p><p><span>Recall from </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>part 1</span></a><span> that we can think of subtyping as an adversarial game: I pass a function of type </span><span><code>A1 =&gt; A2</code></span><span> to an opponent who may perform any operations supported by type </span><span><code>B1 =&gt; B2</code></span><span> on it; if my opponent can&#x27;t perform any unsupported operations on the value, then </span><span><code>A1 =&gt; A2</code></span><span> is a subtype of </span><span><code>B1 =&gt; B2</code></span><span>.</span></p><p><span>My opponent may pass the function an argument of type </span><span><code>B1</code></span><span>, and the function (of type </span><span><code>A1 =&gt; A2</code></span><span>) may perform any operations on the argument that are supported by </span><span><code>A1</code></span><span>. So </span><span><code>B1</code></span><span> must be a subtype of </span><span><code>A1</code></span><span>,  since it must support any operation supported by </span><span><code>A1</code></span><span>. After the function returns a value (of type </span><span><code>A2</code></span><span>), my opponent may perform any operations supported by </span><span><code>B2</code></span><span>. So </span><span><code>A2</code></span><span> must be a subtype of </span><span><code>B2</code></span><span>.</span></p><p><span>We say that function types are </span><span><em>covariant</em></span><span> in their return type, because the subtyping goes the same way: if </span><span><code>A1 =&gt; A2</code></span><span> is a subtype of </span><span><code>B1 =&gt; B2</code></span><span> then </span><span><code>A2</code></span><span> is a subtype of </span><span><code>B2</code></span><span>. And we say that function types are </span><span><em>contravariant</em></span><span> in their argument types, because the subtyping goes the opposite way: if </span><span><code>A1 =&gt; A2</code></span><span> is a subtype of </span><span><code>B1 =&gt; B2</code></span><span> then </span><span><code>B1</code></span><span> is a subtype of </span><span><code>A1</code></span><span>.</span></p><p><span>So we add a case for function types to </span><span><code>isSubtype</code></span><span> as follows (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part2/src/type/isSubtype.ts" class="sc-gtsrHT kFWJEY"><span>isSubtype.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">function</span> <span class="sc-kLojOw iehvjW">isSubtype</span><span class="sc-giAqHp bYgUJS">(</span>a<span class="sc-giAqHp bYgUJS">:</span> Type<span class="sc-giAqHp bYgUJS">,</span> b<span class="sc-giAqHp bYgUJS">:</span> Type<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">:</span> <span class="sc-bYwzuL fDDjHD">boolean</span> <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-giAqHp bYgUJS">...</span>

  <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span>Type<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isFunction</span><span class="sc-giAqHp bYgUJS">(</span>a<span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">&amp;&amp;</span> Type<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isFunction</span><span class="sc-giAqHp bYgUJS">(</span>b<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">{</span>
    <span class="sc-ezzafa dvHFX">return</span> a<span class="sc-giAqHp bYgUJS">.</span>args<span class="sc-giAqHp bYgUJS">.</span>length <span class="sc-giAqHp bYgUJS">===</span> b<span class="sc-giAqHp bYgUJS">.</span>args<span class="sc-giAqHp bYgUJS">.</span>length <span class="sc-giAqHp bYgUJS">&amp;&amp;</span>
      a<span class="sc-giAqHp bYgUJS">.</span>args<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">every</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">(</span>a<span class="sc-giAqHp bYgUJS">,</span> i<span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span> <span class="sc-kLojOw iehvjW">isSubtype</span><span class="sc-giAqHp bYgUJS">(</span>b<span class="sc-giAqHp bYgUJS">.</span>args<span class="sc-giAqHp bYgUJS">[</span>i<span class="sc-giAqHp bYgUJS">]</span><span class="sc-giAqHp bYgUJS">,</span> a<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">&amp;&amp;</span>
      <span class="sc-kLojOw iehvjW">isSubtype</span><span class="sc-giAqHp bYgUJS">(</span>a<span class="sc-giAqHp bYgUJS">.</span>ret<span class="sc-giAqHp bYgUJS">,</span> b<span class="sc-giAqHp bYgUJS">.</span>ret<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-giAqHp bYgUJS">}</span>
  <span class="sc-giAqHp bYgUJS">...</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><p><span>It would be safe for a function type </span><span><code>(a: A) =&gt; C</code></span><span> to be a subtype of </span><span><code>(a: A, b: B) =&gt; C</code></span><span>, because the extra argument can be ignored. And it would be safe for a function type </span><span><code>(a: A, b: B | undefined) =&gt; C</code></span><span> to be a subtype of </span><span><code>(a: A) =&gt; C</code></span><span>, because the missing argument can be treated as </span><span><code>undefined</code></span><span>. I left these cases out for simplicity; actual TypeScript supports them (but again requires an explicit </span><span><code>?</code></span><span> marker in the second case).</span></p><h2 id="checking-function-expressions-against-function-types"><span>Checking function expressions against function types</span></h2><p><span>Recall from </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1#checking-expressions-against-types"><span>part 1</span></a><span> that to check an expression against a type, we break down the expression and type and check their corresponding parts. To check a function expression against a function type we:</span></p><ul><li><p><span>match up the function expression arguments against the function type arguments;</span></p></li><li><p><span>add each name-to-type binding to the environment; and</span></p></li><li><p><span>check the function body against the return type using the new environment.</span></p></li></ul><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part2/src/typecheck/check.ts" class="sc-gtsrHT kFWJEY"><span>check.ts</span></a><span>)</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-ezzafa dvHFX">function</span> <span class="sc-kLojOw iehvjW">check</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">:</span> Env<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span>Expression<span class="sc-giAqHp bYgUJS">,</span> type<span class="sc-giAqHp bYgUJS">:</span> Type<span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-giAqHp bYgUJS">...</span>
  <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isArrowFunctionExpression</span><span class="sc-giAqHp bYgUJS">(</span>ast<span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">&amp;&amp;</span> Type<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isFunction</span><span class="sc-giAqHp bYgUJS">(</span>type<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span>
    <span class="sc-ezzafa dvHFX">return</span> <span class="sc-kLojOw iehvjW">checkFunction</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">,</span> type<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-giAqHp bYgUJS">...</span>
<span class="sc-giAqHp bYgUJS">}</span>

<span class="sc-ezzafa dvHFX">function</span> <span class="sc-kLojOw iehvjW">checkFunction</span><span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">:</span> Env<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">:</span> <span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span>ArrowFunctionExpression<span class="sc-giAqHp bYgUJS">,</span> type<span class="sc-giAqHp bYgUJS">:</span> Type<span class="sc-giAqHp bYgUJS">.</span><span class="sc-bYwzuL fDDjHD">Function</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">{</span>
  <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">!</span><span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isExpression</span><span class="sc-giAqHp bYgUJS">(</span>ast<span class="sc-giAqHp bYgUJS">.</span>body<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-kLojOw iehvjW">bug</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">unimplemented </span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">ast</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">body</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-ezzafa dvHFX">type</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">)</span>
  <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span>type<span class="sc-giAqHp bYgUJS">.</span>args<span class="sc-giAqHp bYgUJS">.</span>length <span class="sc-giAqHp bYgUJS">!=</span> ast<span class="sc-giAqHp bYgUJS">.</span>params<span class="sc-giAqHp bYgUJS">.</span>length<span class="sc-giAqHp bYgUJS">)</span>
    <span class="sc-kLojOw iehvjW">err</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">expected </span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">type</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">args</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">length</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-lmgQwP hpRDUw"> args, got </span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">ast</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">params</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-giAqHp bYgUJS">length</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-lmgQwP hpRDUw"> args</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">const</span> bindings <span class="sc-giAqHp bYgUJS">=</span> ast<span class="sc-giAqHp bYgUJS">.</span>params<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">map</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">(</span>param<span class="sc-giAqHp bYgUJS">,</span> i<span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span> <span class="sc-giAqHp bYgUJS">{</span>
    <span class="sc-ezzafa dvHFX">if</span> <span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">!</span><span class="sc-iJCRrE bojiJp">AST</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">isIdentifier</span><span class="sc-giAqHp bYgUJS">(</span>param<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-kLojOw iehvjW">bug</span><span class="sc-giAqHp bYgUJS">(</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-lmgQwP hpRDUw">unimplemented </span><span class="sc-giAqHp bYgUJS">${</span><span class="sc-giAqHp bYgUJS">param</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-ezzafa dvHFX">type</span><span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">`</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
    <span class="sc-ezzafa dvHFX">return</span> <span class="sc-giAqHp bYgUJS">{</span> name<span class="sc-giAqHp bYgUJS">:</span> param<span class="sc-giAqHp bYgUJS">.</span>name<span class="sc-giAqHp bYgUJS">,</span> type<span class="sc-giAqHp bYgUJS">:</span> type<span class="sc-giAqHp bYgUJS">.</span>args<span class="sc-giAqHp bYgUJS">[</span>i<span class="sc-giAqHp bYgUJS">]</span> <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-ezzafa dvHFX">const</span> bodyEnv <span class="sc-giAqHp bYgUJS">=</span>
    bindings<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">reduce</span><span class="sc-giAqHp bYgUJS">(</span>
      <span class="sc-giAqHp bYgUJS">(</span>env<span class="sc-giAqHp bYgUJS">,</span> <span class="sc-giAqHp bYgUJS">{</span> name<span class="sc-giAqHp bYgUJS">,</span> <span class="sc-ezzafa dvHFX">type</span> <span class="sc-giAqHp bYgUJS">}</span><span class="sc-giAqHp bYgUJS">)</span> <span class="sc-giAqHp bYgUJS">=&gt;</span> env<span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">set</span><span class="sc-giAqHp bYgUJS">(</span>name<span class="sc-giAqHp bYgUJS">,</span> type<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">,</span>
      env
    <span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
  <span class="sc-kLojOw iehvjW">check</span><span class="sc-giAqHp bYgUJS">(</span>bodyEnv<span class="sc-giAqHp bYgUJS">,</span> ast<span class="sc-giAqHp bYgUJS">.</span>body<span class="sc-giAqHp bYgUJS">,</span> type<span class="sc-giAqHp bYgUJS">.</span>ret<span class="sc-giAqHp bYgUJS">)</span><span class="sc-giAqHp bYgUJS">;</span>
<span class="sc-giAqHp bYgUJS">}</span></code></pre><p><span>Again we could handle some cases here where the argument lists have different lengths; I&#x27;ve left them out for simplicity.</span></p><p><span>Note that we don&#x27;t require type annotations on the function arguments. I mentioned in </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> that a benefit of bidirectional type checking over just synthesis with subtyping is that it reduces necessary type annotations—when checking a function expression against a function type, we already know the argument types, so we can omit them in the expression. This is especially convenient with higher-order functions, like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-giAqHp bYgUJS">[</span><span class="sc-cxNHIi fHUQtx">1</span><span class="sc-giAqHp bYgUJS">,</span> <span class="sc-cxNHIi fHUQtx">2</span><span class="sc-giAqHp bYgUJS">,</span> <span class="sc-cxNHIi fHUQtx">3</span><span class="sc-giAqHp bYgUJS">]</span><span class="sc-giAqHp bYgUJS">.</span><span class="sc-kLojOw iehvjW">map</span><span class="sc-giAqHp bYgUJS">(</span>x <span class="sc-giAqHp bYgUJS">=&gt;</span> x <span class="sc-giAqHp bYgUJS">+</span> <span class="sc-cxNHIi fHUQtx">1</span><span class="sc-giAqHp bYgUJS">)</span></code></pre><p><span>However, if you do include argument type annotations we just ignore them; it would be better to check (as actual TypeScript does) that each argument type annotation is a subtype of the expected argument type.</span></p><h2 id="example"><span>Example?</span></h2><p><span>I tried to write up an example like I did for </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1#example"><span>part 1</span></a><span>, but with environments in the mix it got too complicated and tedious—instead I added an interactive call tree to the demo widget so you can work through examples yourself, see below.</span></p><h2 id="try-it"><span>Try it!</span></h2><p><span>You can try out the type checker below. In the top box, click on an example button or type an expression (remember that the supported expressions are primitive literals, object expressions, member expressions, variables, functions, function calls, and </span><span><code>as</code></span><span> ascriptions). In the bottom box you&#x27;ll see a trace of the type checker execution, ending in a synthesized type (or an error). The trace is a tree of function calls; click on a function call to expand the tree under that call, or mouse over a call to highlight the matching return value.</span></p><p><span>Notice how the environment changes when we </span><span><code>synth</code></span><span> a function expression or </span><span><code>check</code></span><span> a function expression against a function type. Also notice how type checking switches from </span><span><code>synth</code></span><span> to </span><span><code>check</code></span><span> when we </span><span><code>synth</code></span><span> a call expression.</span></p><iframe src="https://jaked.org/reconstructing-typescript/part2/" width="700" height="500" style="border-style:none"></iframe><h2 id="the-plan"><span>The plan</span></h2><p><span>For the full code of part 2 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part2" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part2</span></a><span>. To view the changes between part1 and part2 see </span><a href="https://github.com/jaked/reconstructing-typescript/compare/part1...part2" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/compare/part1...part2</span></a><span>.</span></p><p><span>Next time we&#x27;ll add </span><span><em>singleton</em></span><span> types and some operators so we can write more interesting programs.</span></p><ul><li><p><span></span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>Part 0: intro and background</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>Part 1: bidirectional type checking</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>Part 2: functions and function calls</span></a><span></span></p></li><li><p><span>Part 3: singleton / literal types and arithmetic / logical operators</span></p></li><li><p><span>Part 4: union types</span></p></li><li><p><span>Part 5: intersection types</span></p></li><li><p><span>Part 6: narrowing</span></p></li></ul><p><span>Please </span><a href="/blog/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p><p><span></span></p></div></body></html>