<html><head><title>Reconstructing TypeScript, part 3: singleton types and operators</title><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@jakedonham"/><meta name="twitter:creator" content="@jakedonham"/><meta name="twitter:title" content="Reconstructing TypeScript, part 3: singleton types and operators"/><meta name="twitter:title" content="Reconstructing TypeScript, part 3: singleton types and operators"/><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/2021-10-06-Reconstructing-TypeScript-part-3.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.bOWasK{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;overflow:auto;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"bOWasK,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.hbusih{color:#268bd2;}/*!sc*/
data-styled.g37[id="sc-iklJeh"]{content:"hbusih,"}/*!sc*/
.laKGqb{color:#000000;}/*!sc*/
data-styled.g38[id="sc-jJMGnK"]{content:"laKGqb,"}/*!sc*/
.dRsyqq{color:#aa1111;}/*!sc*/
data-styled.g39[id="sc-hiKfDv"]{content:"dRsyqq,"}/*!sc*/
.jKLUHq{color:#770088;}/*!sc*/
data-styled.g40[id="sc-gXfVKN"]{content:"jKLUHq,"}/*!sc*/
.lRfdj{color:#116644;}/*!sc*/
data-styled.g41[id="sc-cBoqAE"]{content:"lRfdj,"}/*!sc*/
.kyvWZW{color:#b58900;}/*!sc*/
data-styled.g43[id="sc-jcwpoC"]{content:"kyvWZW,"}/*!sc*/
.hBWCUB{color:#009900;}/*!sc*/
data-styled.g44[id="sc-carFqZ"]{content:"hBWCUB,"}/*!sc*/
.oxVOu{color:#221199;}/*!sc*/
data-styled.g45[id="sc-iTVJFM"]{content:"oxVOu,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript, part 3</span></p><h1 id="reconstructing-typescript-part-3-operators-and-singleton-types"><span>Reconstructing TypeScript, part 3: operators and singleton types</span></h1><h3 id="2021-10-06"><span><em>2021-10-06</em></span></h3><p><span>This post is part of a series about implementing type checking for a TypeScript-like language. In </span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>part 2</span></a><span> we added functions and function applications to the core bidirectional type checker from </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>part 1</span></a><span>. In this part we&#x27;ll add operator expressions like:</span></p><pre class="sc-bdnxRM bOWasK"><code>x <span class="sc-jJMGnK laKGqb">+</span> y
x <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> y
x <span class="sc-jJMGnK laKGqb">||</span> y
<span class="sc-jJMGnK laKGqb">!</span>x
<span class="sc-gXfVKN jKLUHq">typeof</span> x
x <span class="sc-jJMGnK laKGqb">===</span> y
x <span class="sc-jJMGnK laKGqb">!==</span> y</code></pre><p><span>so we&#x27;ll be able to write more interesting programs. We&#x27;ll also add a new kind of type: </span><span><em>singleton</em></span><span> types (also known as </span><span><em>literal</em></span><span> types) that contain a single value.</span></p><p><span>These two new features are connected: when the inputs to an operator have singleton types, the type checker can compute the output value at type checking time, and synthesize a singleton output type. This gives the type checker more information to work with, so it can successfully synthesize a type for more programs.</span></p><h2 id="whats-a-singleton-type"><span>What&#x27;s a singleton type?</span></h2><p><span>In </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> I wrote that a type</span></p><blockquote><p><span>describes attributes shared by [a collection of] values: what operations are supported; and, for some operations, what result they return.</span></p></blockquote><p><span>We say that a type </span><span><em>contains</em></span><span> a value (or that a value </span><span><em>satisfies</em></span><span> a type) when the value has all the attributes that are described by the type.</span></p><p><span>A </span><span><em>singleton</em></span><span> type is a type that contains a single value. For example: </span><span><code>7</code></span><span> is the type that contains the value </span><span><code>7</code></span><span>, </span><span><code>true</code></span><span> is the type that contains the value </span><span><code>true</code></span><span>, and so on. You might object—there is not just one value </span><span><code>7</code></span><span>, my program is littered with </span><span><code>7</code></span><span>s! OK, fair, let&#x27;s try again: a singleton type contains all the values that are </span><span><code>===</code></span><span> to a particular value. (JavaScript has a </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness" class="sc-gtsrHT kFWJEY"><span>profusion of equalities</span></a><span> so we should be specific which one we mean.)</span></p><p><span>The value of a singleton type has some underlying base type (</span><span><code>number</code></span><span> for </span><span><code>7</code></span><span>, </span><span><code>boolean</code></span><span> for </span><span><code>true</code></span><span>, and so on), so we call that the base type of the singleton type. A singleton type supports all the same operations as its base type; but it adds some information about what results are returned by the operations for its particular value. For example: in an expression </span><span><code>x === 7</code></span><span>, if </span><span><code>x</code></span><span> has type </span><span><code>number</code></span><span> we don&#x27;t know whether the expression returns </span><span><code>true</code></span><span> or </span><span><code>false</code></span><span>; but if </span><span><code>x</code></span><span> has type </span><span><code>7</code></span><span> we know that it returns </span><span><code>true</code></span><span>.</span></p><p><span>What about a compound type like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">true</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>? This type contains all the values that have a </span><span><code>foo</code></span><span> property with type </span><span><code>7</code></span><span> and a </span><span><code>bar</code></span><span> property with type </span><span><code>true</code></span><span>, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">true</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-jJMGnK laKGqb">,</span> baz<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;hello&#x27;</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>It&#x27;s tempting to read it as the type of values equal to </span><span><code>{ foo: 7, bar: true }</code></span><span>, but in TypeScript there are only singleton types of primitive values.</span></p><p><span>The TypeScript docs call these </span><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types" class="sc-gtsrHT kFWJEY"><span><em>literal</em></span><span> types</span></a><span>; they&#x27;re called singleton types in some other languages.</span></p><h2 id="what-are-singleton-types-good-for"><span>What are singleton types good for?</span></h2><p><span>By themselves, singleton types aren&#x27;t very useful. But with unions, we can use them to define enumerations:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">color</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-hiKfDv dRsyqq">&#x27;red&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;green&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;blue&#x27;</span></code></pre><p><span>or variants:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">tree</span> <span class="sc-jJMGnK laKGqb">=</span>
  <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;leaf&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> value<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span>
  <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;node&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> left<span class="sc-jJMGnK laKGqb">:</span> tree<span class="sc-jJMGnK laKGqb">,</span> right<span class="sc-jJMGnK laKGqb">:</span> tree <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>And with </span><span><em>intersection</em></span><span> types (more on this in part 5), we can use singleton types to describe overloaded functions that return different types based on argument values, like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">const</span> getElementsByTagName<span class="sc-jJMGnK laKGqb">:</span>
  <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span>tag<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;div&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> HTMLDivElement<span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;</span>
  <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span>tag<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;p&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> HTMLParagraphElement<span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;</span>
  <span class="sc-jJMGnK laKGqb">...</span></code></pre><h2 id="representing-singleton-types"><span>Representing singleton types</span></h2><p><span>To represent singleton types we add an arm to the </span><span><code>Type</code></span><span> union (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/types.ts#L37" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>) containing the base type (as above, we permit only primitive types) and value:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">Type</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">...</span> <span class="sc-jJMGnK laKGqb">|</span> Singleton<span class="sc-jJMGnK laKGqb">;</span>

<span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">Singleton</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span>
  type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
  base<span class="sc-jJMGnK laKGqb">:</span> Boolean <span class="sc-jJMGnK laKGqb">|</span> Number <span class="sc-jJMGnK laKGqb">|</span> String<span class="sc-jJMGnK laKGqb">;</span>
  value<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">unknown</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>When </span><span><code>base</code></span><span> is </span><span><code>Boolean</code></span><span>, </span><span><code>value</code></span><span> is always a </span><span><code>boolean</code></span><span>, and so on. (We could encode this invariant in the type, but it turns out not to work well with TypeScript&#x27;s narrowing—give it a try and see what goes wrong; more on this later.)</span></p><p><span>The type of </span><span><code>base</code></span><span> is an example of the flexibility of unions: we want to restrict </span><span><code>Type</code></span><span> to just its </span><span><code>Boolean</code></span><span>, </span><span><code>Number</code></span><span>, and </span><span><code>String</code></span><span> arms, so we simply write the union of those arms. In most languages this is much more painful: in most object-oriented languages we&#x27;d need to bake it into the class hierarchy; in most languages with variants we&#x27;d need a separate variant—either way, it&#x27;s painful enough that we&#x27;d most likely give </span><span><code>base</code></span><span> the type </span><span><code>Type</code></span><span> instead, and check the restriction at run time (losing some development-time checking).</span></p><p><span>As usual we add a constructor function (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/constructors.ts#L20" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>value<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">boolean</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-iklJeh hbusih">string</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Singleton <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">typeof</span> value<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;boolean&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> base<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">,</span> value <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;number&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> base<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> value <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;string&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> base<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">string</span><span class="sc-jJMGnK laKGqb">,</span> value <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>and a validator function (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/validators.ts#L27" class="sc-gtsrHT kFWJEY"><span>validators.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-gXfVKN jKLUHq">is</span> Singleton <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> type<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>and cases for singleton types in </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/toString.ts#L24" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span> and </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/ofTSType.ts#L40" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span>.</span></p><h2 id="synthesizing-types-from-primitive-values"><span>Synthesizing types from primitive values</span></h2><p><span>Now when synthesizing types from primitive expressions (</span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L556" class="sc-gtsrHT kFWJEY"><span><code>BooleanLiteral</code></span></a><span>, </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L539" class="sc-gtsrHT kFWJEY"><span><code>NumericLiteral</code></span></a><span>, </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L534" class="sc-gtsrHT kFWJEY"><span><code>StringLiteral</code></span></a><span>), we return a singleton type instead of the underlying base type (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/typecheck/synth.ts#L22" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthBoolean</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>BooleanLiteral<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthNumber</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>NumericLiteral<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthString</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>StringLiteral<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>In actual TypeScript, singleton types are synthesized for immutable values but not mutable values. This makes sense—a mutable value of singleton type is effectively immutable, since you can only mutate it to another value that&#x27;s </span><span><code>===</code></span><span> to the original. For example:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">const</span> x <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-cBoqAE lRfdj">7</span>  <span class="sc-carFqZ hBWCUB">// x has type 7</span>
<span class="sc-gXfVKN jKLUHq">let</span> y <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-iTVJFM oxVOu">true</span> <span class="sc-carFqZ hBWCUB">// y has type boolean</span>

<span class="sc-gXfVKN jKLUHq">const</span> obj1 <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">true</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-carFqZ hBWCUB">// obj1 has type { foo: number, bar: boolean }</span>

<span class="sc-gXfVKN jKLUHq">const</span> obj2 <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">true</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-gXfVKN jKLUHq">as</span> <span class="sc-gXfVKN jKLUHq">const</span>
<span class="sc-carFqZ hBWCUB">// obj2 has type { readonly foo: 7, readonly bar: true }</span></code></pre><p><span>In our language we have only immutable values, so we always synthesize singleton types.</span></p><h2 id="synthesizing-types-from-operator-expressions"><span>Synthesizing types from operator expressions</span></h2><p><span>We add cases to </span><span><code>synth</code></span><span> for different kinds of operator expression (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/typecheck/synth.ts#L217" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>Expression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-jJMGnK laKGqb">...</span>
  <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;BinaryExpression&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>  <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jcwpoC kyvWZW">synthBinary</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;LogicalExpression&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jcwpoC kyvWZW">synthLogical</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;UnaryExpression&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>   <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jcwpoC kyvWZW">synthUnary</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">...</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><h3 id="binary-operators"><span>Binary operators</span></h3><p><span>For binary operators (</span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L357" class="sc-gtsrHT kFWJEY"><span><code>BinaryExpression</code></span></a><span>) we:</span></p><ul><li><p><span>synthesize types from the </span><span><code>left</code></span><span> and </span><span><code>right</code></span><span> subexpressions;</span></p></li><li><p><span>when both have singleton type, apply the operator and return a singleton type;</span></p></li><li><p><span>otherwise return the appropriate base type,</span></p></li></ul><p><span>Here&#x27;s the code:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthBinary</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>BinaryExpression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">!</span><span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isExpression</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jcwpoC kyvWZW">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">ast</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">left</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-gXfVKN jKLUHq">type</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span>
  <span class="sc-gXfVKN jKLUHq">const</span> left <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">const</span> right <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>right<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>operator<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;===&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>right<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>
        <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">===</span> right<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span>
        <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">;</span>

    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;!==&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>right<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>
        <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">!==</span> right<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span>
        <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">;</span>

    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;+&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">,</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>right<span class="sc-jJMGnK laKGqb">,</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
        <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>right<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
          <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">typeof</span> left<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">!==</span> <span class="sc-hiKfDv dRsyqq">&#x27;number&#x27;</span> <span class="sc-jJMGnK laKGqb">||</span> <span class="sc-gXfVKN jKLUHq">typeof</span> right<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">!==</span> <span class="sc-hiKfDv dRsyqq">&#x27;number&#x27;</span><span class="sc-jJMGnK laKGqb">)</span>
            <span class="sc-jcwpoC kyvWZW">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-hiKfDv dRsyqq">&#x27;unexpected value&#x27;</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
          <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">+</span> right<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
        <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-gXfVKN jKLUHq">else</span> <span class="sc-jJMGnK laKGqb">{</span>
          <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">;</span>
        <span class="sc-jJMGnK laKGqb">}</span>
      <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-gXfVKN jKLUHq">else</span> <span class="sc-jJMGnK laKGqb">{</span>
        <span class="sc-jcwpoC kyvWZW">err</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-hiKfDv dRsyqq">&#x27;+ expects numbers&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-jJMGnK laKGqb">}</span>

    <span class="sc-gXfVKN jKLUHq">default</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jcwpoC kyvWZW">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">ast</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">operator</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>In the case for </span><span><code>+</code></span><span>, we check subtyping rather than equality with </span><span><code>number</code></span><span>, so we can add a singleton </span><span><code>number</code></span><span> to a </span><span><code>number</code></span><span> or vice versa. (See below about </span><a href="/blog/2021-10-06-Reconstructing-TypeScript-part-3#subtyping-singleton-types"><span>subtyping singleton types</span></a><span>.)</span></p><p><span>Actual TypeScript does not synthesize singleton types for these operators. I have some ideas about why not, but let&#x27;s go with it for now and see where it leads.</span></p><h3 id="logical-operators"><span>Logical operators</span></h3><p><span>We&#x27;ll need some helper functions that determine whether values of a type are known at type checking time to be </span><a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" class="sc-gtsrHT kFWJEY"><span>truthy or falsy</span></a><span>. For singletons we can check the specific value; otherwise we know that objects and functions are always truthy, </span><span><code>null</code></span><span> is falsy, and for numbers, strings, and booleans we don&#x27;t know.</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">isTruthy</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">.</span>type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>    <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Function&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>  <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> type<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">default</span><span class="sc-jJMGnK laKGqb">:</span>          <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iTVJFM oxVOu">false</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">isFalsy</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">.</span>type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Null&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>      <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jJMGnK laKGqb">!</span>type<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">default</span><span class="sc-jJMGnK laKGqb">:</span>          <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iTVJFM oxVOu">false</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>Now for logical operators (</span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L576" class="sc-gtsrHT kFWJEY"><span><code>LogicalExpression</code></span></a><span>) we:</span></p><ul><li><p><span>synthesize types from the </span><span><code>left</code></span><span> and </span><span><code>right</code></span><span> subexpressions;</span></p></li><li><p><span>when we know at type checking time which subexpression is returned, then return its type (recall that in JavaScript </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND" class="sc-gtsrHT kFWJEY"><span>logical operators are short-circuit and return the value of the last-evaluated subexpression</span></a><span>);</span></p></li><li><p><span>otherwise return </span><span><code>boolean</code></span><span> (this is not correct but we can&#x27;t return the correct type until we add unions in part 4).</span></p></li></ul><p><span>Here&#x27;s the code:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthLogical</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>LogicalExpression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">const</span> left <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">const</span> right <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>right<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>operator<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;&amp;&amp;&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isFalsy</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>       <span class="sc-gXfVKN jKLUHq">return</span> left<span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span> <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isTruthy</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-gXfVKN jKLUHq">return</span> right<span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span>                          <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-carFqZ hBWCUB">// left | right</span>

    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;||&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isTruthy</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>      <span class="sc-gXfVKN jKLUHq">return</span> left<span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span> <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isFalsy</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>  <span class="sc-gXfVKN jKLUHq">return</span> right<span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span>                          <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-carFqZ hBWCUB">// left | right</span>

    <span class="sc-gXfVKN jKLUHq">default</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jcwpoC kyvWZW">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">ast</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">operator</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>Actual TypeScript does synthesize singleton types for these operators—for example:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">const</span> a <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-cBoqAE lRfdj">7</span>
<span class="sc-gXfVKN jKLUHq">const</span> b <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-cBoqAE lRfdj">9</span>
<span class="sc-gXfVKN jKLUHq">const</span> x <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">(</span>a <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> b<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-carFqZ hBWCUB">// x has type 9</span></code></pre><h3 id="unary-operators"><span>Unary operators</span></h3><p><span>For unary operators (</span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L705" class="sc-gtsrHT kFWJEY"><span><code>UnaryExpression</code></span></a><span>) we</span></p><ul><li><p><span>synthesize a type from the </span><span><code>argument</code></span><span> subexpression;</span></p></li><li><p><span>for </span><span><code>!</code></span><span> return a singleton if we know whether the argument is truthy or falsy; otherwise return </span><span><code>boolean</code></span></p></li><li><p><span>for </span><span><code>typeof</code></span><span> return the appropriate singleton given the argument type.</span></p></li></ul><p><span>Here&#x27;s the code:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-gXfVKN jKLUHq">type</span><span class="sc-jcwpoC kyvWZW">ofType</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">string</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">.</span>type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-gXfVKN jKLUHq">type</span><span class="sc-jcwpoC kyvWZW">ofType</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">.</span>base<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Boolean&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;boolean&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Function&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;function&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Null&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;object&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Number&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;number&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;object&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;String&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;string&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthUnary</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>UnaryExpression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">const</span> argument <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>argument<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>operator<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;!&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isTruthy</span><span class="sc-jJMGnK laKGqb">(</span>argument<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>     <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-iTVJFM oxVOu">false</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span> <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isFalsy</span><span class="sc-jJMGnK laKGqb">(</span>argument<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-iTVJFM oxVOu">true</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span>                             <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">;</span>

    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;typeof&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">type</span><span class="sc-jcwpoC kyvWZW">ofType</span><span class="sc-jJMGnK laKGqb">(</span>argument<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>

    <span class="sc-gXfVKN jKLUHq">default</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jcwpoC kyvWZW">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">ast</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">operator</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>Actual TypeScript synthesizes singleton types for </span><span><code>!</code></span><span> but not for </span><span><code>typeof</code></span><span>. I don&#x27;t know why not! But again let&#x27;s go with it.</span></p><h2 id="subtyping-singleton-types"><span>Subtyping singleton types</span></h2><p><span>A singleton type is a subtype of another singleton type only when they have the same value.</span></p><p><span>A singleton type is always a subtype of its base type (as above, it supports all the same operations as its base type), so it&#x27;s a subtype of another type when its base type is a subtype of the other type. So for example </span><span><code>7</code></span><span> is a subtype of </span><span><code>number</code></span><span>. (We&#x27;ll be able to construct less-trivial examples once we add unions.)</span></p><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/isSubtype.ts#L27" class="sc-gtsrHT kFWJEY"><span>isSubtype.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">,</span> b<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">boolean</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-jJMGnK laKGqb">...</span>
  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>b<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-gXfVKN jKLUHq">return</span> a<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">===</span> b<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">else</span>                     <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">.</span>base<span class="sc-jJMGnK laKGqb">,</span> b<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
  <span class="sc-jJMGnK laKGqb">...</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><h2 id="checking-expressions-against-singleton-types"><span>Checking expressions against singleton types</span></h2><p><span>Recall from </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1#checking-expressions-against-types"><span>part 1</span></a><span> that to check an expression against a type, we break down the expression and type, then check their corresponding parts. But since we have singleton types for primitive values only, there&#x27;s nothing to break down—we just fall back to the default: synthesize a type from the expression, then check that the synthesized type is a subtype of the expected type. So there is no new code to write.</span></p><p><span>Operator expressions are always synthesized; we can&#x27;t in general deduce input types from output types. For example, to check </span><span><code>x + y</code></span><span> against </span><span><code>16</code></span><span>, we know that </span><span><code>x</code></span><span> and </span><span><code>y</code></span><span> must have singleton </span><span><code>number</code></span><span> types that sum to </span><span><code>16</code></span><span>, but we don&#x27;t know how to split </span><span><code>16</code></span><span> between them. So we fall back to synthesizing and checking subtyping. (In part 6 we&#x27;ll see that narrowing involves deducing </span><span><em>constraints</em></span><span> on input types from output types.)</span></p><h2 id="try-it"><span>Try it!</span></h2><p><span>You can try out the type checker below. Click on an example button or type an expression in the top box. In the bottom box you&#x27;ll see a trace of the type checker execution, ending in a synthesized type (or an error). The trace is a tree of function calls; click on a function call to expand the tree under that call, or mouse over a call to highlight the matching return value.</span></p><iframe src="https://jaked.org/reconstructing-typescript/part3/" width="700" height="500" style="border-style:none"></iframe><h2 id="the-plan"><span>The plan</span></h2><p><span>For the full code of part 3 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part3" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part3</span></a><span>. To view the changes between part 2 and part 3 see </span><a href="https://github.com/jaked/reconstructing-typescript/compare/part2...part3" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/compare/part2...part3</span></a><span>.</span></p><p><span>Next time we&#x27;ll add </span><span><em>union</em></span><span> types to represent type alternatives like </span><span><code>string | boolean</code></span><span>.</span></p><ul><li><p><span></span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>Part 0: intro and background</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>Part 1: bidirectional type checking</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>Part 2: functions and function calls</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-06-Reconstructing-TypeScript-part-3"><span>Part 3: operators and singleton types</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4"><span>Part 4: union types</span></a><span></span></p></li><li><p><span>Part 5: intersection types</span></p></li><li><p><span>Part 6: narrowing</span></p></li></ul><p><span>Thanks to Hazem Alhalabi for helpful feedback on a draft of this post.</span></p><p><span>Please </span><a href="/blog/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p><p><span></span></p></div></body></html>