<html><head><title>Reconstructing TypeScript, part 3: singleton types and operators</title><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@jakedonham"/><meta name="twitter:creator" content="@jakedonham"/><meta name="twitter:title" content="Reconstructing TypeScript, part 3: singleton types and operators"/><meta name="twitter:title" content="Reconstructing TypeScript, part 3: singleton types and operators"/><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/2021-10-06-Reconstructing-TypeScript-part-3.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.bOWasK{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;overflow:auto;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"bOWasK,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.hbusih{color:#268bd2;}/*!sc*/
data-styled.g37[id="sc-iklJeh"]{content:"hbusih,"}/*!sc*/
.laKGqb{color:#000000;}/*!sc*/
data-styled.g38[id="sc-jJMGnK"]{content:"laKGqb,"}/*!sc*/
.dRsyqq{color:#aa1111;}/*!sc*/
data-styled.g39[id="sc-hiKfDv"]{content:"dRsyqq,"}/*!sc*/
.jKLUHq{color:#770088;}/*!sc*/
data-styled.g40[id="sc-gXfVKN"]{content:"jKLUHq,"}/*!sc*/
.lRfdj{color:#116644;}/*!sc*/
data-styled.g41[id="sc-cBoqAE"]{content:"lRfdj,"}/*!sc*/
.kyvWZW{color:#b58900;}/*!sc*/
data-styled.g43[id="sc-jcwpoC"]{content:"kyvWZW,"}/*!sc*/
.hBWCUB{color:#009900;}/*!sc*/
data-styled.g44[id="sc-carFqZ"]{content:"hBWCUB,"}/*!sc*/
.oxVOu{color:#221199;}/*!sc*/
data-styled.g45[id="sc-iTVJFM"]{content:"oxVOu,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript, part 3</span></p><h1 id="reconstructing-typescript-part-3-operators-and-singleton-types"><span>Reconstructing TypeScript, part 3: operators and singleton types</span></h1><h3 id="2021-10-06"><span><em>2021-10-06</em></span></h3><p><span>This post is part of a series about implementing type checking for a TypeScript-like language. In </span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>part 2</span></a><span> we added functions and function applications to the core bidirectional type checker from </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>part 1</span></a><span>. In this part we&#x27;ll add operator expressions like:</span></p><pre class="sc-bdnxRM bOWasK"><code>x <span class="sc-jJMGnK laKGqb">+</span> y
x <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> y
x <span class="sc-jJMGnK laKGqb">||</span> y
<span class="sc-jJMGnK laKGqb">!</span>x
<span class="sc-gXfVKN jKLUHq">typeof</span> x
x <span class="sc-jJMGnK laKGqb">===</span> y
x <span class="sc-jJMGnK laKGqb">!==</span> y</code></pre><p><span>so we&#x27;ll be able to write more interesting programs. We&#x27;ll also add a new kind of type: </span><span><em>singleton</em></span><span> types (also known as </span><span><em>literal</em></span><span> types) that contain a single value.</span></p><p><span>These two new features are connected: when the inputs to an operator have singleton types, the type checker can compute the output value at type checking time, and synthesize a singleton output type. This gives the type checker more information to work with, so it can successfully synthesize a type for more programs.</span></p><h2 id="whats-a-singleton-type"><span>What&#x27;s a singleton type?</span></h2><p><span>In </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> I wrote that a type</span></p><blockquote><p><span>describes attributes shared by [a collection of] values: what operations are supported; and, for some operations, what result they return.</span></p></blockquote><p><span>We say that a type </span><span><em>contains</em></span><span> a value (or that a value </span><span><em>satisfies</em></span><span> a type) when the value has all the attributes that are described by the type.</span></p><p><span>A </span><span><em>singleton</em></span><span> type is a type that contains a single value. For example: </span><span><code>7</code></span><span> is the type that contains the value </span><span><code>7</code></span><span>, </span><span><code>true</code></span><span> is the type that contains the value </span><span><code>true</code></span><span>, and so on. You might objectâ€”there is not just one value </span><span><code>7</code></span><span>, my program is littered with </span><span><code>7</code></span><span>s! OK, fair, let&#x27;s try again: a singleton type contains all the values that are </span><span><code>===</code></span><span> to a particular value. (JavaScript has a </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness" class="sc-gtsrHT kFWJEY"><span>profusion of equalities</span></a><span> so we should be specific which one we mean.)</span></p><p><span>The value of a singleton type has some underlying base type (</span><span><code>number</code></span><span> for </span><span><code>7</code></span><span>, </span><span><code>boolean</code></span><span> for </span><span><code>true</code></span><span>, and so on), so we call that the base type of the singleton type. A singleton type supports all the same operations as its base type; but it adds some information about what results are returned by the operations for its particular value. For example: in an expression </span><span><code>x === 7</code></span><span>, if </span><span><code>x</code></span><span> has type </span><span><code>number</code></span><span> we don&#x27;t know whether the expression returns </span><span><code>true</code></span><span> or </span><span><code>false</code></span><span>; but if </span><span><code>x</code></span><span> has type </span><span><code>7</code></span><span> we know that it returns </span><span><code>true</code></span><span>.</span></p><p><span>What about a compound type like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">true</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>? This type contains all the values that have a </span><span><code>foo</code></span><span> property with type </span><span><code>7</code></span><span> and a </span><span><code>bar</code></span><span> property with type </span><span><code>true</code></span><span>, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">true</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-jJMGnK laKGqb">,</span> baz<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;hello&#x27;</span> <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>It&#x27;s tempting to read it as the type of values equal to </span><span><code>{ foo: 7, bar: true }</code></span><span>, but in TypeScript there are only singleton types of primitive values.</span></p><p><span>The TypeScript docs call these </span><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types" class="sc-gtsrHT kFWJEY"><span><em>literal</em></span><span> types</span></a><span>; they&#x27;re called singleton types in some other languages.</span></p><h2 id="what-are-singleton-types-good-for"><span>What are singleton types good for?</span></h2><p><span>By themselves, singleton types aren&#x27;t very useful. But with unions, we can use them to define enumerations:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">color</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-hiKfDv dRsyqq">&#x27;red&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;green&#x27;</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-hiKfDv dRsyqq">&#x27;blue&#x27;</span></code></pre><p><span>or variants:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">tree</span> <span class="sc-jJMGnK laKGqb">=</span>
  <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;leaf&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> value<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-jJMGnK laKGqb">|</span>
  <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;node&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> left<span class="sc-jJMGnK laKGqb">:</span> tree<span class="sc-jJMGnK laKGqb">,</span> right<span class="sc-jJMGnK laKGqb">:</span> tree <span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>And with </span><span><em>intersection</em></span><span> types (more on this in part 5), we can use singleton types to describe overloaded functions that return different types based on argument values, like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">const</span> getElementsByTagName<span class="sc-jJMGnK laKGqb">:</span>
  <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span>tag<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;div&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> HTMLDivElement<span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;</span>
  <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">(</span>tag<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;p&#x27;</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">=&gt;</span> HTMLParagraphElement<span class="sc-jJMGnK laKGqb">[</span><span class="sc-jJMGnK laKGqb">]</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;</span>
  <span class="sc-jJMGnK laKGqb">...</span></code></pre><h2 id="representing-singleton-types"><span>Representing singleton types</span></h2><p><span>To represent singleton types we add an arm to the </span><span><code>Type</code></span><span> union (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/types.ts#L37" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>) containing the base type (as above, we permit only primitive types) and value:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">Type</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">...</span> <span class="sc-jJMGnK laKGqb">|</span> Singleton<span class="sc-jJMGnK laKGqb">;</span>

<span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-jJMGnK laKGqb">Singleton</span> <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span>
  type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
  base<span class="sc-jJMGnK laKGqb">:</span> Boolean <span class="sc-jJMGnK laKGqb">|</span> Number <span class="sc-jJMGnK laKGqb">|</span> String<span class="sc-jJMGnK laKGqb">;</span>
  value<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">unknown</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>When </span><span><code>base</code></span><span> is </span><span><code>Boolean</code></span><span>, </span><span><code>value</code></span><span> is always a </span><span><code>boolean</code></span><span>, and so on. (We could encode this invariant in the type, but it turns out not to work well with TypeScript&#x27;s narrowingâ€”give it a try and see what goes wrong; more on this later.)</span></p><p><span>The type of </span><span><code>base</code></span><span> is an example of the flexibility of unions: we want to restrict </span><span><code>Type</code></span><span> to just its </span><span><code>Boolean</code></span><span>, </span><span><code>Number</code></span><span>, and </span><span><code>String</code></span><span> arms, so we simply write the union of those arms. In most languages this is much more painful: in most object-oriented languages we&#x27;d need to bake it into the class hierarchy; in most languages with variants we&#x27;d need a separate variantâ€”either way, it&#x27;s painful enough that we&#x27;d most likely give </span><span><code>base</code></span><span> the type </span><span><code>Type</code></span><span> instead, and check the restriction at run time (losing some development-time checking).</span></p><p><span>As usual we add a constructor function (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/constructors.ts#L20" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>value<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">boolean</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-iklJeh hbusih">number</span> <span class="sc-jJMGnK laKGqb">|</span> <span class="sc-iklJeh hbusih">string</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Singleton <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">typeof</span> value<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;boolean&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> base<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">,</span> value <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;number&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> base<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">,</span> value <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;string&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jJMGnK laKGqb">{</span> type<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> base<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">string</span><span class="sc-jJMGnK laKGqb">,</span> value <span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>and a validator function (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/validators.ts#L27" class="sc-gtsrHT kFWJEY"><span>validators.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">type</span> <span class="sc-gXfVKN jKLUHq">is</span> Singleton <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> type<span class="sc-jJMGnK laKGqb">.</span>type <span class="sc-jJMGnK laKGqb">===</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>and cases for singleton types in </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/toString.ts#L24" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span> and </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/ofTSType.ts#L40" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span>.</span></p><h2 id="synthesizing-types-from-primitive-values"><span>Synthesizing types from primitive values</span></h2><p><span>Now when synthesizing types from primitive expressions (</span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L556" class="sc-gtsrHT kFWJEY"><span><code>BooleanLiteral</code></span></a><span>, </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L539" class="sc-gtsrHT kFWJEY"><span><code>NumericLiteral</code></span></a><span>, </span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L534" class="sc-gtsrHT kFWJEY"><span><code>StringLiteral</code></span></a><span>), we return a singleton type instead of the underlying base type (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/typecheck/synth.ts#L22" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthBoolean</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>BooleanLiteral<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthNumber</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>NumericLiteral<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthString</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>StringLiteral<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>In actual TypeScript, singleton types are synthesized for immutable values but not mutable values. This makes senseâ€”a mutable value of singleton type is effectively immutable, since you can only mutate it to another value that&#x27;s </span><span><code>===</code></span><span> to the original. For example:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">const</span> x <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-cBoqAE lRfdj">7</span>  <span class="sc-carFqZ hBWCUB">// x has type 7</span>
<span class="sc-gXfVKN jKLUHq">let</span> y <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-iTVJFM oxVOu">true</span> <span class="sc-carFqZ hBWCUB">// y has type boolean</span>

<span class="sc-gXfVKN jKLUHq">const</span> obj1 <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">true</span> <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-carFqZ hBWCUB">// obj1 has type { foo: number, bar: boolean }</span>

<span class="sc-gXfVKN jKLUHq">const</span> obj2 <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">{</span> foo<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-cBoqAE lRfdj">7</span><span class="sc-jJMGnK laKGqb">,</span> bar<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">true</span> <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-gXfVKN jKLUHq">as</span> <span class="sc-gXfVKN jKLUHq">const</span>
<span class="sc-carFqZ hBWCUB">// obj2 has type { readonly foo: 7, readonly bar: true }</span></code></pre><p><span>In our language we have only immutable values, so we always synthesize singleton types.</span></p><h2 id="synthesizing-types-from-operator-expressions"><span>Synthesizing types from operator expressions</span></h2><p><span>We add cases to </span><span><code>synth</code></span><span> for different kinds of operator expression (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/typecheck/synth.ts#L217" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>Expression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-jJMGnK laKGqb">...</span>
  <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;BinaryExpression&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>  <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jcwpoC kyvWZW">synthBinary</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;LogicalExpression&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jcwpoC kyvWZW">synthLogical</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;UnaryExpression&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>   <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jcwpoC kyvWZW">synthUnary</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">...</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><h3 id="binary-operators"><span>Binary operators</span></h3><p><span>For binary operators (</span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L357" class="sc-gtsrHT kFWJEY"><span><code>BinaryExpression</code></span></a><span>) we:</span></p><ul><li><p><span>synthesize types from the </span><span><code>left</code></span><span> and </span><span><code>right</code></span><span> subexpressions;</span></p></li><li><p><span>when both have singleton type, apply the operator and return a singleton type;</span></p></li><li><p><span>otherwise return the appropriate base type,</span></p></li></ul><p><span>Here&#x27;s the code:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthBinary</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>BinaryExpression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">!</span><span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isExpression</span><span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jcwpoC kyvWZW">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">ast</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">left</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-gXfVKN jKLUHq">type</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span>
  <span class="sc-gXfVKN jKLUHq">const</span> left <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">const</span> right <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>right<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>operator<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;===&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>right<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>
        <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">===</span> right<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span>
        <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">;</span>

    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;!==&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>right<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>
        <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">!==</span> right<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span>
        <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">;</span>

    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;+&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">,</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>right<span class="sc-jJMGnK laKGqb">,</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
        <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>right<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
          <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">typeof</span> left<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">!==</span> <span class="sc-hiKfDv dRsyqq">&#x27;number&#x27;</span> <span class="sc-jJMGnK laKGqb">||</span> <span class="sc-gXfVKN jKLUHq">typeof</span> right<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">!==</span> <span class="sc-hiKfDv dRsyqq">&#x27;number&#x27;</span><span class="sc-jJMGnK laKGqb">)</span>
            <span class="sc-jcwpoC kyvWZW">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-hiKfDv dRsyqq">&#x27;unexpected value&#x27;</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
          <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">+</span> right<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
        <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-gXfVKN jKLUHq">else</span> <span class="sc-jJMGnK laKGqb">{</span>
          <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">number</span><span class="sc-jJMGnK laKGqb">;</span>
        <span class="sc-jJMGnK laKGqb">}</span>
      <span class="sc-jJMGnK laKGqb">}</span> <span class="sc-gXfVKN jKLUHq">else</span> <span class="sc-jJMGnK laKGqb">{</span>
        <span class="sc-jcwpoC kyvWZW">err</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-hiKfDv dRsyqq">&#x27;+ expects numbers&#x27;</span><span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-jJMGnK laKGqb">}</span>

    <span class="sc-gXfVKN jKLUHq">default</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jcwpoC kyvWZW">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">ast</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">operator</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>In the case for </span><span><code>+</code></span><span>, we check subtyping rather than equality with </span><span><code>number</code></span><span>, so we can add a singleton </span><span><code>number</code></span><span> to a </span><span><code>number</code></span><span> or vice versa. (See below about </span><a href="/blog/2021-10-06-Reconstructing-TypeScript-part-3#subtyping-singleton-types"><span>subtyping singleton types</span></a><span>.)</span></p><p><span>Actual TypeScript does not synthesize singleton types for these operators. I have some ideas about why not, but let&#x27;s go with it for now and see where it leads.</span></p><h3 id="logical-operators"><span>Logical operators</span></h3><p><span>We&#x27;ll need some helper functions that determine whether values of a type are known at type checking time to be </span><a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy" class="sc-gtsrHT kFWJEY"><span>truthy or falsy</span></a><span>. For singletons we can check the specific value; otherwise we know that objects and functions are always truthy, </span><span><code>null</code></span><span> is falsy, and for numbers, strings, and booleans we don&#x27;t know.</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">isTruthy</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">.</span>type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>    <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Function&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>  <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> type<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">default</span><span class="sc-jJMGnK laKGqb">:</span>          <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iTVJFM oxVOu">false</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">isFalsy</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">.</span>type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Null&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>      <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iTVJFM oxVOu">true</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jJMGnK laKGqb">!</span>type<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">default</span><span class="sc-jJMGnK laKGqb">:</span>          <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-iTVJFM oxVOu">false</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>Now for logical operators (</span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L576" class="sc-gtsrHT kFWJEY"><span><code>LogicalExpression</code></span></a><span>) we:</span></p><ul><li><p><span>synthesize types from the </span><span><code>left</code></span><span> and </span><span><code>right</code></span><span> subexpressions;</span></p></li><li><p><span>when we know at type checking time which subexpression is returned, then return its type (recall that in JavaScript </span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND" class="sc-gtsrHT kFWJEY"><span>logical operators are short-circuit and return the value of the last-evaluated subexpression</span></a><span>);</span></p></li><li><p><span>otherwise return </span><span><code>boolean</code></span><span> (this is not correct but we can&#x27;t return the correct type until we add unions in part 4).</span></p></li></ul><p><span>Here&#x27;s the code:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthLogical</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>LogicalExpression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">const</span> left <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">const</span> right <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>right<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>operator<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;&amp;&amp;&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isFalsy</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>       <span class="sc-gXfVKN jKLUHq">return</span> left<span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span> <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isTruthy</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-gXfVKN jKLUHq">return</span> right<span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span>                          <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-carFqZ hBWCUB">// left | right</span>

    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;||&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isTruthy</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>      <span class="sc-gXfVKN jKLUHq">return</span> left<span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span> <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isFalsy</span><span class="sc-jJMGnK laKGqb">(</span>left<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>  <span class="sc-gXfVKN jKLUHq">return</span> right<span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span>                          <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">;</span> <span class="sc-carFqZ hBWCUB">// left | right</span>

    <span class="sc-gXfVKN jKLUHq">default</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jcwpoC kyvWZW">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">ast</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">operator</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>Actual TypeScript does synthesize singleton types for these operatorsâ€”for example:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">const</span> a <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-cBoqAE lRfdj">7</span>
<span class="sc-gXfVKN jKLUHq">const</span> b <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-cBoqAE lRfdj">9</span>
<span class="sc-gXfVKN jKLUHq">const</span> x <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jJMGnK laKGqb">(</span>a <span class="sc-jJMGnK laKGqb">&amp;&amp;</span> b<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-carFqZ hBWCUB">// x has type 9</span></code></pre><h3 id="unary-operators"><span>Unary operators</span></h3><p><span>For unary operators (</span><a href="https://github.com/babel/babel/blob/v7.15.3/packages/babel-types/src/ast-types/generated/index.ts#L705" class="sc-gtsrHT kFWJEY"><span><code>UnaryExpression</code></span></a><span>) we</span></p><ul><li><p><span>synthesize a type from the </span><span><code>argument</code></span><span> subexpression;</span></p></li><li><p><span>for </span><span><code>!</code></span><span> return a singleton if we know whether the argument is truthy or falsy; otherwise return </span><span><code>boolean</code></span></p></li><li><p><span>for </span><span><code>typeof</code></span><span> return the appropriate singleton given the argument type.</span></p></li></ul><p><span>Here&#x27;s the code:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-gXfVKN jKLUHq">type</span><span class="sc-jcwpoC kyvWZW">ofType</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">string</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">.</span>type<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Singleton&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-gXfVKN jKLUHq">type</span><span class="sc-jcwpoC kyvWZW">ofType</span><span class="sc-jJMGnK laKGqb">(</span>type<span class="sc-jJMGnK laKGqb">.</span>base<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Boolean&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;boolean&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Function&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;function&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Null&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;object&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Number&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;number&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;Object&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;object&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;String&#x27;</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-hiKfDv dRsyqq">&#x27;string&#x27;</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span>

<span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">synthUnary</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">:</span> Env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iTVJFM oxVOu">AST</span><span class="sc-jJMGnK laKGqb">.</span>UnaryExpression<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> Type <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-gXfVKN jKLUHq">const</span> argument <span class="sc-jJMGnK laKGqb">=</span> <span class="sc-jcwpoC kyvWZW">synth</span><span class="sc-jJMGnK laKGqb">(</span>env<span class="sc-jJMGnK laKGqb">,</span> ast<span class="sc-jJMGnK laKGqb">.</span>argument<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-gXfVKN jKLUHq">switch</span> <span class="sc-jJMGnK laKGqb">(</span>ast<span class="sc-jJMGnK laKGqb">.</span>operator<span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;!&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isTruthy</span><span class="sc-jJMGnK laKGqb">(</span>argument<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span>     <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-iTVJFM oxVOu">false</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span> <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isFalsy</span><span class="sc-jJMGnK laKGqb">(</span>argument<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-iTVJFM oxVOu">true</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
      <span class="sc-gXfVKN jKLUHq">else</span>                             <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-iklJeh hbusih">boolean</span><span class="sc-jJMGnK laKGqb">;</span>

    <span class="sc-gXfVKN jKLUHq">case</span> <span class="sc-hiKfDv dRsyqq">&#x27;typeof&#x27;</span><span class="sc-jJMGnK laKGqb">:</span>
      <span class="sc-gXfVKN jKLUHq">return</span> Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">singleton</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-gXfVKN jKLUHq">type</span><span class="sc-jcwpoC kyvWZW">ofType</span><span class="sc-jJMGnK laKGqb">(</span>argument<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>

    <span class="sc-gXfVKN jKLUHq">default</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-jcwpoC kyvWZW">bug</span><span class="sc-jJMGnK laKGqb">(</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-hiKfDv dRsyqq">unimplemented </span><span class="sc-jJMGnK laKGqb">${</span><span class="sc-jJMGnK laKGqb">ast</span><span class="sc-jJMGnK laKGqb">.</span><span class="sc-jJMGnK laKGqb">operator</span><span class="sc-jJMGnK laKGqb">}</span><span class="sc-jJMGnK laKGqb">`</span><span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><p><span>Actual TypeScript synthesizes singleton types for </span><span><code>!</code></span><span> but not for </span><span><code>typeof</code></span><span>. I don&#x27;t know why not! But again let&#x27;s go with it.</span></p><h2 id="subtyping-singleton-types"><span>Subtyping singleton types</span></h2><p><span>A singleton type is a subtype of another singleton type only when they have the same value.</span></p><p><span>A singleton type is always a subtype of its base type (as above, it supports all the same operations as its base type), so it&#x27;s a subtype of another type when its base type is a subtype of the other type. So for example </span><span><code>7</code></span><span> is a subtype of </span><span><code>number</code></span><span>. (We&#x27;ll be able to construct less-trivial examples once we add unions.)</span></p><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part3/src/type/isSubtype.ts#L27" class="sc-gtsrHT kFWJEY"><span>isSubtype.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-gXfVKN jKLUHq">function</span> <span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">,</span> b<span class="sc-jJMGnK laKGqb">:</span> Type<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">:</span> <span class="sc-iklJeh hbusih">boolean</span> <span class="sc-jJMGnK laKGqb">{</span>
  <span class="sc-jJMGnK laKGqb">...</span>
  <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-jJMGnK laKGqb">{</span>
    <span class="sc-gXfVKN jKLUHq">if</span> <span class="sc-jJMGnK laKGqb">(</span>Type<span class="sc-jJMGnK laKGqb">.</span><span class="sc-jcwpoC kyvWZW">isSingleton</span><span class="sc-jJMGnK laKGqb">(</span>b<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">)</span> <span class="sc-gXfVKN jKLUHq">return</span> a<span class="sc-jJMGnK laKGqb">.</span>value <span class="sc-jJMGnK laKGqb">===</span> b<span class="sc-jJMGnK laKGqb">.</span>value<span class="sc-jJMGnK laKGqb">;</span>
    <span class="sc-gXfVKN jKLUHq">else</span>                     <span class="sc-gXfVKN jKLUHq">return</span> <span class="sc-jcwpoC kyvWZW">isSubtype</span><span class="sc-jJMGnK laKGqb">(</span>a<span class="sc-jJMGnK laKGqb">.</span>base<span class="sc-jJMGnK laKGqb">,</span> b<span class="sc-jJMGnK laKGqb">)</span><span class="sc-jJMGnK laKGqb">;</span>
  <span class="sc-jJMGnK laKGqb">}</span>
  <span class="sc-jJMGnK laKGqb">...</span>
<span class="sc-jJMGnK laKGqb">}</span></code></pre><h2 id="checking-expressions-against-singleton-types"><span>Checking expressions against singleton types</span></h2><p><span>Recall from </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1#checking-expressions-against-types"><span>part 1</span></a><span> that to check an expression against a type, we break down the expression and type, then check their corresponding parts. But since we have singleton types for primitive values only, there&#x27;s nothing to break downâ€”we just fall back to the default: synthesize a type from the expression, then check that the synthesized type is a subtype of the expected type. So there is no new code to write.</span></p><p><span>Operator expressions are always synthesized; we can&#x27;t in general deduce input types from output types. For example, to check </span><span><code>x + y</code></span><span> against </span><span><code>16</code></span><span>, we know that </span><span><code>x</code></span><span> and </span><span><code>y</code></span><span> must have singleton </span><span><code>number</code></span><span> types that sum to </span><span><code>16</code></span><span>, but we don&#x27;t know how to split </span><span><code>16</code></span><span> between them. So we fall back to synthesizing and checking subtyping. (In part 6 we&#x27;ll see that narrowing involves deducing </span><span><em>constraints</em></span><span> on input types from output types.)</span></p><h2 id="try-it"><span>Try it!</span></h2><p><span>You can try out the type checker below. Click on an example button or type an expression in the top box. In the bottom box you&#x27;ll see a trace of the type checker execution, ending in a synthesized type (or an error). The trace is a tree of function calls; click on a function call to expand the tree under that call, or mouse over a call to highlight the matching return value.</span></p><iframe src="https://jaked.org/reconstructing-typescript/part3/" width="700" height="500" style="border-style:none"></iframe><h2 id="the-plan"><span>The plan</span></h2><p><span>For the full code of part 3 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part3" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part3</span></a><span>. To view the changes between part 2 and part 3 see </span><a href="https://github.com/jaked/reconstructing-typescript/compare/part2...part3" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/compare/part2...part3</span></a><span>.</span></p><p><span>Next time we&#x27;ll add </span><span><em>union</em></span><span> types to represent type alternatives like </span><span><code>string | boolean</code></span><span>.</span></p><ul><li><p><span></span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>Part 0: intro and background</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>Part 1: bidirectional type checking</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>Part 2: functions and function calls</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-06-Reconstructing-TypeScript-part-3"><span>Part 3: operators and singleton types</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4"><span>Part 4: union types</span></a><span></span></p></li><li><p><span>Part 5: intersection types</span></p></li><li><p><span>Part 6: narrowing</span></p></li></ul><p><span>Thanks to Hazem Alhalabi for helpful feedback on a draft of this post.</span></p><p><span>Please </span><a href="/blog/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p><p><span></span></p></div></body></html>