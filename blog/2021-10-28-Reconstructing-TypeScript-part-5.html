<html><head><title>How to implement a TypeScript-style type checker (Reconstructing TypeScript), part 5: intersection types</title><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@jakedonham"/><meta name="twitter:creator" content="@jakedonham"/><meta name="twitter:title" content="How to implement a TypeScript-style type checker (Reconstructing TypeScript), part 5: intersection types"/><meta name="twitter:description" content="How to implement a TypeScript-style type checker (Reconstructing TypeScript), part 5: intersection types"/><style>
body {
  background-color: #eeeeee;
}
.content {
  background-color: white;
  padding-top: 80px;
  padding-bottom: 80px;
  padding-left: 120px;
  padding-right: 120px;
  margin-left: auto;
  margin-right: auto;
  max-width: 700px
}
blockquote { margin-block-end: 2em }
p, ul { font-family: serif; font-size: 19px; line-height: 26px }
code { font-family: monospace; font-size: 14px; }
pre { font-family: monospace; font-size: 14px; }
h1, h2, h3, h4, h5, h6 { font-family: sans-serif }
a:link { text-decoration: none; }
a:visited { color: blue }
a:hover {
  background-color: #eeeeee;
}
hr { border-style: solid }
</style>
<script type='module' src='/blog/2021-10-28-Reconstructing-TypeScript-part-5.js'></script>
<style data-styled="true" data-styled-version="5.3.0">.bOWasK{background-color:#f7f7f7;margin-left:10px;margin-right:10px;padding:10px;overflow:auto;}/*!sc*/
data-styled.g1[id="sc-bdnxRM"]{content:"bOWasK,"}/*!sc*/
.kFWJEY:hover{cursor:pointer;}/*!sc*/
data-styled.g2[id="sc-gtsrHT"]{content:"kFWJEY,"}/*!sc*/
.fHUQtx{color:#009900;}/*!sc*/
data-styled.g30[id="sc-cxNHIi"]{content:"fHUQtx,"}/*!sc*/
.hpRDUw{color:#000000;}/*!sc*/
data-styled.g31[id="sc-lmgQwP"]{content:"hpRDUw,"}/*!sc*/
.bojiJp{color:#aa1111;}/*!sc*/
data-styled.g32[id="sc-iJCRrE"]{content:"bojiJp,"}/*!sc*/
.bYgUJS{color:#268bd2;}/*!sc*/
data-styled.g33[id="sc-giAqHp"]{content:"bYgUJS,"}/*!sc*/
.dvHFX{color:#221199;}/*!sc*/
data-styled.g34[id="sc-ezzafa"]{content:"dvHFX,"}/*!sc*/
.fDDjHD{color:#770088;}/*!sc*/
data-styled.g35[id="sc-bYwzuL"]{content:"fDDjHD,"}/*!sc*/
.iehvjW{color:#b58900;}/*!sc*/
data-styled.g36[id="sc-kLojOw"]{content:"iehvjW,"}/*!sc*/
.hbusih{color:#116644;}/*!sc*/
data-styled.g37[id="sc-iklJeh"]{content:"hbusih,"}/*!sc*/
.laKGqb{color:#6f42c1;}/*!sc*/
data-styled.g38[id="sc-jJMGnK"]{content:"laKGqb,"}/*!sc*/
</style>
</head><body><div class="content"><p><span></span><a href="/index"><span>Jake Donham</span></a><span> &gt; </span><a href="/blog/index"><span>Technical Difficulties</span></a><span> &gt; Reconstructing TypeScript, part 5</span></p><h1 id="reconstructing-typescript-part-5-intersection-types"><span>Reconstructing TypeScript, part 5: intersection types</span></h1><h3 id="2021-10-28"><span><em>2021-10-28</em></span></h3><p><span>This post is part of a series about implementing type checking for a TypeScript-like language. See </span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>part 0</span></a><span> for background, and parts </span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>1</span></a><span>, </span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>2</span></a><span>, </span><a href="/blog/2021-10-06-Reconstructing-TypeScript-part-3"><span>3</span></a><span>, </span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4"><span>4</span></a><span> for the implementation so far.</span></p><p><span>In this part we&#x27;ll add </span><span><em>intersection</em></span><span> types like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> z<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span>

<span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>n<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>s<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>to describe collections of values that satisfy all the parts (separated by </span><span><code>&amp;</code></span><span>) of the intersection. We haven&#x27;t talked about intersection types yet, but they&#x27;ll be important when we cover narrowing in the next part. They can also be useful in ordinary programming (I&#x27;ll give some examples below).</span></p><p><span>Intersection types are unusual, although some other languages support them in a limited formâ€”for example, implementing multiple interfaces in Java or Scala is a kind of intersection, as is function overloading.</span></p><h2 id="whats-an-intersection-type"><span>What&#x27;s an intersection type?</span></h2><p><span>In </span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4#whats-a-union-type"><span>part 4</span></a><span> I explained a type as a description of what&#x27;s known about a collection of values (at a certain point in a program). Some types describe concrete attributes (like &quot;supports the </span><span><code>bar</code></span><span> property&quot;); others describe logical operations on pieces of knowledge:</span></p><p><span>A union type </span><span><code>A | B</code></span><span> is a logical OR of its arms: for any value satisfying the type, we know that either the value satisfies </span><span><code>A</code></span><span>, or the value satisfies </span><span><code>B</code></span><span>, or the value satisfies both </span><span><code>A</code></span><span> and </span><span><code>B</code></span><span>; but we don&#x27;t know which one.</span></p><p><span>An intersection type </span><span><code>A &amp; B</code></span><span> is a logical AND of its parts: for any value satisfying </span><span><code>A &amp; B</code></span><span> we know the value satisfies both </span><span><code>A</code></span><span> and </span><span><code>B</code></span><span>. For example, the type</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> z<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>has properties </span><span><code>x</code></span><span>, </span><span><code>y</code></span><span>, and </span><span><code>z</code></span><span>, all of type </span><span><code>number</code></span><span>.</span></p><p><span>One use for intersections is to add fields to an existing type. For example: a hassle that comes up with ORM systems is that IDs are issued by the database; when you create an object it doesn&#x27;t have an ID, but when you look it up it does; so you can&#x27;t use the same type for both purposes. Usually you get around this by making the ID an optional property, but that&#x27;s not quite right. In TypeScript you can define the core object type without the ID property:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">Obj</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> <span class="sc-lmgQwP hpRDUw">...</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>then augment it with an </span><span><code>id</code></span><span> property using an intersection</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">ObjWithID</span> <span class="sc-lmgQwP hpRDUw">=</span> Obj <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> id<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>to get a type that supports all the same operations as </span><span><code>Obj</code></span><span> and also the </span><span><code>id</code></span><span> property.</span></p><p><span>Another use is to give types to overloaded functions. For example, the browser </span><span><code>getElementsByTagName</code></span><span> function returns different types based on its argument, so we can give it an intersection type:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">const</span> getElementsByTagName<span class="sc-lmgQwP hpRDUw">:</span>
  <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>tag<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iJCRrE bojiJp">&#x27;div&#x27;</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> HTMLDivElement<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span>
  <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>tag<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iJCRrE bojiJp">&#x27;p&#x27;</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> HTMLParagraphElement<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span>
  <span class="sc-lmgQwP hpRDUw">...</span></code></pre><p><span>(In actual TypeScript you can declare overloaded functions with </span><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads" class="sc-gtsrHT kFWJEY"><span>overload signatures</span></a><span>, and as we&#x27;ll see its type checker doesn&#x27;t handle function intersections very well.)</span></p><p><span>An intersection with only one part contains the same values as the single part. (There&#x27;s no way to write this type in TypeScript&#x27;s concrete syntax, but it comes up in the code.)</span></p><p><span>An intersection with no parts contains all values! This type is called </span><span><code>unknown</code></span><span>. It supports only operations supported on every value, like calling </span><span><code>typeof</code></span><span> or testing for truthiness.</span></p><p><span>(In the same way that logical AND is </span><span><em>dual</em></span><span> to logical OR, intersection is dual to union. So a lot of the code we&#x27;ll need for intersections looks like the code for unions, but flipped somehow.)</span></p><h2 id="equivalent-intersection-types"><span>Equivalent intersection types</span></h2><p><span>Like union types, intersection types give us lots of ways to describe the same collection of values:</span></p><p><span>The order of the parts of an intersection doesn&#x27;t matter; so for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> z<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">{</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> z<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">{</span> z<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>all contain the same values.</span></p><p><span>If a part of an intersection is a nested intersection, the parts of the inner intersection can be lifted up to the outer intersection; so for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> z<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span>
<span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> z<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> z<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>all contain the same values.</span></p><p><span>If one part of an intersection is a supertype of another, it can be removed; so for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iJCRrE bojiJp">&#x27;cartesian&#x27;</span><span class="sc-lmgQwP hpRDUw">,</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">,</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">,</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iJCRrE bojiJp">&#x27;cartesian&#x27;</span><span class="sc-lmgQwP hpRDUw">,</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">,</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-giAqHp bYgUJS">unknown</span>
<span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iJCRrE bojiJp">&#x27;cartesian&#x27;</span><span class="sc-lmgQwP hpRDUw">,</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">,</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>all contain the same values. (Here&#x27;s an example of duality between union and intersection: For unions we remove the </span><span><em>sub</em></span><span>typesâ€”a value satisfying a union must satisfy one of the arms; if it satisfies an arm it also satisfies all subtypes of the arm; so subtypes are redundant. For intersections we remove the </span><span><em>super</em></span><span>typesâ€”a value satisfying an intersection must satisfy all the parts; if it satisfies any supertype of a part it also satisfies the part; so supertypes are redundant.)</span></p><p><span>Intersections distribute over object types, so for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> bar<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> baz<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">string</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> bar<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> baz<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">string</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>contain the same values; and also</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> z<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">{</span> x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">,</span> y<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">,</span> z<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>contain the same values.</span></p><p><span>Intersections also distribute over unions (just as multiplication distributes over addition) so</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">2</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">)</span>
<span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span>
<span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-iklJeh hbusih">2</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-iklJeh hbusih">2</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>all contain the same values.</span></p><p><span>Some types have empty intersection: for example, a value can&#x27;t be both a </span><span><code>number</code></span><span> and a </span><span><code>string</code></span><span>, or satisfy both singleton types </span><span><code>7</code></span><span> and </span><span><code>9</code></span><span>. An empty intersection contains no values, so it&#x27;s equivalent to </span><span><code>never</code></span><span>. In the previous example, all but one of the intersections in the 3rd line are empty, so the type is equivalent to</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iklJeh hbusih">2</span></code></pre><p><span>Now that we have intersections, we can distribute functions over unionsâ€”for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">boolean</span>
<span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">boolean</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">boolean</span></code></pre><p><span>contain the same values.</span></p><h2 id="representing-intersection-types"><span>Representing intersection types</span></h2><p><span>To represent intersection types, we add an </span><span><code>Intersection</code></span><span> arm to the </span><span><code>Type</code></span><span> union containing a list of parts, and an </span><span><code>Unknown</code></span><span> arm to represent </span><span><code>unknown</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part5/src/type/types.ts#L60" class="sc-gtsrHT kFWJEY"><span>types.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">Type</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">...</span> <span class="sc-lmgQwP hpRDUw">|</span> Unknown <span class="sc-lmgQwP hpRDUw">|</span> Intersection<span class="sc-lmgQwP hpRDUw">;</span>

<span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">Unknown</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iJCRrE bojiJp">&#x27;Unknown&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span>

<span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">Intersection</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iJCRrE bojiJp">&#x27;Intersection&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span> types<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">;</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>We add a constructor function for </span><span><code>Unknown</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part5/src/type/constructors.ts#L4" class="sc-gtsrHT kFWJEY"><span>constructors.ts</span></a><span>, and below for the </span><span><code>Intersection</code></span><span> constructor):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">const</span> <span class="sc-giAqHp bYgUJS">unknown</span><span class="sc-lmgQwP hpRDUw">:</span> Types<span class="sc-lmgQwP hpRDUw">.</span>Unknown <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iJCRrE bojiJp">&#x27;Unknown&#x27;</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">;</span></code></pre><p><span>and validator functions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part5/src/type/validators.ts#L43" class="sc-gtsrHT kFWJEY"><span>validators.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">isUnknown</span><span class="sc-lmgQwP hpRDUw">(</span>type<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-bYwzuL fDDjHD">is</span> Unknown <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-bYwzuL fDDjHD">return</span> type<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-iJCRrE bojiJp">&#x27;Unknown&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span>

<span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">isIntersection</span><span class="sc-lmgQwP hpRDUw">(</span>type<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-bYwzuL fDDjHD">is</span> Intersection <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-bYwzuL fDDjHD">return</span> type<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-iJCRrE bojiJp">&#x27;Intersection&#x27;</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>and cases for </span><span><code>Intersection</code></span><span> and </span><span><code>Unknown</code></span><span> in </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part5/src/type/toString.ts#L43" class="sc-gtsrHT kFWJEY"><span>toString.ts</span></a><span> and </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part5/src/type/ofTSType.ts#L58" class="sc-gtsrHT kFWJEY"><span>ofTSType.ts</span></a><span>.</span></p><h2 id="normalizing-intersection-types"><span>Normalizing intersection types</span></h2><p><span>As we do for unions (see </span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4#normalizing-union-types"><span>part 4</span></a><span>), we normalize intersection types in the constructor, to simplify the type checker and make its output more readable.</span></p><p><span>Normalizing intersections is more complicated than normalizing unions. We want to detect and eliminate empty intersections (this will be important for narrowing), but unions make it more difficult. For example, in</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">2</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>it&#x27;s not obvious that we can eliminate most of the union cases. But if we distribute the intersection over the unions</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-iklJeh hbusih">2</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-iklJeh hbusih">2</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>then it&#x27;s easy to check each intersection for emptiness</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-giAqHp bYgUJS">never</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-giAqHp bYgUJS">never</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-giAqHp bYgUJS">never</span></code></pre><p><span>and eliminate the empty intersections</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iklJeh hbusih">2</span></code></pre><p><span>So that&#x27;s what we do: in addition to flattening nested intersections and removing redundant parts (as we do for unions), we also distribute intersections over unions and eliminate empty intersections. As with unions, we don&#x27;t distribute intersections over object or function types (or objects / functions over intersections).</span></p><h3 id="distributing-intersections-over-unions"><span>Distributing intersections over unions</span></h3><p><span>Here&#x27;s a helper function for distributing over unions (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part5/src/type/union.ts#L28" class="sc-gtsrHT kFWJEY"><span>union.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">distributeUnion</span><span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span> <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-bYwzuL fDDjHD">const</span> accum<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">dist</span><span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">,</span> i<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">void</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>i <span class="sc-lmgQwP hpRDUw">===</span> ts<span class="sc-lmgQwP hpRDUw">.</span>length<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
      accum<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">push</span><span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-bYwzuL fDDjHD">else</span> <span class="sc-lmgQwP hpRDUw">{</span>
      <span class="sc-bYwzuL fDDjHD">const</span> ti <span class="sc-lmgQwP hpRDUw">=</span> ts<span class="sc-lmgQwP hpRDUw">[</span>i<span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isUnion</span><span class="sc-lmgQwP hpRDUw">(</span>ti<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
        <span class="sc-bYwzuL fDDjHD">for</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-bYwzuL fDDjHD">const</span> t <span class="sc-bYwzuL fDDjHD">of</span> ti<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
          <span class="sc-bYwzuL fDDjHD">const</span> ts2 <span class="sc-lmgQwP hpRDUw">=</span> ts<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">slice</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">0</span><span class="sc-lmgQwP hpRDUw">,</span> i<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">concat</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">,</span> ts<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">slice</span><span class="sc-lmgQwP hpRDUw">(</span>i <span class="sc-lmgQwP hpRDUw">+</span> <span class="sc-iklJeh hbusih">1</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
          <span class="sc-kLojOw iehvjW">dist</span><span class="sc-lmgQwP hpRDUw">(</span>ts2<span class="sc-lmgQwP hpRDUw">,</span> i <span class="sc-lmgQwP hpRDUw">+</span> <span class="sc-iklJeh hbusih">1</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
        <span class="sc-lmgQwP hpRDUw">}</span>
      <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-bYwzuL fDDjHD">else</span> <span class="sc-lmgQwP hpRDUw">{</span>
        <span class="sc-kLojOw iehvjW">dist</span><span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">,</span> i <span class="sc-lmgQwP hpRDUw">+</span> <span class="sc-iklJeh hbusih">1</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-lmgQwP hpRDUw">}</span>
    <span class="sc-lmgQwP hpRDUw">}</span>
  <span class="sc-lmgQwP hpRDUw">}</span>

  <span class="sc-kLojOw iehvjW">dist</span><span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-iklJeh hbusih">0</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">return</span> accum<span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>This function takes a list of types (which may contain unions) and returns the Cartesian product (roughly speaking) over the unions. So if you call</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-kLojOw iehvjW">distributeUnion</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">[</span> <span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">2</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-iklJeh hbusih">4</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">5</span> <span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>you get back</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">[</span>
  <span class="sc-lmgQwP hpRDUw">[</span> <span class="sc-iklJeh hbusih">1</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-iklJeh hbusih">4</span> <span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">,</span>
  <span class="sc-lmgQwP hpRDUw">[</span> <span class="sc-iklJeh hbusih">1</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-iklJeh hbusih">5</span> <span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">,</span>
  <span class="sc-lmgQwP hpRDUw">[</span> <span class="sc-iklJeh hbusih">2</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-iklJeh hbusih">4</span> <span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">,</span>
  <span class="sc-lmgQwP hpRDUw">[</span> <span class="sc-iklJeh hbusih">2</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-iklJeh hbusih">5</span> <span class="sc-lmgQwP hpRDUw">]</span>
<span class="sc-lmgQwP hpRDUw">]</span></code></pre><h3 id="detecting-empty-intersections"><span>Detecting empty intersections</span></h3><p><span>Here&#x27;s a function to check if two types overlapâ€”that is, their intersection is not empty (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part5/src/type/intersection.ts#L30" class="sc-gtsrHT kFWJEY"><span>intersection.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">overlaps</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">,</span> y<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">boolean</span> <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isNever</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">||</span> <span class="sc-kLojOw iehvjW">isNever</span><span class="sc-lmgQwP hpRDUw">(</span>y<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-ezzafa dvHFX">false</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isUnknown</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">||</span> <span class="sc-kLojOw iehvjW">isUnknown</span><span class="sc-lmgQwP hpRDUw">(</span>y<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-ezzafa dvHFX">true</span><span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isUnion</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span>
    <span class="sc-bYwzuL fDDjHD">return</span> x<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">some</span><span class="sc-lmgQwP hpRDUw">(</span>x <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">overlaps</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">,</span> y<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isUnion</span><span class="sc-lmgQwP hpRDUw">(</span>y<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span>
    <span class="sc-bYwzuL fDDjHD">return</span> y<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">some</span><span class="sc-lmgQwP hpRDUw">(</span>y <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">overlaps</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">,</span> y<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isIntersection</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span>
    <span class="sc-bYwzuL fDDjHD">return</span> x<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">every</span><span class="sc-lmgQwP hpRDUw">(</span>x <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">overlaps</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">,</span> y<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isIntersection</span><span class="sc-lmgQwP hpRDUw">(</span>y<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span>
    <span class="sc-bYwzuL fDDjHD">return</span> y<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">every</span><span class="sc-lmgQwP hpRDUw">(</span>y <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">overlaps</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">,</span> y<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isSingleton</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;&amp;</span> <span class="sc-kLojOw iehvjW">isSingleton</span><span class="sc-lmgQwP hpRDUw">(</span>y<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> x<span class="sc-lmgQwP hpRDUw">.</span>value <span class="sc-lmgQwP hpRDUw">===</span> y<span class="sc-lmgQwP hpRDUw">.</span>value<span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isSingleton</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> x<span class="sc-lmgQwP hpRDUw">.</span>base<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> y<span class="sc-lmgQwP hpRDUw">.</span>type<span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isSingleton</span><span class="sc-lmgQwP hpRDUw">(</span>y<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> y<span class="sc-lmgQwP hpRDUw">.</span>base<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> x<span class="sc-lmgQwP hpRDUw">.</span>type<span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isObject</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;&amp;</span> <span class="sc-kLojOw iehvjW">isObject</span><span class="sc-lmgQwP hpRDUw">(</span>y<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-bYwzuL fDDjHD">return</span> x<span class="sc-lmgQwP hpRDUw">.</span>properties<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">every</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> name<span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">:</span> xType <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-lmgQwP hpRDUw">{</span>
      <span class="sc-bYwzuL fDDjHD">const</span> yType <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-kLojOw iehvjW">propType</span><span class="sc-lmgQwP hpRDUw">(</span>y<span class="sc-lmgQwP hpRDUw">,</span> name<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span>yType<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-ezzafa dvHFX">true</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-bYwzuL fDDjHD">else</span> <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-kLojOw iehvjW">overlaps</span><span class="sc-lmgQwP hpRDUw">(</span>xType<span class="sc-lmgQwP hpRDUw">,</span> yType<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">}</span>

  <span class="sc-bYwzuL fDDjHD">return</span> x<span class="sc-lmgQwP hpRDUw">.</span>type <span class="sc-lmgQwP hpRDUw">===</span> y<span class="sc-lmgQwP hpRDUw">.</span>type<span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>It&#x27;s interesting to compare </span><span><code>overlaps</code></span><span> with </span><span><code>isSubtype</code></span><span>: </span><span><code>isSubtype(a, b)</code></span><span> is true when all of </span><span><code>a</code></span><span> is contained in </span><span><code>b</code></span><span>; </span><span><code>overlaps(a, b)</code></span><span> is true when part of </span><span><code>a</code></span><span> is contained in </span><span><code>b</code></span><span> (or, equivalently, part of </span><span><code>b</code></span><span> is contained in </span><span><code>a</code></span><span>).</span></p><h3 id="empty-intersections-of-object-types"><span>Empty intersections of object types</span></h3><p><span><code>overlaps</code></span><span> recurses inside object types, so it detects that</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>is empty. Object properties may contain unions and intersections (since we don&#x27;t distribute objects over unions and intersections) so </span><span><code>overlaps</code></span><span> must handle those cases. So </span><span><code>overlaps</code></span><span> detects that</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">3</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">4</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>is empty, but we don&#x27;t normalize</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">3</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>to the equivalent</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><h3 id="empty-intersections-of-function-types"><span>Empty intersections of function types</span></h3><p><span>I&#x27;m not sure what to do about functions here. Clearly there are non-overlapping functionsâ€”for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">boolean</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>is empty; there is no function that returns both </span><span><code>string</code></span><span> and </span><span><code>boolean</code></span><span> for the same input. But when the argument types don&#x27;t overlap it&#x27;s OK to return different types, for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">boolean</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>so maybe there is a way to compute this precisely by checking for argument type overlap. In the meantime we just say that all functions overlap.</span></p><p><span>Actual TypeScript doesn&#x27;t seem to be precise here either: it detects empty intersections in objects</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">x</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">7</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">y</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">9</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">z</span> <span class="sc-lmgQwP hpRDUw">=</span> x <span class="sc-lmgQwP hpRDUw">&amp;</span> y <span class="sc-cxNHIi fHUQtx">// z has type never</span></code></pre><p><span>but not in functions</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">f</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">string</span>
<span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">g</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">boolean</span>
<span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">h</span> <span class="sc-lmgQwP hpRDUw">=</span> f <span class="sc-lmgQwP hpRDUw">&amp;</span> g <span class="sc-cxNHIi fHUQtx">// h has type f &amp; g</span></code></pre><h3 id="normalizing-intersections"><span>Normalizing intersections</span></h3><p><span>Now we can put the pieces together. To normalize an intersection:</span></p><ol><li><p><span>flatten nested intersections</span></p></li><li><p><span>distribute the intersection over unions to get a union of intersections</span></p></li><li><p><span>for each intersection, check for emptiness and remove redundant parts</span></p></li></ol><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part5/src/type/intersection.ts#L75" class="sc-gtsrHT kFWJEY"><span>intersection.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">collapseSupertypes</span><span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span> <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-bYwzuL fDDjHD">return</span> ts<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">filter</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>t1<span class="sc-lmgQwP hpRDUw">,</span> i1<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span>       <span class="sc-cxNHIi fHUQtx">// a part is kept if</span>
    ts<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">every</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>t2<span class="sc-lmgQwP hpRDUw">,</span> i2<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span>             <span class="sc-cxNHIi fHUQtx">// for every part</span>
      i1 <span class="sc-lmgQwP hpRDUw">===</span> i2 <span class="sc-lmgQwP hpRDUw">||</span>                   <span class="sc-cxNHIi fHUQtx">// (except itself)</span>
      <span class="sc-lmgQwP hpRDUw">!</span><span class="sc-kLojOw iehvjW">isSubtype</span><span class="sc-lmgQwP hpRDUw">(</span>t2<span class="sc-lmgQwP hpRDUw">,</span> t1<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">||</span>          <span class="sc-cxNHIi fHUQtx">// it&#x27;s not a supertype of the other part</span>
      <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isSubtype</span><span class="sc-lmgQwP hpRDUw">(</span>t1<span class="sc-lmgQwP hpRDUw">,</span> t2<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;&amp;</span> i1 <span class="sc-lmgQwP hpRDUw">&lt;</span> i2<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-cxNHIi fHUQtx">// or it&#x27;s equivalent to the other part</span>
                                     <span class="sc-cxNHIi fHUQtx">// and this is the first equivalent part</span>
    <span class="sc-lmgQwP hpRDUw">)</span>
  <span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span>

<span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">flatten</span><span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span> <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span> <span class="sc-bYwzuL fDDjHD">as</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">concat</span><span class="sc-lmgQwP hpRDUw">(</span>
    <span class="sc-lmgQwP hpRDUw">...</span>ts<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">map</span><span class="sc-lmgQwP hpRDUw">(</span>t <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">isIntersection</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">?</span> t<span class="sc-lmgQwP hpRDUw">.</span>types <span class="sc-lmgQwP hpRDUw">:</span> t<span class="sc-lmgQwP hpRDUw">)</span>
  <span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span>

<span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">intersectionNoUnion</span><span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">some</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>t1<span class="sc-lmgQwP hpRDUw">,</span> i1<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> ts<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">some</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>t2<span class="sc-lmgQwP hpRDUw">,</span> i2<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span>
    i1 <span class="sc-lmgQwP hpRDUw">&lt;</span> i2 <span class="sc-lmgQwP hpRDUw">&amp;&amp;</span> <span class="sc-kLojOw iehvjW">emptyIntersection</span><span class="sc-lmgQwP hpRDUw">(</span>t1<span class="sc-lmgQwP hpRDUw">,</span> t2<span class="sc-lmgQwP hpRDUw">)</span>
  <span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span>
    <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-giAqHp bYgUJS">never</span><span class="sc-lmgQwP hpRDUw">;</span>
  ts <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-kLojOw iehvjW">collapseSupertypes</span><span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">.</span>length <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-iklJeh hbusih">0</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-giAqHp bYgUJS">unknown</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">.</span>length <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-iklJeh hbusih">1</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> ts<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-iklJeh hbusih">0</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-lmgQwP hpRDUw">{</span> type<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iJCRrE bojiJp">&#x27;Intersection&#x27;</span><span class="sc-lmgQwP hpRDUw">,</span> types<span class="sc-lmgQwP hpRDUw">:</span> ts <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">}</span>

<span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">intersection</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">...</span>ts<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">{</span>
  ts <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-kLojOw iehvjW">flatten</span><span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  ts <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-kLojOw iehvjW">distributeUnion</span><span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">map</span><span class="sc-lmgQwP hpRDUw">(</span>intersectionNoUnion<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-kLojOw iehvjW">union</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">...</span>ts<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><h2 id="synthesizing-with-intersection-types"><span>Synthesizing with intersection types</span></h2><p><span>Recall from </span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4#synthesizing-with-union-types"><span>part 4</span></a><span> that when we synthesize the type of an expression that operates on a subexpression (like a member expression </span><span><code>foo.bar</code></span><span>), we</span></p><ul><li><p><span>synthesize the type of the subexpression (</span><span><code>foo</code></span><span> in the example); then</span></p></li><li><p><span><code>Type.map</code></span><span> over the subexpression type with a callback that</span></p><ul><li><p><span>checks that a type supports the operation (accessing the </span><span><code>bar</code></span><span> property)</span></p></li><li><p><span>computes the result type (the type of </span><span><code>bar</code></span><span>)</span></p></li></ul></li></ul><p><span>like</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">synthMember</span><span class="sc-lmgQwP hpRDUw">(</span>env<span class="sc-lmgQwP hpRDUw">:</span> Env<span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-ezzafa dvHFX">AST</span><span class="sc-lmgQwP hpRDUw">.</span>MemberExpression<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-bYwzuL fDDjHD">const</span> prop <span class="sc-lmgQwP hpRDUw">=</span> ast<span class="sc-lmgQwP hpRDUw">.</span>property<span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">...</span>
  <span class="sc-bYwzuL fDDjHD">const</span> object <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-kLojOw iehvjW">synth</span><span class="sc-lmgQwP hpRDUw">(</span>env<span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">.</span>object<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">return</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">map</span><span class="sc-lmgQwP hpRDUw">(</span>object<span class="sc-lmgQwP hpRDUw">,</span> object <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span>Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">isObject</span><span class="sc-lmgQwP hpRDUw">(</span>object<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-kLojOw iehvjW">err</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iJCRrE bojiJp">&#x27;. expects object&#x27;</span><span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">.</span>object<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-bYwzuL fDDjHD">const</span> type <span class="sc-lmgQwP hpRDUw">=</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">propType</span><span class="sc-lmgQwP hpRDUw">(</span>object<span class="sc-lmgQwP hpRDUw">,</span> prop<span class="sc-lmgQwP hpRDUw">.</span>name<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span>type<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-kLojOw iehvjW">err</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-iJCRrE bojiJp">no such property </span><span class="sc-lmgQwP hpRDUw">${</span><span class="sc-lmgQwP hpRDUw">prop</span><span class="sc-lmgQwP hpRDUw">.</span><span class="sc-lmgQwP hpRDUw">name</span><span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">`</span><span class="sc-lmgQwP hpRDUw">,</span> prop<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-bYwzuL fDDjHD">return</span> type<span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>For non-union types, </span><span><code>Type.map</code></span><span> calls the callback directly on the type; for union types it calls the callback on each arm of the union and returns the union of the results.</span></p><p><span>Now that we have intersection types we need to handle them in a similar way. For unions, we need every arm to support the operation (since the subexpression may satisfy any of the arms). For intersections, we need only one part to support the operation (since the subexpression satisfies all the parts); when more than one part supports it, we return the intersection of the results. Here&#x27;s the new </span><span><code>map</code></span><span> (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part5/src/type/map.ts#L74" class="sc-gtsrHT kFWJEY"><span>map.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">map</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-jJMGnK laKGqb">fn</span><span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> Type<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isUnion</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-kLojOw iehvjW">union</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">...</span>t<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">map</span><span class="sc-lmgQwP hpRDUw">(</span>t <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">map</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">,</span> fn<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-bYwzuL fDDjHD">else</span> <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">isIntersection</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-bYwzuL fDDjHD">const</span> ts<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">[</span><span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-bYwzuL fDDjHD">let</span> error<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">unknown</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-bYwzuL fDDjHD">undefined</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-bYwzuL fDDjHD">for</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-bYwzuL fDDjHD">const</span> tt <span class="sc-bYwzuL fDDjHD">of</span> t<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
      <span class="sc-bYwzuL fDDjHD">try</span> <span class="sc-lmgQwP hpRDUw">{</span>
        ts<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">push</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-kLojOw iehvjW">fn</span><span class="sc-lmgQwP hpRDUw">(</span>tt<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-bYwzuL fDDjHD">catch</span> <span class="sc-lmgQwP hpRDUw">(</span>e<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
        <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">!</span>error<span class="sc-lmgQwP hpRDUw">)</span> error <span class="sc-lmgQwP hpRDUw">=</span> e<span class="sc-lmgQwP hpRDUw">;</span>
      <span class="sc-lmgQwP hpRDUw">}</span>
    <span class="sc-lmgQwP hpRDUw">}</span>
    <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>ts<span class="sc-lmgQwP hpRDUw">.</span>length <span class="sc-lmgQwP hpRDUw">===</span> <span class="sc-iklJeh hbusih">0</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">{</span>
      <span class="sc-bYwzuL fDDjHD">throw</span> error<span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-bYwzuL fDDjHD">else</span> <span class="sc-lmgQwP hpRDUw">{</span>
      <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-kLojOw iehvjW">intersection</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">...</span>ts<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-bYwzuL fDDjHD">else</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-kLojOw iehvjW">fn</span><span class="sc-lmgQwP hpRDUw">(</span>t<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>For example, in</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-cxNHIi fHUQtx">// foo has type { baz: string } &amp; { bar: 1 | 2 } &amp; { bar: 2 | 3 }</span>
foo<span class="sc-lmgQwP hpRDUw">.</span>bar</code></pre><p><span>calling the </span><span><code>synthMember</code></span><span> callback on the first part of the intersection throws an exception because </span><span><code>bar</code></span><span> is not supported; the other parts succeed with result types </span><span><code>1|2</code></span><span> and </span><span><code>2|3</code></span><span>; so the overall result type is the intersection</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">1</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">2</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-iklJeh hbusih">2</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-iklJeh hbusih">3</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>which normalizes to</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-iklJeh hbusih">2</span></code></pre><p><span>If the callback fails on all the parts, </span><span><code>map</code></span><span> throws an exception; the error message is the one from the first part. (Actual TypeScript gives a more helpful error here, referencing the whole intersection type, not just a part.)</span></p><h3 id="synthesizing-function-types-with-intersections"><span>Synthesizing function types with intersections</span></h3><p><span>Recall from </span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2#function-expressions"><span>part 2</span></a><span> that to synthesize a type from a function, we bind the argument types in the environment and synthesize a result type from the function body:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">synthFunction</span><span class="sc-lmgQwP hpRDUw">(</span>env<span class="sc-lmgQwP hpRDUw">:</span> Env<span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-ezzafa dvHFX">AST</span><span class="sc-lmgQwP hpRDUw">.</span>ArrowFunctionExpression<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-lmgQwP hpRDUw">...</span>
  <span class="sc-bYwzuL fDDjHD">const</span> bindings <span class="sc-lmgQwP hpRDUw">=</span> ast<span class="sc-lmgQwP hpRDUw">.</span>params<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">map</span><span class="sc-lmgQwP hpRDUw">(</span>param <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-lmgQwP hpRDUw">...</span>
    <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-lmgQwP hpRDUw">{</span>
      name<span class="sc-lmgQwP hpRDUw">:</span> param<span class="sc-lmgQwP hpRDUw">.</span>name<span class="sc-lmgQwP hpRDUw">,</span>
      type<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">ofTSType</span><span class="sc-lmgQwP hpRDUw">(</span>param<span class="sc-lmgQwP hpRDUw">.</span>typeAnnotation<span class="sc-lmgQwP hpRDUw">.</span>typeAnnotation<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">,</span>
    <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">const</span> args <span class="sc-lmgQwP hpRDUw">=</span> bindings<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">map</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">{</span> type <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">const</span> bodyEnv <span class="sc-lmgQwP hpRDUw">=</span>
    bindings<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">reduce</span><span class="sc-lmgQwP hpRDUw">(</span>
      <span class="sc-lmgQwP hpRDUw">(</span>env<span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-lmgQwP hpRDUw">{</span> name<span class="sc-lmgQwP hpRDUw">,</span> type <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> env<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">set</span><span class="sc-lmgQwP hpRDUw">(</span>name<span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">,</span>
      env
    <span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">const</span> ret <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-kLojOw iehvjW">synth</span><span class="sc-lmgQwP hpRDUw">(</span>bodyEnv<span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">.</span>body<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">return</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">functionType</span><span class="sc-lmgQwP hpRDUw">(</span>args<span class="sc-lmgQwP hpRDUw">,</span> ret<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>So for a function expression</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> x</code></pre><p><span>we synthesize the type</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">|</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>This type is not very preciseâ€”it doesn&#x27;t capture the fact that you always get back a value of the same type you put in.</span></p><p><span>Now that we have intersections, we can split the argument cases to get a more precise type:</span></p><ul><li><p><span>distribute unions in the function arguments;</span></p></li><li><p><span>for each resulting argument list</span></p><ul><li><p><span>bind the argument types in the environment;</span></p></li><li><p><span>synthesize a result type from the function body; and</span></p></li></ul></li><li><p><span>intersect the resulting function types.</span></p></li></ul><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part5/src/typecheck/synth.ts#L83" class="sc-gtsrHT kFWJEY"><span>synth.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">synthFunction</span><span class="sc-lmgQwP hpRDUw">(</span>env<span class="sc-lmgQwP hpRDUw">:</span> Env<span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-ezzafa dvHFX">AST</span><span class="sc-lmgQwP hpRDUw">.</span>ArrowFunctionExpression<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> Type <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-lmgQwP hpRDUw">...</span> <span class="sc-cxNHIi fHUQtx">// same as before up to `const bodyEnv = `</span>
  <span class="sc-bYwzuL fDDjHD">const</span> argsLists <span class="sc-lmgQwP hpRDUw">=</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">distributeUnion</span><span class="sc-lmgQwP hpRDUw">(</span>args<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">const</span> funcTypes <span class="sc-lmgQwP hpRDUw">=</span> argsLists<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">map</span><span class="sc-lmgQwP hpRDUw">(</span>args <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-lmgQwP hpRDUw">{</span>
    <span class="sc-bYwzuL fDDjHD">const</span> bodyEnv <span class="sc-lmgQwP hpRDUw">=</span>
      bindings<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">reduce</span><span class="sc-lmgQwP hpRDUw">(</span>
        <span class="sc-lmgQwP hpRDUw">(</span>env<span class="sc-lmgQwP hpRDUw">,</span> <span class="sc-lmgQwP hpRDUw">{</span> name <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">,</span> i<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> env<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">set</span><span class="sc-lmgQwP hpRDUw">(</span>name<span class="sc-lmgQwP hpRDUw">,</span> args<span class="sc-lmgQwP hpRDUw">[</span>i<span class="sc-lmgQwP hpRDUw">]</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">,</span>
        env
      <span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-bYwzuL fDDjHD">const</span> ret <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-kLojOw iehvjW">synth</span><span class="sc-lmgQwP hpRDUw">(</span>bodyEnv<span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">.</span>body<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
    <span class="sc-bYwzuL fDDjHD">return</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">functionType</span><span class="sc-lmgQwP hpRDUw">(</span>args<span class="sc-lmgQwP hpRDUw">,</span> ret<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">)</span>
  <span class="sc-bYwzuL fDDjHD">return</span> Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">intersection</span><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">...</span>funcTypes<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
<span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>Now for the example above, we synthesize a type from the body in the case where </span><span><code>x: number</code></span><span> and in the case where </span><span><code>x: string</code></span><span>, then intersect the results to get</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">(</span><span class="sc-giAqHp bYgUJS">number</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-giAqHp bYgUJS">string</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>This type is more precise than the originalâ€”it captures the fact that you always get back a value of the same type that you put in.</span></p><p><span>Actual TypeScript does not split cases like this. My guess is that this is for performance reasons: for most functions the result type doesn&#x27;t vary according to the arguments, so it&#x27;s a waste of effort to synthesize the body for each arm of union args. Maybe it&#x27;s better not to split cases in synthesis, but only in checking, so you can get it if you need it with a type ascription. (But actual TypeScript doesn&#x27;t do this either, see below.)</span></p><h2 id="subtyping-intersection-types"><span>Subtyping intersection types</span></h2><p><span>Since a value of intersection type must satisfy all the parts of the intersection</span></p><ul><li><p><span>an intersection type is a subtype of another type when at least one of its parts is a subtype of the other type;</span></p></li><li><p><span>a type is a subtype of an intersection type when it&#x27;s a subtype of all the parts of the intersection; and</span></p></li><li><p><span>every type is a subtype of </span><span><code>unknown</code></span><span> (an intersection of no parts).</span></p></li></ul><p><span>Here&#x27;s the code (see </span><a href="https://github.com/jaked/reconstructing-typescript/blob/part5/src/type/isSubtype.ts#L14" class="sc-gtsrHT kFWJEY"><span>isSubtype.ts</span></a><span>):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">isSubtype</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">,</span> b<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">boolean</span> <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">isNever</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-ezzafa dvHFX">true</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">isUnknown</span><span class="sc-lmgQwP hpRDUw">(</span>b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> <span class="sc-ezzafa dvHFX">true</span><span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">isUnion</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span>        <span class="sc-bYwzuL fDDjHD">return</span> a<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">every</span><span class="sc-lmgQwP hpRDUw">(</span>a <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">isSubtype</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">,</span> b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">isUnion</span><span class="sc-lmgQwP hpRDUw">(</span>b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span>        <span class="sc-bYwzuL fDDjHD">return</span> b<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">some</span><span class="sc-lmgQwP hpRDUw">(</span>b <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">isSubtype</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">,</span> b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>

  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">isIntersection</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> a<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">some</span><span class="sc-lmgQwP hpRDUw">(</span>a <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">isSubtype</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">,</span> b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">isIntersection</span><span class="sc-lmgQwP hpRDUw">(</span>b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">return</span> b<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">every</span><span class="sc-lmgQwP hpRDUw">(</span>b <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">isSubtype</span><span class="sc-lmgQwP hpRDUw">(</span>a<span class="sc-lmgQwP hpRDUw">,</span> b<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">...</span></code></pre><p><span>(I&#x27;ve left in the cases for unions and </span><span><code>never</code></span><span> because they show the duality between union and intersection.)</span></p><p><span>We saw in </span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4#subtyping-union-types"><span>part 4</span></a><span> that these straightforward subtyping rules for unions are incomplete. A similar issue comes up for intersectionsâ€”for example</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> bar<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">7</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> baz<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">9</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> bar<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">7</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> baz<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">9</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">}</span></code></pre><p><span>contain the same values, and the first is a subtype of the second, but the second is not a subtype of the first according to these rules. Again, actual TypeScript does better here; it detects that each is a subtype of the other. I need to find out how it works!</span></p><p><span>(By the way, you can check subtyping in the </span><a href="https://www.typescriptlang.org/play" class="sc-gtsrHT kFWJEY"><span>TypeScript playground</span></a><span> like so</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-lmgQwP hpRDUw">IsSubtype</span><span class="sc-lmgQwP hpRDUw">&lt;</span><span class="sc-ezzafa dvHFX">T1</span><span class="sc-lmgQwP hpRDUw">,</span><span class="sc-lmgQwP hpRDUw"> </span><span class="sc-ezzafa dvHFX">T2</span><span class="sc-lmgQwP hpRDUw">&gt;</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-ezzafa dvHFX">T1</span> <span class="sc-bYwzuL fDDjHD">extends</span> <span class="sc-ezzafa dvHFX">T2</span> <span class="sc-lmgQwP hpRDUw">?</span> <span class="sc-ezzafa dvHFX">true</span> <span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-ezzafa dvHFX">false</span>

<span class="sc-bYwzuL fDDjHD">const</span> t<span class="sc-lmgQwP hpRDUw">:</span> IsSubtype<span class="sc-lmgQwP hpRDUw">&lt;</span>
  <span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> bar<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">7</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> baz<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">9</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">}</span><span class="sc-lmgQwP hpRDUw">,</span>
  <span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> bar<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">7</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">{</span> foo<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">{</span> baz<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">9</span> <span class="sc-lmgQwP hpRDUw">}</span> <span class="sc-lmgQwP hpRDUw">}</span>
<span class="sc-lmgQwP hpRDUw">&gt;</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-ezzafa dvHFX">true</span></code></pre><p><span>If </span><span><code>T1</code></span><span> is not a subtype of </span><span><code>T2</code></span><span>, TypeScript will flag an error that type </span><span><code>true</code></span><span> is not assignable to type </span><span><code>false</code></span><span>.)</span></p><h2 id="checking-against-intersection-types"><span>Checking against intersection types</span></h2><p><span>Recall from </span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4#checking-against-union-types"><span>part 4</span></a><span> that checking against union types isn&#x27;t very useful because it doesn&#x27;t produce good error messages. It works better for intersection types: since an expression of intersection type must satisfy all the parts, we can just check them all (see check.ts):</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">function</span> <span class="sc-kLojOw iehvjW">check</span><span class="sc-lmgQwP hpRDUw">(</span>env<span class="sc-lmgQwP hpRDUw">:</span> Env<span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-ezzafa dvHFX">AST</span><span class="sc-lmgQwP hpRDUw">.</span>Expression<span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">:</span> Type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-bYwzuL fDDjHD">void</span> <span class="sc-lmgQwP hpRDUw">{</span>
  <span class="sc-bYwzuL fDDjHD">if</span> <span class="sc-lmgQwP hpRDUw">(</span>Type<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">isIntersection</span><span class="sc-lmgQwP hpRDUw">(</span>type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span>
    <span class="sc-bYwzuL fDDjHD">return</span> type<span class="sc-lmgQwP hpRDUw">.</span>types<span class="sc-lmgQwP hpRDUw">.</span><span class="sc-kLojOw iehvjW">forEach</span><span class="sc-lmgQwP hpRDUw">(</span>type <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-kLojOw iehvjW">check</span><span class="sc-lmgQwP hpRDUw">(</span>env<span class="sc-lmgQwP hpRDUw">,</span> ast<span class="sc-lmgQwP hpRDUw">,</span> type<span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">)</span><span class="sc-lmgQwP hpRDUw">;</span>
  <span class="sc-lmgQwP hpRDUw">...</span></code></pre><p><span>Now we can check overloaded function types, like:</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-lmgQwP hpRDUw">(</span>x <span class="sc-lmgQwP hpRDUw">=&gt;</span> x<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">as</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span>
<span class="sc-lmgQwP hpRDUw">(</span>x <span class="sc-lmgQwP hpRDUw">=&gt;</span> x<span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-bYwzuL fDDjHD">as</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">number</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-giAqHp bYgUJS">string</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-giAqHp bYgUJS">boolean</span><span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>When checking fails we get an error mentioning the part that failed.</span></p><p><span>Actual TypeScript doesn&#x27;t handle this kind of example; for</span></p><pre class="sc-bdnxRM bOWasK"><code><span class="sc-bYwzuL fDDjHD">const</span> f<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">7</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-iklJeh hbusih">7</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">&amp;</span> <span class="sc-lmgQwP hpRDUw">(</span><span class="sc-lmgQwP hpRDUw">(</span>x<span class="sc-lmgQwP hpRDUw">:</span> <span class="sc-iklJeh hbusih">9</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=&gt;</span> <span class="sc-iklJeh hbusih">9</span><span class="sc-lmgQwP hpRDUw">)</span> <span class="sc-lmgQwP hpRDUw">=</span> <span class="sc-lmgQwP hpRDUw">(</span>x <span class="sc-lmgQwP hpRDUw">=&gt;</span> x<span class="sc-lmgQwP hpRDUw">)</span></code></pre><p><span>it produces</span></p><pre class="sc-bdnxRM bOWasK"><code>Type <span class="sc-iJCRrE bojiJp">&#x27;(x: 7 | 9) =&gt; 7 | 9&#x27;</span> <span class="sc-bYwzuL fDDjHD">is</span> not assignable to <span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-iJCRrE bojiJp">&#x27;((x: 7) =&gt; 7) &amp; ((x: 9) =&gt; 9)&#x27;</span><span class="sc-lmgQwP hpRDUw">.</span>
  Type <span class="sc-iJCRrE bojiJp">&#x27;(x: 7 | 9) =&gt; 7 | 9&#x27;</span> <span class="sc-bYwzuL fDDjHD">is</span> not assignable to <span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-iJCRrE bojiJp">&#x27;(x: 7) =&gt; 7&#x27;</span><span class="sc-lmgQwP hpRDUw">.</span>
    Type <span class="sc-iJCRrE bojiJp">&#x27;7 | 9&#x27;</span> <span class="sc-bYwzuL fDDjHD">is</span> not assignable to <span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-iJCRrE bojiJp">&#x27;7&#x27;</span><span class="sc-lmgQwP hpRDUw">.</span>
      Type <span class="sc-iJCRrE bojiJp">&#x27;9&#x27;</span> <span class="sc-bYwzuL fDDjHD">is</span> not assignable to <span class="sc-bYwzuL fDDjHD">type</span> <span class="sc-iJCRrE bojiJp">&#x27;7&#x27;</span></code></pre><p><span>It seems like TypeScript doesn&#x27;t check the function against the type in this case, but instead synthesizes a type for the function under the assumption that </span><span><code>x</code></span><span> has type </span><span><code>7|9</code></span><span> (it undoes the rewrite we do in synthesis), then checks subtyping (or </span><span><em>assignability</em></span><span> in TypeScript terms). I don&#x27;t know why!</span></p><h2 id="try-it"><span>Try it!</span></h2><p><span>You can try out the type checker below. Click on an example button or type an expression in the top box. In the bottom box you&#x27;ll see a trace of the type checker execution, ending in a synthesized type (or an error). The trace is a tree of function calls; click on a function call to expand the tree under that call, or mouse over a call to highlight the matching return value.</span></p><p><span>Callbacks passed to </span><span><code>Type.map</code></span><span> are labelled to match the enclosing function; and since they usually close over the subexpression AST, they&#x27;re annotated with the AST for context. So the callback in </span><span><code>synthBinary</code></span><span> for an addition is labelled </span><span><code>...synthBinary[_ + _]</code></span><span>.</span></p><iframe src="https://jaked.org/reconstructing-typescript/part5/" width="700" height="500" style="border-style:none"></iframe><h2 id="the-plan"><span>The plan</span></h2><p><span>For the full code of part 5 see </span><a href="https://github.com/jaked/reconstructing-typescript/tree/part5" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/tree/part5</span></a><span>. To view the changes between part 4 and part 5 see </span><a href="https://github.com/jaked/reconstructing-typescript/compare/part4...part5" class="sc-gtsrHT kFWJEY"><span>https://github.com/jaked/reconstructing-typescript/compare/part4...part5</span></a><span>.</span></p><p><span>Next time we&#x27;ll finally implement </span><span><em>narrowing</em></span><span>!</span></p><ul><li><p><span></span><a href="/blog/2021-09-07-Reconstructing-TypeScript-part-0"><span>Part 0: intro and background</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-15-Reconstructing-TypeScript-part-1"><span>Part 1: bidirectional type checking</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-09-27-Reconstructing-TypeScript-part-2"><span>Part 2: functions and function calls</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-06-Reconstructing-TypeScript-part-3"><span>Part 3: operators and singleton types</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-14-Reconstructing-TypeScript-part-4"><span>Part 4: union types</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-10-28-Reconstructing-TypeScript-part-5"><span>Part 5: intersection types</span></a><span></span></p></li><li><p><span></span><a href="/blog/2021-11-11-Reconstructing-TypeScript-part-6"><span>Part 6: narrowing</span></a><span></span></p></li></ul><p><span>Please </span><a href="/blog/mailto%3Ajake%40donham.org"><span>email me</span></a><span> with comments, criticisms, or corrections.</span></p></div></body></html>